{"ast":null,"code":"/* global module */\n\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\nif (typeof module !== 'undefined' && typeof nerdamer === 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Algebra.js');\n}\n\n(function () {\n  \"use strict\";\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      Frac = core.Frac,\n      Settings = core.Settings,\n      isSymbol = core.Utils.isSymbol,\n      FN = core.groups.FN,\n      Symbol = core.Symbol,\n      text = core.Utils.text,\n      inBrackets = core.Utils.inBrackets,\n      isInt = core.Utils.isInt,\n      format = core.Utils.format,\n      even = core.Utils.even,\n      evaluate = core.Utils.evaluate,\n      N = core.groups.N,\n      S = core.groups.S,\n      FN = core.groups.FN,\n      PL = core.groups.PL,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      EX = core.groups.EX,\n      P = core.groups.P,\n      LOG = Settings.LOG,\n      EXP = 'exp',\n      ABS = 'abs',\n      SQRT = 'sqrt',\n      SIN = 'sin',\n      COS = 'cos',\n      TAN = 'tan',\n      SEC = 'sec',\n      CSC = 'csc',\n      COT = 'cot',\n      ASIN = 'asin',\n      ACOS = 'acos',\n      ATAN = 'atan',\n      ASEC = 'asec',\n      ACSC = 'acsc',\n      ACOT = 'acot',\n      SINH = 'sinh',\n      COSH = 'cosh',\n      TANH = 'tanh',\n      CSCH = 'csch',\n      SECH = 'sech',\n      COTH = 'coth',\n      ASECH = 'asech',\n      ACSCH = 'acsch',\n      ACOTH = 'acoth'; //custom errors\n\n  function NoIntegralFound(msg) {\n    this.message = msg || \"\";\n  }\n\n  NoIntegralFound.prototype = new Error(); //Preparations\n\n  Symbol.prototype.hasIntegral = function () {\n    return this.containsFunction('integrate');\n  }; //transforms a function\n\n\n  Symbol.prototype.fnTransform = function () {\n    if (this.group !== FN) return this;\n    var retval,\n        a = this.args[0];\n    var m = new Symbol(this.multiplier);\n    var sym = this.clone().toUnitMultiplier();\n\n    if (this.isLinear()) {\n      switch (this.fname) {\n        case SINH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\n          break;\n\n        case COSH:\n          retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\n          break;\n\n        case TANH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\n          break;\n\n        case TAN:\n          retval = _.parse(format('sin({0})/cos({0})', a));\n          break;\n\n        case CSC:\n          retval = _.parse(format('1/sin({0})', a));\n          break;\n\n        case SEC:\n          retval = _.parse(format('1/cos({0})', a));\n          break;\n\n        default:\n          retval = sym;\n      }\n    } else if (this.power.equals(2)) {\n      switch (this.fname) {\n        case SIN:\n          retval = _.parse(format('1/2-cos(2*({0}))/2', a));\n          break;\n\n        case COS:\n          retval = _.parse(format('1/2+cos(2*({0}))/2', a));\n          break;\n\n        case TAN:\n          //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\n          retval = _.parse(format('sin({0})^2/cos({0})^2', a));\n          break;\n\n        case COSH:\n          retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\n          break;\n\n        case SINH:\n          retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\n          break;\n\n        case TANH:\n          retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\n          break;\n\n        case SEC:\n          retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\n          break;\n\n        default:\n          retval = sym;\n      }\n    } else if (this.fname === SEC) {\n      retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === CSC) {\n      retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === TAN) {\n      if (this.power.lessThan(0)) {\n        retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\n      } else {\n        retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\n      }\n    } else if (this.fname === SIN && this.power.lessThan(0)) {\n      retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === COS && this.power.lessThan(0)) {\n      retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === SIN && this.power.equals(3)) {\n      retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\n    } else if (this.fname === COS && this.power.equals(3)) {\n      retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\n    } //cos(a*x)^(2*n) or sin(a*x)^(2*n)\n    else if ((this.fname === COS || this.fname === SIN) && even(this.power)) {\n        var n = this.power / 2; //convert to a double angle\n\n        var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform(); //raise to the n and expand\n\n\n        var transformed = _.expand(_.pow(double_angle, _.parse(n)));\n\n        retval = new Symbol(0);\n        transformed.each(function (s) {\n          var t = s.fnTransform();\n          retval = _.add(retval, t);\n        }, true);\n      } else retval = sym;\n\n    return _.multiply(retval, m);\n  };\n\n  Symbol.prototype.hasTrig = function () {\n    if (this.isConstant(true) || this.group === S) return false;\n    if (this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname))) return true;\n\n    if (this.symbols) {\n      for (var x in this.symbols) if (this.symbols[x].hasTrig()) return true;\n    }\n\n    return false;\n  };\n\n  core.Expression.prototype.hasIntegral = function () {\n    return this.symbol.hasIntegral();\n  };\n  /**\r\n   * Attempts to rewrite a symbol under one common denominator\r\n   * @param {Symbol} symbol \r\n   */\n\n\n  core.Utils.toCommonDenominator = function (symbol) {\n    //transform x/a+x -> (ax+x)/a\n    if (symbol.isComposite() && symbol.isLinear()) {\n      var m = new Symbol(symbol.multiplier);\n      var denominator = new Symbol(1);\n      var numerator = new Symbol(0);\n      symbol.each(function (x) {\n        denominator = _.multiply(denominator, x.getDenom());\n      }, true); //remove the denomitor in each term\n\n      symbol.each(function (x) {\n        var num = x.getNum();\n        var den = x.getDenom();\n\n        var factor = _.multiply(num, _.divide(denominator.clone(), den));\n\n        numerator = _.add(numerator, factor);\n      });\n\n      var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\n\n      return retval;\n    }\n\n    return symbol;\n  }; //A function to check if a function name is an inverse trig function\n\n\n  core.Utils.in_inverse_trig = function (x) {\n    var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\n    return inv_trig_fns.indexOf(x) !== -1;\n  }; //A function to check if a function name is a trig function\n\n\n  core.Utils.in_trig = function (x) {\n    var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\n    return trig_fns.indexOf(x) !== -1;\n  };\n\n  core.Utils.in_htrig = function (x) {\n    var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\n    return trig_fns.indexOf(x) !== -1;\n  }; // Matrix functions\n\n\n  core.Matrix.jacobian = function (eqns, vars) {\n    var jacobian = new core.Matrix(); //get the variables if not supplied\n\n    if (!vars) {\n      vars = core.Utils.arrayGetVariables(eqns);\n    }\n\n    vars.forEach(function (v, i) {\n      eqns.forEach(function (eq, j) {\n        var e = core.Calculus.diff(eq.clone(), v);\n        jacobian.set(j, i, e);\n      });\n    });\n    return jacobian;\n  };\n\n  core.Matrix.prototype.max = function () {\n    var max = new Symbol(0);\n    this.each(function (x) {\n      var e = x.abs();\n      if (e.gt(max)) max = e;\n    });\n    return max;\n  };\n\n  core.Matrix.cMatrix = function (value, vars) {\n    var m = new core.Matrix(); //make an initial guess\n\n    vars.forEach(function (v, i) {\n      m.set(i, 0, _.parse(value));\n    });\n    return m;\n  };\n\n  var all_functions = core.Utils.all_functions = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) if (arr[i].group !== FN) return false;\n\n    return true;\n  },\n      cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n    var a, b;\n    a = symbol1.args[0];\n    b = symbol2.args[0];\n    return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\n  },\n      cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\n    //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\n    //we technically know how to do this transform but more is needed for correct output\n    if (Number(symbol2.power) !== 1) return _.multiply(symbol1, symbol2);\n    var a;\n    a = symbol1.args[0];\n    return _.parse(format('(sin(2*({0})))/2', a));\n  },\n      sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n    var a, b;\n    a = symbol1.args[0];\n    b = symbol2.args[0];\n    return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\n  },\n      trigTransform = core.Utils.trigTransform = function (arr) {\n    var map = {},\n        symbol,\n        t,\n        retval = new Symbol(1);\n\n    for (var i = 0, l = arr.length; i < l; i++) {\n      symbol = arr[i];\n\n      if (symbol.group === FN) {\n        var fname = symbol.fname;\n\n        if (fname === COS && map[SIN]) {\n          if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n            t = cosAsinBtransform(symbol, map[SIN]);\n          } else {\n            t = cosAsinAtransform(symbol, map[SIN]);\n          }\n\n          delete map[SIN];\n          retval = _.multiply(retval, t);\n        } else if (fname === SIN && map[COS]) {\n          if (map[COS].args[0].toString() !== symbol.args[0].toString()) {\n            t = cosAsinBtransform(symbol, map[COS]);\n          } else {\n            t = cosAsinAtransform(symbol, map[COS]);\n          }\n\n          delete map[COS];\n          retval = _.multiply(retval, t);\n        } else if (fname === SIN && map[SIN]) {\n          if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n            t = sinAsinBtransform(symbol, map[SIN]);\n            delete map[SIN];\n          } else {\n            //This should actually be redundant code but let's put just in case\n            t = _.multiply(symbol, map[SIN]);\n            delete map[SIN];\n          }\n\n          retval = t;\n        } else {\n          map[fname] = symbol;\n        }\n      } else retval = _.multiply(retval, symbol);\n    } //put back the remaining functions\n\n\n    for (var x in map) retval = _.multiply(retval, map[x]);\n\n    return retval;\n  };\n\n  core.Settings.integration_depth = 10;\n  core.Settings.max_lim_depth = 10;\n\n  var __ = core.Calculus = {\n    version: '1.4.6',\n    sum: function (fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        start = Number(start);\n        end = Number(end);\n        retval = core.Utils.block(modifier, function () {\n          var f = fn.text(),\n              subs = {\n            '~': true\n          },\n              //lock subs. Is this even being used?\n          retval = new core.Symbol(0);\n\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n\n            var ans = _.parse(f, subs);\n\n            retval = _.add(retval, ans);\n          }\n\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('sum', arguments);\n      }\n\n      return retval;\n    },\n    product: function (fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        retval = core.Utils.block(modifier, function () {\n          start = Number(start);\n          end = Number(end.multiplier);\n          var f = fn.text(),\n              subs = {},\n              retval = new core.Symbol(1);\n\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n            retval = _.multiply(retval, _.parse(f, subs));\n          }\n\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('product', arguments);\n      }\n\n      return retval;\n    },\n    diff: function (symbol, wrt, nth) {\n      if (core.Utils.isVector(symbol)) {\n        var vector = new core.Vector([]);\n        symbol.each(function (x) {\n          vector.elements.push(__.diff(x, wrt, nth));\n        });\n        return vector;\n      } else if (core.Utils.isMatrix(symbol)) {\n        var matrix = new core.Matrix();\n        symbol.each(function (x, i, j) {\n          matrix.set(i, j, __.diff(x, wrt, nth));\n        });\n        return matrix;\n      }\n\n      var d = isSymbol(wrt) ? wrt.text() : wrt; //the nth derivative\n\n      nth = isSymbol(nth) ? nth.multiplier : nth || 1;\n      if (d === undefined) d = core.Utils.variables(symbol)[0]; //unwrap sqrt\n\n      if (symbol.group === FN && symbol.fname === SQRT) {\n        var s = symbol.args[0],\n            sp = symbol.power.clone(); //these groups go to zero anyway so why waste time?\n\n        if (s.group !== N || s.group !== P) {\n          s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\n          s.multiplier = s.multiplier.multiply(symbol.multiplier);\n        }\n\n        symbol = s;\n      }\n\n      if (symbol.group === FN && !isSymbol(symbol.power)) {\n        var a = derive(_.parse(symbol));\n\n        var b = __.diff(symbol.args[0].clone(), d);\n\n        symbol = _.multiply(a, b); //chain rule\n      } else {\n        symbol = derive(symbol);\n      }\n\n      if (nth > 1) {\n        nth--;\n        symbol = __.diff(symbol, wrt, nth);\n      }\n\n      return symbol; // Equivalent to \"derivative of the outside\".\n\n      function polydiff(symbol) {\n        if (symbol.value === d || symbol.contains(d, true)) {\n          symbol.multiplier = symbol.multiplier.multiply(symbol.power);\n          symbol.power = symbol.power.subtract(new Frac(1));\n\n          if (symbol.power.equals(0)) {\n            symbol = Symbol(symbol.multiplier);\n          }\n        }\n\n        return symbol;\n      }\n\n      function derive(symbol) {\n        var g = symbol.group,\n            a,\n            b,\n            cp;\n\n        if (g === N || g === S && symbol.value !== d || g === P) {\n          symbol = Symbol(0);\n        } else if (g === S) {\n          symbol = polydiff(symbol);\n        } else if (g === CB) {\n          var m = symbol.multiplier.clone();\n          symbol.toUnitMultiplier();\n\n          var retval = _.multiply(product_rule(symbol), polydiff(symbol));\n\n          retval.multiplier = retval.multiplier.multiply(m);\n          return retval;\n        } else if (g === FN && symbol.power.equals(1)) {\n          // Table of known derivatives\n          switch (symbol.fname) {\n            case LOG:\n              cp = symbol.clone();\n              symbol = symbol.args[0].clone(); //get the arguments\n\n              symbol.power = symbol.power.negate();\n              symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\n              break;\n\n            case COS:\n              //cos -> -sin\n              symbol.fname = SIN;\n              symbol.multiplier.negate();\n              break;\n\n            case SIN:\n              //sin -> cos\n              symbol.fname = COS;\n              break;\n\n            case TAN:\n              //tan -> sec^2\n              symbol.fname = SEC;\n              symbol.power = new Frac(2);\n              break;\n\n            case SEC:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, TAN);\n              break;\n\n            case CSC:\n              symbol = qdiff(symbol, '-cot');\n              break;\n\n            case COT:\n              symbol.fname = CSC;\n              symbol.multiplier.negate();\n              symbol.power = new Frac(2);\n              break;\n\n            case ASIN:\n              symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case ACOS:\n              symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case ATAN:\n              symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n\n            case ABS:\n              m = symbol.multiplier.clone();\n              symbol.toUnitMultiplier(); //depending on the complexity of the symbol it's easier to just parse it into a new symbol\n              //this should really be readdressed soon\n\n              b = symbol.args[0].clone();\n              b.toUnitMultiplier();\n              symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\n              symbol.multiplier = m;\n              break;\n\n            case 'parens':\n              //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\n              //1*g'\n              symbol = Symbol(1);\n              break;\n\n            case 'cosh':\n              //cosh -> -sinh\n              symbol.fname = 'sinh';\n              break;\n\n            case 'sinh':\n              //sinh -> cosh\n              symbol.fname = 'cosh';\n              break;\n\n            case TANH:\n              //tanh -> sech^2\n              symbol.fname = SECH;\n              symbol.power = new Frac(2);\n              break;\n\n            case SECH:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, '-tanh');\n              break;\n\n            case CSCH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\n              break;\n\n            case COTH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-csch(' + arg + ')^2');\n              break;\n\n            case 'asinh':\n              symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case 'acosh':\n              symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case 'atanh':\n              symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n\n            case ASECH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\n              break;\n\n            case ACOTH:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\n              break;\n\n            case ACSCH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\n              break;\n\n            case ASEC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n\n            case ACSC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n\n            case ACOT:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\n              break;\n\n            case 'S':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\n              break;\n\n            case 'C':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\n              break;\n\n            case 'Si':\n              var arg = symbol.args[0];\n              symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Shi':\n              var arg = symbol.args[0];\n              symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Ci':\n              var arg = symbol.args[0];\n              symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Chi':\n              var arg = symbol.args[0];\n              symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Ei':\n              var arg = symbol.args[0];\n              symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Li':\n              var arg = symbol.args[0];\n              symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\n              break;\n\n            case 'erf':\n              symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\n              break;\n\n            case 'atan2':\n              var x_ = String(symbol.args[0]),\n                  y_ = String(symbol.args[1]);\n              symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\n              break;\n\n            case 'sign':\n              symbol = new Symbol(0);\n              break;\n\n            case 'sinc':\n              symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\n              break;\n\n            case Settings.LOG10:\n              symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\n              break;\n\n            default:\n              symbol = _.symfunction('diff', [symbol, wrt]);\n          }\n        } else if (g === EX || g === FN && isSymbol(symbol.power)) {\n          var value;\n\n          if (g === EX) {\n            value = symbol.value;\n          } else if (g === FN && symbol.contains(d)) {\n            value = symbol.fname + inBrackets(text(symbol.args[0]));\n          } else {\n            value = symbol.value + inBrackets(text(symbol.args[0]));\n          }\n\n          a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\n          b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\n          symbol = _.multiply(symbol, b);\n        } else if (g === FN && !symbol.power.equals(1)) {\n          b = symbol.clone();\n          b.toLinear();\n          b.toUnitMultiplier();\n          symbol = _.multiply(polydiff(symbol.clone()), derive(b));\n        } else if (g === CP || g === PL) {\n          // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\n          var c = symbol.clone();\n          var result = new Symbol(0);\n\n          for (var x in symbol.symbols) {\n            result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\n          }\n\n          symbol = _.multiply(polydiff(c), result);\n        }\n\n        symbol.updateHash();\n        return symbol;\n      }\n\n      ;\n\n      function qdiff(symbol, val, altVal) {\n        return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\n      }\n\n      ;\n\n      function product_rule(symbol) {\n        //grab all the symbols within the CB symbol\n        var symbols = symbol.collectSymbols(),\n            result = new Symbol(0),\n            l = symbols.length; //loop over all the symbols\n\n        for (var i = 0; i < l; i++) {\n          var df = __.diff(symbols[i].clone(), d);\n\n          for (var j = 0; j < l; j++) {\n            //skip the symbol of which we just pulled the derivative\n            if (i !== j) {\n              //multiply out the remaining symbols\n              df = _.multiply(df, symbols[j].clone());\n            }\n          } //add the derivative to the result\n\n\n          result = _.add(result, df);\n        }\n\n        return result; //done\n      }\n\n      ;\n    },\n    integration: {\n      u_substitution: function (symbols, dx) {\n        function try_combo(a, b, f) {\n          var d = __.diff(b, dx);\n\n          var q = f ? f(a, b) : _.divide(a.clone(), d);\n          if (!q.contains(dx, true)) return q;\n          return null;\n        }\n\n        function do_fn_sub(fname, arg) {\n          var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\n\n          subbed = subbed.sub(new Symbol(u), arg);\n          subbed.updateHash();\n          return subbed;\n        }\n\n        var a = symbols[0].clone(),\n            b = symbols[1].clone(),\n            g1 = a.group,\n            g2 = b.group,\n            //may cause problems if person is using this already. Will need\n        //to find algorithm for detecting conflict\n        u = '__u__',\n            Q;\n\n        if (g1 === FN && g2 !== FN) {\n          //e.g. 2*x*cos(x^2)\n          var arg = a.args[0];\n          Q = try_combo(b, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(a.fname, arg));\n          Q = try_combo(b, a);\n\n          if (Q) {\n            return __.integration.poly_integrate(a);\n          }\n        } else if (g2 === FN && g1 !== FN) {\n          //e.g. 2*(x+1)*cos((x+1)^2\n          var arg = b.args[0];\n          Q = try_combo(a, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(b.fname, arg));\n        } else if (g1 === FN && g2 === FN) {\n          Q = try_combo(a.clone(), b.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(b.clone(), a.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n        } else if (g1 === EX && g2 !== EX) {\n          var p = a.power;\n          Q = try_combo(b, p.clone());\n\n          if (!Q) {\n            //one more try\n            var dc = __.integration.decompose_arg(p.clone(), dx); //consider the possibility of a^x^(n-1)*x^n dx\n\n\n            var xp = __.diff(dc[2].clone(), dx);\n\n            var dc2 = __.integration.decompose_arg(xp.clone(), dx); //if their powers equal, so if dx*p == b\n\n\n            if (_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\n              var m = _.divide(dc[0].clone(), dc2[0].clone());\n\n              var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\n\n              new_val = _.multiply(new_val, new Symbol(u));\n              return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\n            }\n          }\n\n          var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\n              retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\n\n          return retval;\n        } else if (g2 === EX && g1 !== EX) {\n          var p = b.power;\n          Q = try_combo(a, p.clone());\n\n          var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\n\n          return _.multiply(integrated.sub(new Symbol(u), p), Q);\n        } else if (a.isComposite() || b.isComposite()) {\n          var f = function (a, b) {\n            var d = __.diff(b, dx);\n\n            var A = core.Algebra.Factor.factor(a),\n                B = core.Algebra.Factor.factor(d);\n\n            var q = _.divide(A, B);\n\n            return q;\n          };\n\n          var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\n              f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\n          Q = try_combo(f1.clone(), f2.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(f2.clone(), f1.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(a), Q);\n        }\n      },\n      //simple integration of a single polynomial x^(n+1)/(n+1)\n      poly_integrate: function (x) {\n        var p = x.power.toString(),\n            m = x.multiplier.toDecimal(),\n            s = x.toUnitMultiplier().toLinear();\n\n        if (Number(p) === -1) {\n          return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\n        }\n\n        return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\n      },\n      //If we're just spinning wheels we want to stop. This is why we \n      //wrap integration in a try catch block and call this to stop.\n      stop: function (msg) {\n        msg = msg || 'Unable to compute integral!';\n        core.Utils.warn(msg);\n        throw new NoIntegralFound(msg);\n      },\n      partial_fraction: function (input, dx, depth, opt) {\n        //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\n        if (!isSymbol(dx)) dx = _.parse(dx);\n        var result, partial_fractions;\n        result = new Symbol(0);\n        partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\n\n        if (partial_fractions.group === CB && partial_fractions.isLinear()) {\n          //perform a quick check to make sure that all partial fractions are linear\n          partial_fractions.each(function (x) {\n            if (!x.isLinear()) __.integration.stop();\n          });\n          partial_fractions.each(function (x) {\n            result = _.add(result, __.integrate(x, dx, depth, opt));\n          });\n        } else {\n          result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\n        }\n\n        return result;\n      },\n      get_udv: function (symbol) {\n        var parts = [[\n          /*L*/\n        ], [\n          /*I*/\n        ], [\n          /*A*/\n        ], [\n          /*T*/\n        ], [\n          /*E*/\n        ]]; //first we sort them \n\n        var setSymbol = function (x) {\n          var g = x.group;\n\n          if (g === FN) {\n            var fname = x.fname;\n            if (core.Utils.in_trig(fname) || core.Utils.in_htrig(fname)) parts[3].push(x);else if (core.Utils.in_inverse_trig(fname)) parts[1].push(x);else if (fname === LOG) parts[0].push(x);else {\n              __.integration.stop();\n            }\n          } else if (g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\n            parts[2].push(x);\n          } else if (g === EX || x.isComposite() && !x.isLinear()) parts[4].push(x);else __.integration.stop();\n        };\n\n        if (symbol.group === CB) symbol.each(function (x) {\n          setSymbol(Symbol.unwrapSQRT(x, true));\n        });else setSymbol(symbol);\n        var u,\n            dv = new Symbol(1); //compile u and dv\n\n        for (var i = 0; i < 5; i++) {\n          var part = parts[i],\n              t,\n              l = part.length;\n\n          if (l > 0) {\n            if (l > 1) {\n              t = new Symbol(1);\n\n              for (var j = 0; j < l; j++) t = _.multiply(t, part[j].clone());\n            } else t = part[0].clone();\n\n            if (!u) {\n              u = t; //the first u encountered gets chosen\n\n              u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\n            } else dv = _.multiply(dv, t); //everything else belongs to dv\n\n          }\n        }\n\n        return [u, dv];\n      },\n      trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\n        parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\n        var b = parts[3],\n            ax = parts[2],\n            a = parts[0],\n            x = parts[1];\n\n        if (x.power.equals(2) && a.greaterThan(0)) {\n          //use tan(x)\n          var t = core.Utils.getU(symbol),\n              //get an appropriate u\n          u = _.parse(TAN + inBrackets(t)),\n              //u\n          du = _.parse(SEC + inBrackets(t) + '^2'),\n              //du\n          f = _.multiply(symbol.sub(x, u), du);\n\n          var integral = __.integrate(f, t, depth, opt).sub(u, x);\n\n          core.Utils.clearU(u);\n          return integral;\n        }\n      },\n      by_parts: function (symbol, dx, depth, o) {\n        o.previous = o.previous || [];\n        var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s; //first LIATE\n\n        udv = __.integration.get_udv(symbol);\n        u = udv[0];\n        dv = udv[1];\n        du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\n        c = du.clone().stripVar(dx); //strip any coefficients\n\n        du = _.divide(du, c.clone());\n        v = __.integrate(dv.clone(), dx, depth || 0);\n        vdu = _.multiply(v.clone(), du);\n        vdu_s = vdu.toString(); //currently only supports e^x*(some trig)\n\n        if (o.previous.indexOf(vdu_s) !== -1 && core.Utils.in_trig(u.fname) && dv.isE()) {\n          //We're going to exploit the fact that vdu can never be constant\n          //to work out way out of this cycle. We'll return the length of\n          //the this.previous array until we're back at level one\n          o.is_cyclic = true; //return the integral. \n\n          return new Symbol(1);\n        } else o.previous.push(vdu_s);\n\n        uv = _.multiply(u, v); //clear the multiplier so we're dealing with a bare integral\n\n        m = vdu.multiplier.clone();\n        vdu.toUnitMultiplier();\n        integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\n        integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\n        retval = _.subtract(uv, integral_vdu); //we know that there cannot be constants so they're a holdover from a cyclic integral\n\n        if (o.is_cyclic) {\n          //start popping the previous stack so we know how deep in we are\n          o.previous.pop();\n\n          if (o.previous.length === 0) {\n            retval = _.expand(retval);\n            var rem = new Symbol(0);\n            retval.each(function (x) {\n              if (!x.contains(dx)) rem = _.add(rem, x.clone());\n            }); //get the actual uv\n\n            retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\n          }\n        }\n\n        return retval;\n      },\n\n      /*\r\n       * dependents: [Solve, integrate]\r\n       */\n      decompose_arg: core.Utils.decompose_fn\n    },\n    //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\n    integrate: function (original_symbol, dt, depth, opt) {\n      //assume integration wrt independent variable if expression only has one variable\n      if (!dt) {\n        var vars = core.Utils.variables(original_symbol);\n        if (vars.length === 1) dt = vars[0]; //defaults to x\n\n        dt = dt || 'x';\n      } //add support for integrating vectors\n\n\n      if (core.Utils.isVector(original_symbol)) {\n        var vector = new core.Vector([]);\n        original_symbol.each(function (x) {\n          vector.elements.push(__.integrate(x, dt));\n        });\n        return vector;\n      }\n\n      if (!isNaN(dt)) _.error('variable expected but received ' + dt); //get rid of constants right away\n\n      if (original_symbol.isConstant(true)) return _.multiply(original_symbol.clone(), _.parse(dt)); //configurations options for integral. This is needed for tracking extra options\n      //e.g. cyclic integrals or additional settings\n\n      opt = opt || {};\n      return core.Utils.block('PARSE2NUMBER', function () {\n        //make a note of the original symbol. Set only if undefined\n        depth = depth || 0;\n        var dx = isSymbol(dt) ? dt.toString() : dt,\n            //we don't want the symbol in sqrt form. x^(1/2) is prefererred\n        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\n            g = symbol.group,\n            retval;\n\n        try {\n          //We stop integration after x amount of recursive calls\n          if (++depth > core.Settings.integration_depth) __.integration.stop('Maximum depth reached. Exiting!'); //constants. We first eliminate anything that doesn't have dx. Everything after this has \n          //to have dx or else it would have been taken care of below\n\n          if (!symbol.contains(dx, true)) {\n            retval = _.multiply(symbol.clone(), _.parse(dx));\n          } //e.g. 2*x\n          else if (g === S) {\n              retval = __.integration.poly_integrate(symbol, dx, depth);\n            } else if (g === EX) {\n              if (symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS)) __.integration.stop(); //check the base\n\n              if (symbol.contains(dx) && symbol.previousGroup !== FN) {\n                //if the symbol also contains dx then we stop since we currently \n                //don't know what to do with it e.g. x^x\n                if (symbol.power.contains(dx)) __.integration.stop();else {\n                  var t = __.diff(symbol.clone().toLinear(), dx);\n\n                  if (t.contains(dx)) __.integration.stop(); //since at this point it's the base only then we do standard single poly integration\n                  //e.g. x^y\n\n                  retval = __.integration.poly_integrate(symbol, dx, depth);\n                }\n              } //e.g. a^x or 9^x\n              else {\n                  var a = __.diff(symbol.power.clone(), dx);\n\n                  if (a.contains(dx)) {\n                    var aa = a.stripVar(dx),\n                        x = _.divide(a.clone(), aa.clone());\n\n                    if (x.group === S && x.isLinear()) {\n                      aa.multiplier = aa.multiplier.divide(new Frac(2));\n                      return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\n                    } else __.integration.stop();\n                  }\n\n                  if (symbol.isE()) {\n                    if (a.isLinear()) retval = symbol;else {\n                      if (a.isE() && a.power.group === S && a.power.power.equals(1)) retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);else __.integration.stop();\n                    }\n                  } else {\n                    var d = _.symfunction(LOG, [_.parse(symbol.value)]);\n\n                    retval = _.divide(symbol, d);\n                  }\n\n                  retval = _.divide(retval, a);\n                }\n            } else if (symbol.isComposite() && symbol.isLinear()) {\n              var m = _.parse(symbol.multiplier);\n\n              symbol.toUnitMultiplier();\n              retval = new Symbol(0);\n              symbol.each(function (x) {\n                retval = _.add(retval, __.integrate(x, dx, depth));\n              });\n              retval = _.multiply(m, retval);\n            } else if (g === CP) {\n              if (symbol.power.greaterThan(1)) symbol = _.expand(symbol);\n\n              if (symbol.power.equals(1)) {\n                retval = new Symbol(0);\n                symbol.each(function (x) {\n                  retval = _.add(retval, __.integrate(x, dx, depth));\n                }, true);\n              } else {\n                var p = Number(symbol.power),\n                    m = symbol.multiplier.clone(); //temporarily remove the multiplier\n\n                symbol.toUnitMultiplier();\n\n                var //below we consider the form ax+b\n                fn = symbol.clone().toLinear(),\n                    //get just the pure function without the power\n                decomp = __.integration.decompose_arg(fn, dx),\n                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\n                b = decomp[3],\n                    ax = decomp[2],\n                    a = decomp[0],\n                    x = decomp[1];\n\n                if (p === -1 && x.group !== PL && x.power.equals(2)) {\n                  var b_is_positive = isInt(b) ? b > 0 : true; //we can now check for atan\n\n                  if (x.group === S && x.power.equals(2) && b_is_positive) {\n                    ////then we have atan\n                    //abs is redundants since the sign appears in both denom and num.\n                    var unwrapAbs = function (s) {\n                      var result = new Symbol(1);\n                      s.each(function (x) {\n                        result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\n                      });\n                      return result;\n                    };\n\n                    var A = a.clone(),\n                        B = b.clone();\n                    A = _.pow(A, new Symbol(1 / 2));\n                    B = _.pow(B, new Symbol(1 / 2)); //unwrap abs\n\n                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\n                        f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\n\n                    retval = _.divide(f, d);\n                  } else if (x.group === S && x.isLinear()) {\n                    retval = _.divide(__.integration.poly_integrate(symbol), a);\n                  } else {\n                    //1/(x^4+1)\n                    if (x.power.equals(4)) {\n                      //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\n                      var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\n                      var br = inBrackets; //apply rule: ax^4+b = (√ax^2+√2∜a∜bx+√b)(√ax^2-√2∜a∜bx+√b)\n                      //get quadratic factors\n\n                      A = _.parse(SQRT + br(a) + '*' + dx + '^2');\n                      B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\n                      C = _.parse(SQRT + br(b));\n                      f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\n                      f2 = _.add(_.subtract(A, B), C); //calculate numerators: [D+E, D-E] -> [√2*b^(3/4)+√b∜ax, √2*b^(3/4)-√b∜ax]\n\n                      D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\n                      E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx); //let F = 2b√2∜b\n\n                      F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4')); //calculate the factors\n\n                      L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\n                      L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\n                      retval = _.add(__.integrate(L1, dx, depth, opt), __.integrate(L2, dx, depth, opt));\n                    } else //let's try partial fractions\n                      retval = __.integration.partial_fraction(symbol, dx, depth);\n                  }\n                } else if (p === -1 / 2) {\n                  //detect asin and atan\n                  if (x.group === S && x.power.equals(2)) {\n                    if (ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\n                      a.negate(); //it's asin\n\n                      if (b.isConstant() && a.isConstant()) {\n                        var d = _.symfunction(SQRT, [a.clone()]),\n                            d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\n\n                        retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\n                      } //I'm not sure about this one. I'm trusting Wolfram Alpha here\n                      else {\n                          var sqrt_a = _.symfunction(SQRT, [a]),\n                              sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\n\n                          retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\n                        }\n                    } else {\n                      /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\n                      __.integration.stop();\n                    }\n                  } else {\n                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\n                    __.integration.stop();\n                  }\n                } else {\n                  if (x.isLinear() && x.group !== PL) retval = _.divide(__.integration.poly_integrate(symbol), a);else if (x.power.equals(2) && a.greaterThan(0)) {\n                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv; //1/(a*x^2+b^2)^n\n                    //strip the value of b so b = 1\n\n                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\n\n                    sqb = _.parse(SQRT + inBrackets(b));\n                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\n                    bsqi = _.pow(b, new Symbol(symbol.power));\n                    uv = core.Utils.getU(symbol);\n                    u = _.multiply(aob, x.clone().toLinear());\n                    v = _.parse(ATAN + inBrackets(u)); //the conversion will be 1+tan(x)^2 -> sec(x)^2\n                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \n                    //then the remaining sec will be (n-1)*2;\n\n                    var n = (Math.abs(symbol.power) - 1) * 2; //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\n\n                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\n\n                    core.Utils.clearU(uv);\n                    return _.multiply(integral.sub(uv, v), bsqi);\n                  } else {\n                    if (symbol.group !== CB && !symbol.power.lessThan(0)) {\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                    } else {\n                      var f = symbol.clone().toLinear();\n                      var factored = core.Algebra.Factor.factor(f);\n                      var was_factored = factored.toString() !== f.toString();\n\n                      if (core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\n                        try {\n                          var f1, fx, u, sq;\n                          sq = core.Algebra.sqComplete(f, dx);\n                          u = core.Utils.getU(f);\n                          f1 = sq.f.sub(sq.a, u);\n                          fx = _.pow(f1, _.parse(symbol.power));\n                          retval = __.integrate(fx, u).sub(u, sq.a);\n                        } catch (e) {\n                          __.integration.stop();\n                        }\n                      } else retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                    }\n                  }\n                }\n\n                retval.multiplier = retval.multiplier.multiply(m);\n              }\n            } else if (g === FN) {\n              var arg = symbol.args[0],\n                  m = symbol.multiplier.clone();\n              symbol.toUnitMultiplier();\n\n              var decomp = __.integration.decompose_arg(arg, dx); //easies way I can think of to get the coefficient and to make sure\n              //that the symbol is linear wrt dx. I'm not actually trying to get the \n              //derivative\n\n\n              var a = decomp[0],\n                  x = decomp[1],\n                  fname = symbol.fname; //log is a special case that can be handled with integration by parts\n\n              if (fname === LOG || fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear()) {\n                /*integration by parts */\n                var p = symbol.power.toString();\n                if (isInt(p)) depth = depth - p; //it needs more room to find the integral\n\n                if (!arg.isComposite()) retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));else {\n                  //integral u du\n                  var u = core.Utils.getU(symbol);\n\n                  var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\n\n                  var du = __.diff(arg, dx);\n\n                  var u_du = _.multiply(f, du);\n\n                  var integral = __.integrate(u_du, u, depth, opt);\n\n                  retval = _.multiply(_.parse(m), integral.sub(u, arg));\n                }\n              } else if (fname === TAN && symbol.power.lessThan(0)) {\n                //convert to cotangent\n                var sym = symbol.clone();\n                sym.power.negate();\n                sym.fname = COT;\n                return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\n              } else {\n                if (!a.contains(dx, true) && symbol.isLinear()) {\n                  //perform a deep search for safety\n                  //first handle the special cases \n                  if (fname === ABS) {\n                    //REVISIT **TODO**\n                    var x = _.divide(arg.clone(), a.clone());\n\n                    if (x.group === S && !x.power.lessThan(0)) {\n                      if (core.Utils.even(x.power)) {\n                        retval = __.integrate(arg, dx, depth);\n                      } else {\n                        var integrated = __.integrate(x, dx, depth);\n\n                        integrated.power = integrated.power.subtract(new Frac(1));\n                        retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\n                      }\n                    } else __.integration.stop();\n                  } else {\n                    var ag = symbol.args[0].group,\n                        decomposed = __.integration.decompose_arg(arg, dx);\n\n                    if (!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc()) __.integration.stop();\n                    /**TODO**/\n                    //ASIN, ACOS, ATAN\n\n                    switch (fname) {\n                      case COS:\n                        retval = _.symfunction(SIN, [arg]);\n                        break;\n\n                      case SIN:\n                        retval = _.symfunction(COS, [arg]);\n                        retval.negate();\n                        break;\n\n                      case TAN:\n                        retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\n                        break;\n\n                      case SEC:\n                        retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\n                        break;\n\n                      case CSC:\n                        retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\n                        break;\n\n                      case COT:\n                        retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\n                        break;\n\n                      case SINH:\n                        retval = _.symfunction(COSH, [arg]);\n                        break;\n\n                      case COSH:\n                        retval = _.symfunction(SINH, [arg]);\n                        break;\n\n                      case TANH:\n                        retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\n                        break;\n\n                      case ASEC:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACSC:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACOT:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n                      //inverse htrig\n\n                      case ASECH:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACSCH:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACOTH:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n                      //end inverse htrig\n                      //htrigh\n\n                      case SECH:\n                        retval = _.parse(format('atan(sinh({0}))', arg));\n                        break;\n\n                      case CSCH:\n                        retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\n                        break;\n\n                      case COTH:\n                        retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\n                        break;\n                      //end htrig\n\n                      case EXP:\n                        retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\n                        break;\n\n                      case 'S':\n                        var arg = symbol.args[0].clone(),\n                            dc = __.integration.decompose_arg(arg, dx),\n                            x_ = dc[1],\n                            a_ = dc[0];\n\n                        var b_ = dc[3];\n                        retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\n                        break;\n\n                      case 'C':\n                        var arg = symbol.args[0].clone(),\n                            dc = __.integration.decompose_arg(arg, dx),\n                            x_ = dc[1],\n                            a_ = dc[0];\n\n                        var b_ = dc[3];\n                        retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\n                        break;\n\n                      case 'erf':\n                        var arg = symbol.args[0].clone(),\n                            dc = __.integration.decompose_arg(arg, dx),\n                            x_ = dc[1],\n                            a_ = dc[0];\n\n                        retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\n                        break;\n\n                      case 'sign':\n                        retval = _.multiply(symbol.clone(), arg.clone());\n                        break;\n\n                      default:\n                        __.integration.stop();\n\n                    }\n\n                    retval = _.divide(retval, a);\n                  }\n                } else if (x.isLinear()) {\n                  if (fname === COS || fname === SIN) {\n                    var p = Number(symbol.power); //check to see if it's negative and then just transform it to sec or csc\n\n                    if (p < 0) {\n                      symbol.fname = fname === SIN ? CSC : SEC;\n                      symbol.invert().updateHash();\n                      retval = __.integrate(symbol, dx, depth);\n                    } else {\n                      var arg = symbol.args[0],\n                          rd = symbol.clone(),\n                          //cos^(n-1)\n                      rd2 = symbol.clone(),\n                          //cos^(n-2)\n                      q = new Symbol((p - 1) / p),\n                          //\n                      na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\n\n\n                      rd.power = rd.power.subtract(new Frac(1));\n                      rd2.power = rd2.power.subtract(new Frac(2));\n\n                      var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\n\n                      if (fname === SIN) t.negate();\n                      retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\n                    }\n                  } //tan(x)^n or cot(x)^n\n                  else if (fname === TAN || fname === COT) {\n                      //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                      if (symbol.args[0].isLinear(dx)) {\n                        var n = symbol.power.subtract(new Frac(1)).toString(),\n                            r = symbol.clone().toUnitMultiplier(),\n                            w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\n\n                        r.power = r.power.subtract(new Frac(2));\n                        if (r.power.equals(0)) r = _.parse(r);\n                        retval = _.subtract(w, __.integrate(r, dx, depth));\n                      }\n                    } //sec(x)^n or csc(x)^n\n                    else if (fname === SEC || fname === CSC) {\n                        //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                        var n1 = symbol.power.subtract(new Frac(1)).toString(),\n                            n2 = symbol.power.subtract(new Frac(2)).toString(),\n                            f2 = fname === SEC ? TAN : COT,\n                            r = symbol.clone().toUnitMultiplier(),\n                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\n                            w = _.parse(parse_str);\n\n                        r.power = r.power.subtract(new Frac(2));\n                        if (r.power.equals(0)) r = _.parse(r);\n                        retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\n                      } else if ((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\n                        retval = __.integrate(symbol.fnTransform(), dx, depth);\n                      } else __.integration.stop();\n                } else __.integration.stop();\n\n                retval.multiplier = retval.multiplier.multiply(m);\n              }\n            } else if (g === PL) {\n              retval = __.integration.partial_fraction(symbol, dx, depth);\n            } else if (g === CB) {\n              var den = symbol.getDenom();\n              if (den.group === S) symbol = _.expand(symbol); //separate the coefficient since all we care about are symbols containing dx\n\n              var coeff = symbol.stripVar(dx); //now get only those that apply\n\n              var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\n              //peform a correction for stripVar. This is a serious TODO!\n\n\n              if (coeff.contains(dx)) {\n                cfsymbol = _.multiply(cfsymbol, coeff);\n                coeff = new Symbol(1);\n              } //if we only have one symbol left then let's not waste time. Just pull the integral\n              //and let the chips fall where they may\n\n\n              if (cfsymbol.group !== CB) {\n                if (cfsymbol.equals(1)) {\n                  return __.integrate(_.expand(symbol), dx, depth);\n                } //only factor for multivariate which are polynomials\n\n\n                if (cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\n                  cfsymbol = core.Algebra.Factor.factor(cfsymbol);\n                }\n\n                retval = __.integrate(cfsymbol, dx, depth);\n              } else {\n                //we collect the symbols and sort them descending group, descending power, descending alpabethically\n                var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\n                  if (a.group === b.group) {\n                    if (Number(a.power) === Number(b.power)) if (a < b) return 1; //I want sin first\n                    else return -1;\n                    return b.power - a.power; //descending power\n                  }\n\n                  return b.group - a.group; //descending groups\n                }).map(function (x) {\n                  var unwrapped = Symbol.unwrapSQRT(x, true);\n\n                  if (unwrapped.fname === EXP) {\n                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\n                  }\n\n                  return unwrapped;\n                });\n                var l = symbols.length;\n\n                if (symbol.power < 0) {\n                  if (l === 2) {\n                    return __.integrate(_.expand(symbol), dx, depth, opt);\n                  }\n                } //otherwise the denominator is one lumped together symbol \n                else {\n                    //generate an image for \n                    if (l === 2) {\n                      //try u substitution\n                      try {\n                        retval = __.integration.u_substitution(symbols, dx);\n                      } catch (e) {\n                        /* failed :`(*/\n                        ;\n                      }\n\n                      if (!retval) {\n                        //no success with u substitution so let's try known combinations\n                        //are they two functions\n                        var g1 = symbols[0].group,\n                            g2 = symbols[1].group,\n                            sym1 = symbols[0],\n                            sym2 = symbols[1],\n                            fn1 = sym1.fname,\n                            fn2 = sym2.fname; //reset the symbol minus the coeff\n\n                        symbol = _.multiply(sym1.clone(), sym2.clone());\n\n                        if (g1 === FN && g2 === FN) {\n                          if (fn1 === LOG || fn2 === LOG) {\n                            retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\n                          } else {\n                            symbols.sort(function (a, b) {\n                              return b.fname > a.fname;\n                            });\n                            var arg1 = sym1.args[0]; //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\n\n                            if (!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S)) __.integration.stop();\n\n                            var decomp = __.integration.decompose_arg(arg1, dx);\n\n                            x = decomp[1], a = decomp[0];\n                            if (!x.isLinear()) //again... linear arguments only wrt x\n                              __.integration.stop(); //they have to have the same arguments and then we have cleared all the check to \n                            //make sure we can integrate FN & FN\n\n                            var arg2 = sym2.args[0]; //make sure that their argument matches\n\n                            if (arg1.equals(arg2)) {\n                              if (fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\n                                if (sym1.power.lessThan(0)) __.integration.stop(); //we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\n                                //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\n\n                                if (fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\n                                  sym1.fname = TAN;\n                                  sym1.updateHash();\n                                  retval = __.integrate(sym1, dx, depth);\n                                } else {\n                                  if (even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\n                                    //transform sin^(2*n) to (1-cos^2)^n\n                                    var n = Number(sym1.power) / 2,\n                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\n\n                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                                  } else if (even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\n                                    //transform cos^(2*n) to (1-sin^2)^n\n                                    var n = Number(sym1.power) / 2,\n                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\n\n                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                                  } else {\n                                    var p1_even = core.Utils.even(sym1.power),\n                                        p2_even = core.Utils.even(sym2.power);\n                                    retval = new Symbol(0);\n\n                                    if (!p1_even || !p2_even) {\n                                      var u, r, trans; //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\n                                      //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\n\n                                      if (!p1_even) {\n                                        //u = sin(x)\n                                        u = sym2;\n                                        r = sym1;\n                                      } else {\n                                        u = sym1;\n                                        r = sym2;\n                                      } //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\n\n\n                                      var sign = u.fname === COS ? -1 : 1,\n                                          n = r.power,\n                                          //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \n                                      //even powers afterwards which can be transformed\n                                      k = (n - 1) / 2,\n                                          //make the transformation cos(x)^2 = 1 - sin(x)^2\n                                      trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\n                                          sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans))); //we can now just loop through and integrate each since it's now just a polynomial with functions\n\n\n                                      sym.each(function (x) {\n                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\n                                      });\n                                    } else {\n                                      //performs double angle transformation\n                                      var double_angle = function (symbol) {\n                                        var p = symbol.power,\n                                            k = p / 2,\n                                            e;\n                                        if (symbol.fname === COS) e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;else e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\n                                        return _.parse(e);\n                                      }; //they're both even so transform both using double angle identities and we'll just\n                                      //be able to integrate by the sum of integrals\n\n\n                                      var a = double_angle(sym1),\n                                          b = double_angle(sym2),\n                                          t = _.multiply(a, b);\n\n                                      var sym = _.expand(t);\n\n                                      sym.each(function (x) {\n                                        retval = _.add(retval, __.integrate(x, dx, depth));\n                                      });\n                                      return _.multiply(retval, coeff);\n                                    }\n                                  }\n                                }\n                              } //tan(x)*sec(x)^n \n                              else if (fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\n                                  retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\n                                } else if (fn1 === TAN && fn2 === SEC && x.isLinear()) {\n                                  //remaining: tan(x)^3*sec(x)^6\n                                  if (sym1.isLinear() && sym2.isLinear()) {\n                                    retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\n                                  } else if (even(sym1.power)) {\n                                    var p = Number(sym1.power) / 2; //transform tangent\n\n                                    var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\n\n                                    retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\n                                  } else __.integration.stop();\n                                } else if (fn1 === SEC && fn2 === COS) {\n                                  sym1.fname = COS;\n                                  sym1.invert().updateHash();\n                                  retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                                } else if (fn1 === SIN && fn2 === CSC) {\n                                  sym2.fname = SIN;\n                                  sym2.invert().updateHash();\n                                  retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                                } //tan/cos\n                                else if (fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\n                                    var t = _.multiply(sym1.fnTransform(), sym2);\n\n                                    retval = __.integrate(_.expand(t), dx, depth);\n                                  } else {\n                                    var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\n\n                                    retval = __.integrate(_.expand(t), dx, depth);\n                                  }\n                            } //TODO: In progress\n                            else if ((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\n                                if (sym1.isLinear() && sym2.isLinear()) {\n                                  //if in the form cos(a*x)*sin(b*x)\n                                  if (sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\n                                    //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\n                                    var ax, bx;\n\n                                    if (fn2 === SIN) {\n                                      ax = sym1.args[0];\n                                      bx = sym2.args[0];\n                                    } else {\n                                      bx = sym1.args[0];\n                                      ax = sym2.args[0];\n                                    } //make the transformation\n\n\n                                    f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString())); //integrate it\n\n                                    retval = __.integrate(f, dx, depth);\n                                  } else {\n                                    var transformed = trigTransform(symbols);\n                                    retval = __.integrate(_.expand(transformed), dx, depth);\n                                  }\n                                } else {\n                                  var transformed = new Symbol(1);\n                                  symbols.map(function (sym) {\n                                    var s = sym.fnTransform();\n                                    transformed = _.multiply(transformed, s);\n                                  });\n\n                                  var t = _.expand(transformed);\n\n                                  retval = __.integrate(t, dx, depth);\n\n                                  if (retval.hasIntegral()) {\n                                    retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\n                                  }\n                                }\n                              } else {\n                                __.integration.stop();\n                              }\n                          }\n                        } else if (g1 === FN && g2 === S) {\n                          var sym1_is_linear = sym1.isLinear();\n                          if (sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Ci', [sym1.args[0]]);else if (sym1.fname === COS && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Chi', [sym1.args[0]]);else if (sym1.fname === COSH && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Si', [sym1.args[0]]);else if (sym1.fname === SIN && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Shi', [sym1.args[0]]);else if (sym1.fname === SINH && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === LOG && sym2.power.equals(-1)) {\n                            //log(x)^n/x = log(x)^(n+1)/(n+1)\n                            retval = __.integration.poly_integrate(sym1, dx, depth);\n                          } else if (sym1.fname === 'erf') {\n                            if (sym2.power.equals(1)) {\n                              var dc = __.integration.decompose_arg(sym1.args[0], dx),\n                                  a_ = dc[0],\n                                  x_ = dc[1],\n                                  arg = sym1.args[0].toString();\n\n                              retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg));\n                            }\n                          } else {\n                            //since group S is guaranteed convergence we need not worry about tracking depth of integration\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          }\n                        } else if (g1 === EX && g2 === S) {\n                          var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\n\n                          if (sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\n                            retval = _.symfunction('Ei', [sym1.power.clone()]);\n                          } else if (fn1 === LOG && x.value === sym2.value) {\n                            retval = __.integration.poly_integrate(sym1, dx, depth);\n                          } else retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        } else if (g1 === PL && g2 === S) {\n                          //first try to reduce the top\n                          if (sym2.value === sym1.value && sym1.power.equals(-1)) {\n                            //find the lowest power in the denominator\n                            var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols)); //get the lowest common value between denominator and numerator\n\n                            var pc = Math.min(pd, sym2.power); //reduce both denominator and numerator by that factor\n\n                            var factor = sym2.clone();\n                            factor.power = new Frac(pc);\n                            sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\n\n                            var t = new Symbol(0);\n                            sym1.each(function (x) {\n                              t = _.add(t, _.divide(x.clone(), factor.clone()));\n                            });\n                            t.multiplier = sym1.multiplier;\n                            symbol = _.divide(sym2, t);\n                          } else {\n                            symbol = _.expand(symbol);\n                          }\n\n                          retval = __.integration.partial_fraction(symbol, dx, depth);\n                        } else if (g1 === CP && g2 === S) {\n                          var f = sym1.clone().toLinear(),\n                              f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1); //handle cases x^(2*n)/sqrt(1-x^2)\n\n                          if (sym1.power.equals(-1 / 2)) {\n                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\n\n                            var a = decomp[0].negate(),\n                                x = decomp[1],\n                                b = decomp[3],\n                                p1 = Number(sym1.power),\n                                p2 = Number(sym2.power);\n\n                            if (isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\n                              //if the substitution \n                              var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)), _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])), _.pow(a.clone(), new Symbol(2)));\n\n                              c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\n\n                              var dummy = _.parse('sin(u)');\n\n                              dummy.power = dummy.power.multiply(sym2.power);\n\n                              var integral = __.integrate(dummy, 'u', depth);\n\n                              var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\n\n                              retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\n                            } else if (p1 === -1 / 2) {\n                              var u_transform = function (f, u) {\n                                var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\n\n                                if (!integral.hasIntegral()) return integral;\n                              };\n\n                              if (p2 === -1) {\n                                retval = u_transform(_.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(), 'sqrt(1-1/({0})^2)');\n                              } else if (p2 === -2) {\n                                //apply transformation to see if it matches asin(x)\n                                retval = u_transform(_.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(), 'sqrt(1-1/({0})^2)');\n                              }\n                            }\n                          } else if (sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\n                            retval = __.integration.partial_fraction(symbol, dx, depth);\n                          } else if (!sym1.power.lessThan(0) && isInt(sym1.power)) {\n                            //sum of integrals\n                            var expanded = _.expand(sym1);\n\n                            retval = new Symbol(0);\n                            expanded.each(function (x) {\n                              if (x.group === PL) {\n                                x.each(function (y) {\n                                  retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\n                                });\n                              } else retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\n                            });\n                          } else if (sym1.power.lessThan(-2)) {\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          } else if (sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\n                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                                a = decomp[0].negate(),\n                                x = decomp[1],\n                                b = decomp[3],\n                                fn = sym1.clone().toLinear();\n\n                            if (x.group !== PL && x.isLinear()) {\n                              var p = Number(sym2.power),\n                                  du = '_u_',\n                                  u = new Symbol(du),\n                                  //pull the integral with the subsitution\n                              U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\n                                  scope = {}; //generate a scope for resubbing the symbol\n\n\n                              scope[du] = fn;\n\n                              var U2 = _.parse(U, scope);\n\n                              retval = __.integrate(U2, dx, 0);\n                            } else if (sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\n                              //factor out coefficients\n                              var factors = new core.Algebra.Classes.Factors();\n                              sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\n                              var div = core.Algebra.divide(sym2, sym1); //it assumed that the result will be of group CB\n\n                              if (div.group !== CB) {\n                                retval = new Symbol(0);\n                                div.each(function (t) {\n                                  retval = _.add(retval, __.integrate(t, dx, depth));\n                                }); //put back the factors\n\n                                factors.each(function (factor) {\n                                  retval = _.divide(retval, factor);\n                                });\n                                retval = _.expand(retval);\n                              } else {\n                                //try something else\n                                retval = __.integration.by_parts(symbol, dx, depth, opt);\n                              }\n                            } else retval = __.integration.partial_fraction(symbol, dx, depth);\n                          } else {\n                            //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \n                            if (sym1.power.den.equals(2)) {\n                              //assume the function is in the form (a^2-b*x^n)^(m/2)\n                              var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                                  //using the above definition\n                              a = dc[3],\n                                  x = dc[1],\n                                  b = dc[0],\n                                  bx = dc[2];\n\n                              if (x.power.equals(2) && b.lessThan(0)) {\n                                //if n is even && b is negative\n                                //make a equal 1 so we can do a trig sub\n                                if (!a.equals(1)) {\n                                  //divide a out of everything\n                                  //move a to the coeff\n                                  coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\n                                }\n\n                                var u = dx;\n\n                                var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\n                                    du = _.symfunction(COS, [new Symbol(u)]),\n                                    cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\n                                    X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\n                                    val = _.multiply(_.multiply(cosn, du), X),\n                                    integral = __.integrate(val, u, depth); //but remember that u = asin(sqrt(b)*a*x)\n\n\n                                retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\n                              } else {\n                                retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                              }\n                            } else if (f_is_linear) {\n                              retval = __.integration.partial_fraction(symbol, dx, depth);\n                            }\n                          }\n                        } else if (sym1.isComposite() && sym2.isComposite()) {\n                          //sum of integrals\n                          retval = new Symbol(0);\n\n                          if (sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\n                            //combine and pull the integral of each\n                            var sym = _.expand(symbol);\n\n                            sym.each(function (x) {\n                              retval = _.add(retval, __.integrate(x, dx, depth));\n                            }, true);\n                          } else {\n                            var p1 = Number(sym1.power),\n                                p2 = Number(sym2.power);\n\n                            if (p1 < 0 && p2 > 0) {\n                              //swap\n                              var t = sym1;\n                              sym1 = sym2;\n                              sym2 = t;\n                            }\n\n                            if (p1 === -1 && p2 === -1) {\n                              retval = __.integration.partial_fraction(symbol, dx);\n                            } else {\n                              sym1.each(function (x) {\n                                var k = _.multiply(x, sym2.clone());\n\n                                var integral = __.integrate(k, dx, depth);\n\n                                retval = _.add(retval, integral);\n                              });\n                            }\n                          }\n                        } else if (g1 === CP && symbols[0].power.greaterThan(0)) {\n                          sym1 = _.expand(sym1);\n                          retval = new Symbol(0);\n                          sym1.each(function (x) {\n                            retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\n                          }, true);\n                        } else if (g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\n                          sym1 = sym1.fnTransform();\n                          retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\n                        } else if (g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\n                          if (g2 === FN && g1 === CP) {\n                            var t = sym1;\n                            sym1 = sym2;\n                            sym2 = t; //swap\n                          }\n\n                          var du, sym2_clone, p, q, sa, sb;\n                          du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\n                          sym2_clone = Symbol.unwrapSQRT(sym2, true);\n\n                          if (du.power.equals(sym2_clone.power)) {\n                            p = new Symbol(sym2.power);\n                            sa = du.clone().toLinear();\n                            sb = sym2.clone().toLinear();\n                            q = core.Algebra.divide(sa.toLinear(), sb);\n\n                            if (q.isConstant()) {\n                              var nq = _.pow(q, p.negate());\n\n                              retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\n                            }\n                          } else {\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          }\n                        } else {\n                          var syma = sym1.clone().toLinear();\n                          var symb = sym2.clone().toLinear();\n\n                          if (g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx) && !syma.contains(dx) && !symb.contains(dx)) {\n                            retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))', syma.toString(), symb.toString(), sym1.power.multiplier.toString(), sym2.power.multiplier.toString(), dx));\n                          } else retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        }\n                      }\n                    } else if (l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\n                      var first = symbols[0];\n\n                      if (first.group === CP) {\n                        //TODO {support higher powers of x in the future}\n                        if (first.power.greaterThan(1)) first = _.expand(first);\n\n                        var r = _.multiply(symbols[1], symbols[2]);\n\n                        retval = new Symbol(0);\n                        first.each(function (x) {\n                          var t = _.multiply(x, r.clone());\n\n                          var intg = __.integrate(t, dx, depth);\n\n                          retval = _.add(retval, intg);\n                        }, true);\n                      } else {\n                        //try integration by parts although technically it will never work\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      }\n                    } else if (all_functions(symbols)) {\n                      var t = new Symbol(1);\n\n                      for (var i = 0, l = symbols.length; i < l; i++) {\n                        t = _.multiply(t, symbols[i].fnTransform());\n                      }\n\n                      t = _.expand(t);\n                      retval = __.integrate(t, dx, depth);\n                    } else {\n                      //one more go\n                      var transformed = trigTransform(symbols);\n                      retval = __.integrate(_.expand(transformed), dx, depth);\n                    }\n                  }\n              }\n\n              retval = _.multiply(retval, coeff);\n            } //if an integral was found then we return it\n\n\n          if (retval) return retval;\n        } catch (error) {\n          //do nothing if it's a NoIntegralFound error otherwise let it bubble\n          if (!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero)) throw error;\n        } //no symbol found so we return the integral again\n\n\n        return _.symfunction('integrate', [original_symbol, dt]);\n      }, false);\n    },\n    defint: function (symbol, from, to, dx) {\n      dx = dx || 'x'; //make x the default variable of integration\n\n      var get_value = function (integral, vars, point) {\n        try {\n          return _.parse(integral, vars);\n        } catch (e) {\n          //it failed for some reason so return the limit\n          var lim = __.Limit.limit(integral, dx, point);\n\n          return lim;\n        }\n      };\n\n      var vars = core.Utils.variables(symbol),\n          hasTrig = symbol.hasTrig();\n      var retval, integral; // Fix #593 - Only assume the first variable if dx is not defined.\n\n      if (vars.length === 1 && !dx) dx = vars[0];\n\n      if (!hasTrig) {\n        integral = __.integrate(symbol, dx);\n      }\n\n      if (!hasTrig && !integral.hasIntegral()) {\n        var upper = {},\n            lower = {},\n            a,\n            b;\n        upper[dx] = to;\n        lower[dx] = from;\n        a = get_value(integral, upper, to, dx);\n        b = get_value(integral, lower, from, dx);\n        retval = _.subtract(a, b);\n      } else if (vars.length === 1 && from.isConstant() && to.isConstant()) {\n        var f = core.Utils.build(symbol);\n        retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\n      } else retval = _.symfunction('defint', [symbol, from, to, dx]);\n\n      return retval;\n    },\n    Limit: {\n      interval: function (start, end) {\n        return _.parse(format('[{0}, {1}]', start, end));\n      },\n      diverges: function () {\n        return __.Limit.interval('-Infinity', 'Infinity');\n      },\n      divide: function (f, g, x, lim, depth) {\n        if (depth++ > Settings.max_lim_depth) {\n          return;\n        }\n\n        var fin = f.clone(),\n            gin = g.clone(); //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\n        //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\n        //the two-sided limit.\n        //Known limit\n\n        if (g.fname === ABS) {\n          var sign = f.sign();\n          var lim_sign = lim.sign();\n          if (lim.isInfinity) return _.multiply(new Symbol(sign), new Symbol(lim_sign));else if (lim.equals(0)) {\n            var fm = _.parse(f.multiplier);\n\n            var gm = _.parse(g.multiplier);\n\n            return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\n          } else {\n            //TODO: Support more limits\n            __.Limit.diverges();\n          }\n        }\n\n        var isInfinity = function (L) {\n          if (core.Utils.isVector(L)) {\n            for (var i = 0; i < L.elements.length; i++) if (!L.elements[i].isInfinity) return false;\n\n            return true;\n          }\n\n          return L.isInfinity;\n        };\n\n        var equals = function (L, v) {\n          if (core.Utils.isVector(L)) {\n            return false;\n          }\n\n          return L.equals(v);\n        };\n\n        var retval;\n\n        do {\n          var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\n          var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth)); //if it's in indeterminate form apply L'Hospital's rule\n\n          var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0); //pull the derivatives\n\n          if (indeterminate) {\n            var ft = __.diff(f.clone(), x);\n\n            var gt = __.diff(g.clone(), x);\n\n            var t_symbol = _.expand(_.divide(ft, gt));\n\n            f = t_symbol.getNum();\n            g = t_symbol.getDenom();\n          }\n        } while (indeterminate); //REMEMBER: \n        //- 1/cos(x)\n        //n/0 is still possible since we only checked for 0/0\n\n\n        var den_is_zero = lim2.equals(0);\n        var p = Number(gin.power);\n\n        if (lim.isConstant(true) && den_is_zero) {\n          retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\n        } else if (den_is_zero) {\n          retval = __.Limit.diverges();\n        } else {\n          retval = _.divide(lim1, lim2);\n        }\n\n        return retval;\n      },\n      rewriteToLog: function (symbol) {\n        var p = symbol.power.clone();\n        symbol.toLinear();\n        return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\n      },\n      getSubbed: function (f, x, lim) {\n        var retval; //1. rewrite EX with base e\n\n        if (f.group === EX) {\n          f = __.rewriteToLog(f);\n        } //2. try simple substitution\n\n\n        try {\n          retval = f.sub(x, lim);\n        } catch (e) {\n          //Nope. No go, so just return the unsubbed function so we can test the limit instead.\n          retval = f;\n        }\n\n        return retval;\n      },\n      isInterval: function (limit) {\n        return core.Utils.isVector(limit);\n      },\n      isConvergent: function (limit) {\n        //it's not convergent if it lies on the interval -Infinity to Infinity\n        if ( //It lies on the interval -Infinity to Infinity\n        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity || //We weren't able to calculate the limit\n        limit.containsFunction('limit')) {\n          return false; //Then no\n        }\n\n        return true; //It is\n      },\n      limit: function (symbol, x, lim, depth) {\n        //Simplify the symbol\n        if (symbol.isLinear() && symbol.isComposite()) {\n          //Apply sum of limits\n          var limit = new Symbol(0);\n          symbol.each(function (s) {\n            limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\n          }, true);\n          return limit;\n        }\n\n        ;\n        symbol = core.Algebra.Simplify.simplify(symbol);\n        depth = depth || 1;\n\n        if (depth++ > Settings.max_lim_depth) {\n          return;\n        } //store the multiplier\n\n\n        var m = _.parse(symbol.multiplier); //strip the multiplier\n\n\n        symbol.toUnitMultiplier();\n\n        try {\n          //https://en.wikipedia.org/wiki/List_of_limits\n          var retval; //we try the simplest option first where c is some limit\n          //lim a as x->c = a where c \n\n          if (symbol.isConstant(true)) {\n            retval = symbol;\n          } else {\n            var point = {};\n            point[x] = lim; //lim x as x->c = c where c\n\n            try {\n              //evaluate the function at the given limit\n              var t = _.parse(symbol.sub(x, lim), point); //a constant or infinity is known so we're done\n\n\n              if (t.isConstant(true) || t.isInfinity) retval = t;\n            } catch (e) {\n              /*Nothing. Maybe we tried to divide by zero.*/\n            }\n\n            ;\n\n            if (!retval) {\n              //split the symbol in the numerator and the denominator\n              var num = symbol.getNum();\n              var den = symbol.getDenom();\n\n              if (den.isConstant(true)) {\n                //We still don't have a limit so we generate tests.\n                if (symbol.group === EX) {\n                  //https://en.wikipedia.org/wiki/List_of_limits\n                  //Speed boost for exponentials by detecting patterns\n                  var f = symbol.clone().toLinear();\n                  var p = symbol.power.clone();\n\n                  var _num = f.getNum();\n\n                  var _den = f.getDenom();\n\n                  var fn = core.Utils.decompose_fn(_den, x, true); //start detection of pattern (x/(x+1))^x\n\n                  if (_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\n                    retval = _.parse(format('(1/e^({0}))', fn.b));\n                  } else {\n                    var symbol_ = __.Limit.rewriteToLog(symbol.clone()); //get the base\n\n\n                    var pow = symbol_.power.clone();\n                    var base = symbol_.clone().toLinear();\n\n                    var lim_base = __.Limit.limit(base, x, lim, depth);\n\n                    var lim_pow = __.Limit.limit(pow, x, lim, depth);\n\n                    retval = _.pow(lim_base, lim_pow);\n                  }\n                } else if (symbol.group === FN && symbol.args.length === 1) {\n                  var evaluates; //Squeeze theorem lim f(g(x)) = lim f(lim g))\n\n                  var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\n\n                  if (core.Utils.isVector(arg)) {\n                    //get the limit over that interval\n                    retval = arg.map(function (e) {\n                      var clone = symbol.clone();\n                      clone.args[0] = e;\n                      return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\n                    });\n                    return _.multiply(m, retval);\n                  } //if the argument is constant then we're done\n                  else if (arg.isConstant(true)) {\n                      //double check that it evaluates\n                      var trial = _.symfunction(symbol.fname, [arg]); //trial evaluation\n\n\n                      try {\n                        evaluate(trial);\n                        evaluates = true;\n                      } catch (e) {\n                        evaluates = false;\n                      }\n                    }\n\n                  if (evaluates) {\n                    retval = trial;\n                  } else {\n                    //if the limit converges. We'll deal with non-convergent ones later\n                    if (__.Limit.isConvergent(arg)) {\n                      if (symbol.fname === LOG) {\n                        switch (arg.toString()) {\n                          //lim -> 0\n                          case '0':\n                            retval = Symbol.infinity().negate();\n                            break;\n\n                          case 'Infinity':\n                            retval = Symbol.infinity();\n                            break;\n\n                          case '-Infinity':\n                            retval = Symbol.infinity();\n                            break;\n                        }\n                      } else if ((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\n                        retval = __.Limit.interval(-1, 1);\n                      } else if (symbol.fname === TAN) {\n                        var s_arg = symbol.args[0];\n                        var n = s_arg.getNum();\n                        var d = s_arg.getDenom();\n                        var pi = n.toUnitMultiplier();\n\n                        if (lim.isInfinity || pi.equals('pi') && d.equals(2)) {\n                          retval = divergent();\n                        }\n                      } else if (symbol.fname === Settings.FACTORIAL) {\n                        if (arg.isInfinity) return Symbol.infinity();\n                      }\n                    }\n                  }\n                } else if (symbol.group === S) {\n                  if (symbol.power > 0) //these functions always converge to the limit\n                    return _.parse(symbol, point);else {\n                    //we're dealing with 1/x^n but remember that infinity has already been dealt\n                    //with by substitution\n                    if (core.Utils.even(symbol.power)) {\n                      //even powers converge to infinity\n                      retval = Symbol.infinity();\n                    } else {\n                      //odd ones don't\n                      retval = __.Limit.diverges();\n                    }\n                  }\n                } else if (symbol.group === CB) {\n                  var lim1, lim2; //loop through all the symbols\n                  //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\n                  //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\n\n                  var symbols = symbol.collectSymbols().sort(function (a, b) {\n                    return a.group - b.group;\n                  });\n                  var f = symbols.pop(); //calculate the first limit so we can keep going down the list\n\n                  lim1 = evaluate(__.Limit.limit(f, x, lim, depth)); //reduces all the limits one at a time\n\n                  while (symbols.length) {\n                    //get the second limit\n                    var g = symbols.pop(); //get the limit of g\n\n                    lim2 = evaluate(__.Limit.limit(g, x, lim, depth)); //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\n\n                    if (lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2)) {\n                      if (g.containsFunction(LOG)) {\n                        //swap them\n                        g = [f, f = g][0];\n                      } //invert the symbol\n\n\n                      g.invert(); // Product of infinities\n\n                      if (lim1.isInfinity && lim2.isInfinity) {\n                        lim1 = Symbol.infinity();\n                      } else {\n                        lim1 = __.Limit.divide(f, g, x, lim, depth);\n                      }\n                    } else {\n                      //lim f*g = (lim f)*(lim g)\n                      lim1 = _.multiply(lim1, lim2); //let f*g equal f and h equal g \n\n                      f = _.multiply(f, g);\n                    }\n                  } //Done, lim1 is the limit we're looking for     \n\n\n                  retval = lim1;\n                } else if (symbol.isComposite()) {\n                  var _lim;\n\n                  if (!symbol.isLinear()) symbol = _.expand(symbol); //Apply lim f+g = (lim f)+(lim g)\n\n                  retval = new Symbol(0);\n                  var symbols = symbol.collectSymbols().sort(function (a, b) {\n                    return b.group - a.group;\n                  });\n                  var _symbols = []; //Analyze the functions first\n\n                  var fns = new Symbol(0);\n\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    var sym = symbols[i].clone();\n\n                    if (sym.group === FN || sym.group === CB && sym.hasFunc()) {\n                      fns = _.add(fns, sym);\n                    } else _symbols.push(sym);\n                  }\n\n                  _symbols.unshift(fns); //make sure that we didn't just repackage the exact same symbol\n\n\n                  if (_symbols.length !== 1) {\n                    symbols = _symbols;\n                  }\n\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    var sym = symbols[i]; //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\n\n                    try {\n                      _lim = __.Limit.limit(sym, x, lim, depth);\n                    } catch (e) {\n                      _lim = __.Limit.diverges();\n                    }\n\n                    try {\n                      retval = _.add(retval, _lim);\n                    } catch (e) {\n                      if (depth++ > Settings.max_lim_depth) {\n                        return;\n                      }\n\n                      ;\n                      retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\n                    }\n                  }\n                }\n              } else {\n                retval = __.Limit.divide(num, den, x, lim, depth);\n              }\n            }\n          } //if we still don't have a solution\n\n\n          if (!retval) //return it symbolically\n            retval = _.symfunction('limit', [symbol, x, lim]);\n        } catch (e) {\n          //if all else fails return the symbolic function\n          retval = _.symfunction('limit', [symbol, x, lim]);\n        }\n\n        return _.multiply(m, retval);\n      }\n    },\n    Fresnel: {\n      S: function (x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n\n        return _.symfunction('S', arguments);\n      },\n      C: function (x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n\n        return _.symfunction('C', arguments);\n      }\n    }\n  };\n\n  nerdamer.register([{\n    name: 'diff',\n    visible: true,\n    numargs: [1, 3],\n    build: function () {\n      return __.diff;\n    }\n  }, {\n    name: 'sum',\n    visible: true,\n    numargs: 4,\n    build: function () {\n      return __.sum;\n    }\n  }, {\n    name: 'product',\n    visible: true,\n    numargs: 4,\n    build: function () {\n      return __.product;\n    }\n  }, {\n    name: 'integrate',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      return __.integrate;\n    }\n  }, {\n    name: 'defint',\n    visible: true,\n    numargs: [3, 4],\n    build: function () {\n      return __.defint;\n    }\n  }, {\n    name: 'S',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Fresnel.S;\n    }\n  }, {\n    name: 'C',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Fresnel.C;\n    }\n  }, {\n    name: 'limit',\n    visible: true,\n    numargs: [3, 4],\n    build: function () {\n      return __.Limit.limit;\n    }\n  }]); //link registered functions externally\n\n  nerdamer.api();\n})();","map":{"version":3,"sources":["C:/Users/brisk/OneDrive/Documents/GitHub/seeciv/my-app/node_modules/nerdamer/Calculus.js"],"names":["module","nerdamer","require","core","getCore","_","PARSER","Frac","Settings","isSymbol","Utils","FN","groups","Symbol","text","inBrackets","isInt","format","even","evaluate","N","S","PL","CP","CB","EX","P","LOG","EXP","ABS","SQRT","SIN","COS","TAN","SEC","CSC","COT","ASIN","ACOS","ATAN","ASEC","ACSC","ACOT","SINH","COSH","TANH","CSCH","SECH","COTH","ASECH","ACSCH","ACOTH","NoIntegralFound","msg","message","prototype","Error","hasIntegral","containsFunction","fnTransform","group","retval","a","args","m","multiplier","sym","clone","toUnitMultiplier","isLinear","fname","parse","power","equals","lessThan","negate","n","double_angle","pow","toLinear","transformed","expand","each","s","t","add","multiply","hasTrig","isConstant","in_trig","in_inverse_trig","symbols","x","Expression","symbol","toCommonDenominator","isComposite","denominator","numerator","getDenom","num","getNum","den","factor","divide","Algebra","inv_trig_fns","indexOf","trig_fns","in_htrig","Matrix","jacobian","eqns","vars","arrayGetVariables","forEach","v","i","eq","j","e","Calculus","diff","set","max","abs","gt","cMatrix","value","all_functions","arr","l","length","cosAsinBtransform","cosAsinBtranform","symbol1","symbol2","b","cosAsinAtransform","cosAsinAtranform","Number","sinAsinBtransform","trigTransform","map","toString","integration_depth","max_lim_depth","__","version","sum","fn","index","start","end","exceptions","NerdamerTypeError","isNumericSymbol","modifier","block","f","subs","ans","symfunction","arguments","product","wrt","nth","isVector","vector","Vector","elements","push","isMatrix","matrix","d","undefined","variables","sp","derive","polydiff","contains","subtract","g","cp","product_rule","qdiff","arg","String","x_","y_","LOG10","c","result","updateHash","val","altVal","collectSymbols","df","integration","u_substitution","dx","try_combo","q","do_fn_sub","subbed","integrate","u","sub","g1","g2","Q","poly_integrate","p","dc","decompose_arg","xp","dc2","new_val","by_parts","integrated","A","Factor","B","f1","f2","toDecimal","stop","warn","partial_fraction","input","depth","opt","partial_fractions","PartFrac","partfrac","get_udv","parts","setSymbol","unwrapSQRT","dv","part","trig_sub","ax","greaterThan","getU","du","integral","clearU","o","previous","udv","vdu","uv","integral_vdu","vdu_s","stripVar","isE","is_cyclic","pop","rem","decompose_fn","original_symbol","dt","isNaN","error","previousGroup","PARENTHESIS","aa","decomp","b_is_positive","unwrapAbs","C","D","E","F","f3","f4","L1","L2","br","d2","sqrt_a","sqrt_ax","sqa","sqb","aob","bsqi","invert","Math","factored","was_factored","degree","fx","sq","sqComplete","u_du","ag","decomposed","hasFunc","a_","b_","rd","rd2","na","r","w","n1","n2","parse_str","coeff","cfsymbol","isPoly","sort","unwrapped","sym1","sym2","fn1","fn2","arg1","arg2","new_sym","p1_even","p2_even","trans","sign","k","bx","sym1_is_linear","pd","min","apply","keys","pc","f_is_linear","p1","p2","dummy","bksub","u_transform","sqrt","expanded","y","U","scope","U2","factors","Classes","Factors","coeffFactor","div","cosn","X","sym2_clone","sa","sb","nq","syma","symb","first","intg","DivisionByZero","defint","from","to","get_value","point","lim","Limit","limit","upper","lower","build","Math2","num_integrate","interval","diverges","fin","gin","lim_sign","isInfinity","fm","gm","L","lim1","lim2","indeterminate","ft","t_symbol","den_is_zero","infinity","rewriteToLog","getSubbed","isInterval","isConvergent","Simplify","simplify","_num","_den","isOne","symbol_","base","lim_base","lim_pow","evaluates","trial","s_arg","pi","divergent","FACTORIAL","_lim","_symbols","fns","unshift","Fresnel","register","name","visible","numargs","api"],"mappings":"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","sourcesContent":["/* global module */\r\n\r\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\nif((typeof module) !== 'undefined' && typeof nerdamer === 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Algebra.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            Frac = core.Frac,\r\n            Settings = core.Settings,\r\n            isSymbol = core.Utils.isSymbol,\r\n            FN = core.groups.FN,\r\n            Symbol = core.Symbol,\r\n            text = core.Utils.text,\r\n            inBrackets = core.Utils.inBrackets,\r\n            isInt = core.Utils.isInt,\r\n            format = core.Utils.format,\r\n            even = core.Utils.even,\r\n            evaluate = core.Utils.evaluate,\r\n            N = core.groups.N,\r\n            S = core.groups.S,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            EX = core.groups.EX,\r\n            P = core.groups.P,\r\n            LOG = Settings.LOG,\r\n            EXP = 'exp',\r\n            ABS = 'abs',\r\n            SQRT = 'sqrt',\r\n            SIN = 'sin',\r\n            COS = 'cos',\r\n            TAN = 'tan',\r\n            SEC = 'sec',\r\n            CSC = 'csc',\r\n            COT = 'cot',\r\n            ASIN = 'asin',\r\n            ACOS = 'acos',\r\n            ATAN = 'atan',\r\n            ASEC = 'asec',\r\n            ACSC = 'acsc',\r\n            ACOT = 'acot',\r\n            SINH = 'sinh',\r\n            COSH = 'cosh',\r\n            TANH = 'tanh',\r\n            CSCH = 'csch',\r\n            SECH = 'sech',\r\n            COTH = 'coth',\r\n            ASECH = 'asech',\r\n            ACSCH = 'acsch',\r\n            ACOTH = 'acoth';\r\n\r\n    //custom errors\r\n    function NoIntegralFound(msg) {\r\n        this.message = msg || \"\";\r\n    }\r\n    NoIntegralFound.prototype = new Error();\r\n\r\n    //Preparations\r\n    Symbol.prototype.hasIntegral = function () {\r\n        return this.containsFunction('integrate');\r\n    };\r\n    //transforms a function\r\n    Symbol.prototype.fnTransform = function () {\r\n        if(this.group !== FN)\r\n            return this;\r\n        var retval, a = this.args[0];\r\n        var m = new Symbol(this.multiplier);\r\n        var sym = this.clone().toUnitMultiplier();\r\n        if(this.isLinear()) {\r\n            switch(this.fname) {\r\n                case SINH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\r\n                    break;\r\n                case TAN:\r\n                    retval = _.parse(format('sin({0})/cos({0})', a));\r\n                    break;\r\n                case CSC:\r\n                    retval = _.parse(format('1/sin({0})', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('1/cos({0})', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.power.equals(2)) {\r\n            switch(this.fname) {\r\n                case SIN:\r\n                    retval = _.parse(format('1/2-cos(2*({0}))/2', a));\r\n                    break;\r\n                case COS:\r\n                    retval = _.parse(format('1/2+cos(2*({0}))/2', a));\r\n                    break;\r\n                case TAN:\r\n                    //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\r\n                    retval = _.parse(format('sin({0})^2/cos({0})^2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case SINH:\r\n                    retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.fname === SEC) {\r\n            retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === CSC) {\r\n            retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === TAN) {\r\n            if(this.power.lessThan(0)) {\r\n                retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\r\n            }\r\n            else {\r\n                retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\r\n            }\r\n        }\r\n        else if(this.fname === SIN && this.power.lessThan(0)) {\r\n            retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === COS && this.power.lessThan(0)) {\r\n            retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === SIN && this.power.equals(3)) {\r\n            retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\r\n        }\r\n        else if(this.fname === COS && this.power.equals(3)) {\r\n            retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\r\n        }\r\n        //cos(a*x)^(2*n) or sin(a*x)^(2*n)\r\n        else if((this.fname === COS || this.fname === SIN) && even(this.power)) {\r\n            var n = this.power / 2;\r\n            //convert to a double angle\r\n            var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();\r\n            //raise to the n and expand\r\n            var transformed = _.expand(_.pow(double_angle, _.parse(n)));\r\n\r\n            retval = new Symbol(0);\r\n\r\n            transformed.each(function (s) {\r\n                var t = s.fnTransform();\r\n                retval = _.add(retval, t);\r\n            }, true);\r\n        }\r\n        else\r\n            retval = sym;\r\n\r\n        return _.multiply(retval, m);\r\n    };\r\n\r\n    Symbol.prototype.hasTrig = function () {\r\n        if(this.isConstant(true) || this.group === S)\r\n            return false;\r\n        if(this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))\r\n            return true;\r\n        if(this.symbols) {\r\n            for(var x in this.symbols)\r\n                if(this.symbols[x].hasTrig())\r\n                    return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    core.Expression.prototype.hasIntegral = function () {\r\n        return this.symbol.hasIntegral();\r\n    };\r\n    /**\r\n     * Attempts to rewrite a symbol under one common denominator\r\n     * @param {Symbol} symbol \r\n     */\r\n    core.Utils.toCommonDenominator = function (symbol) {\r\n        //transform x/a+x -> (ax+x)/a\r\n        if(symbol.isComposite() && symbol.isLinear()) {\r\n            var m = new Symbol(symbol.multiplier);\r\n            var denominator = new Symbol(1);\r\n            var numerator = new Symbol(0);\r\n            symbol.each(function (x) {\r\n                denominator = _.multiply(denominator, x.getDenom());\r\n            }, true);\r\n\r\n            //remove the denomitor in each term\r\n            symbol.each(function (x) {\r\n                var num = x.getNum();\r\n                var den = x.getDenom();\r\n                var factor = _.multiply(num, _.divide(denominator.clone(), den));\r\n                numerator = _.add(numerator, factor);\r\n            });\r\n            var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\r\n            return retval;\r\n        }\r\n        return symbol;\r\n    };\r\n    //A function to check if a function name is an inverse trig function\r\n    core.Utils.in_inverse_trig = function (x) {\r\n        var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\r\n        return inv_trig_fns.indexOf(x) !== -1;\r\n    };\r\n    //A function to check if a function name is a trig function\r\n    core.Utils.in_trig = function (x) {\r\n        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    core.Utils.in_htrig = function (x) {\r\n        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    // Matrix functions\r\n    core.Matrix.jacobian = function (eqns, vars) {\r\n        var jacobian = new core.Matrix();\r\n        //get the variables if not supplied\r\n        if(!vars) {\r\n            vars = core.Utils.arrayGetVariables(eqns);\r\n        }\r\n\r\n        vars.forEach(function (v, i) {\r\n            eqns.forEach(function (eq, j) {\r\n                var e = core.Calculus.diff(eq.clone(), v);\r\n                jacobian.set(j, i, e);\r\n            });\r\n        });\r\n\r\n        return jacobian;\r\n    };\r\n\r\n    core.Matrix.prototype.max = function () {\r\n        var max = new Symbol(0);\r\n        this.each(function (x) {\r\n            var e = x.abs();\r\n            if(e.gt(max))\r\n                max = e;\r\n        });\r\n        return max;\r\n    };\r\n\r\n    core.Matrix.cMatrix = function (value, vars) {\r\n        var m = new core.Matrix();\r\n        //make an initial guess\r\n        vars.forEach(function (v, i) {\r\n            m.set(i, 0, _.parse(value));\r\n        });\r\n        return m;\r\n    };\r\n\r\n    var all_functions = core.Utils.all_functions = function (arr) {\r\n        for(var i = 0, l = arr.length; i < l; i++)\r\n            if(arr[i].group !== FN)\r\n                return false;\r\n        return true;\r\n    },\r\n            cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\r\n            },\r\n            cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\r\n                //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\r\n                //we technically know how to do this transform but more is needed for correct output\r\n                if(Number(symbol2.power) !== 1)\r\n                    return _.multiply(symbol1, symbol2);\r\n                var a;\r\n                a = symbol1.args[0];\r\n                return _.parse(format('(sin(2*({0})))/2', a));\r\n            },\r\n            sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\r\n            },\r\n            trigTransform = core.Utils.trigTransform = function (arr) {\r\n                var map = {}, symbol, t,\r\n                        retval = new Symbol(1);\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    symbol = arr[i];\r\n\r\n                    if(symbol.group === FN) {\r\n                        var fname = symbol.fname;\r\n\r\n                        if(fname === COS && map[SIN]) {\r\n\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[SIN]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[SIN]);\r\n                            }\r\n                            delete map[SIN];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[COS]) {\r\n                            if(map[COS].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[COS]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[COS]);\r\n                            }\r\n                            delete map[COS];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[SIN]) {\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = sinAsinBtransform(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n                            else {\r\n                                //This should actually be redundant code but let's put just in case\r\n                                t = _.multiply(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n\r\n                            retval = t;\r\n                        }\r\n                        else {\r\n                            map[fname] = symbol;\r\n                        }\r\n                    }\r\n                    else\r\n                        retval = _.multiply(retval, symbol);\r\n                }\r\n\r\n                //put back the remaining functions\r\n                for(var x in map)\r\n                    retval = _.multiply(retval, map[x]);\r\n\r\n                return retval;\r\n\r\n            };\r\n\r\n    core.Settings.integration_depth = 10;\r\n\r\n    core.Settings.max_lim_depth = 10;\r\n\r\n    var __ = core.Calculus = {\r\n\r\n        version: '1.4.6',\r\n\r\n        sum: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                start = Number(start);\r\n                end = Number(end);\r\n                retval = core.Utils.block(modifier, function () {\r\n                    var f = fn.text(),\r\n                            subs = {'~': true}, //lock subs. Is this even being used?\r\n                            retval = new core.Symbol(0);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        var ans = _.parse(f, subs);\r\n                        retval = _.add(retval, ans);\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('sum', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        product: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                retval = core.Utils.block(modifier, function () {\r\n                    start = Number(start);\r\n                    end = Number(end.multiplier);\r\n\r\n                    var f = fn.text(),\r\n                            subs = {},\r\n                            retval = new core.Symbol(1);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        retval = _.multiply(retval, _.parse(f, subs));\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('product', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        diff: function (symbol, wrt, nth) {\r\n            if(core.Utils.isVector(symbol)) {\r\n                var vector = new core.Vector([]);\r\n                symbol.each(function (x) {\r\n                    vector.elements.push(__.diff(x, wrt, nth));\r\n                });\r\n                return vector;\r\n            }\r\n            else if(core.Utils.isMatrix(symbol)) {\r\n                var matrix = new core.Matrix();\r\n                symbol.each(function (x, i, j) {\r\n                    matrix.set(i, j, __.diff(x, wrt, nth));\r\n                });\r\n                return matrix;\r\n            }\r\n\r\n            var d = isSymbol(wrt) ? wrt.text() : wrt;\r\n            //the nth derivative\r\n            nth = isSymbol(nth) ? nth.multiplier : nth || 1;\r\n\r\n            if(d === undefined)\r\n                d = core.Utils.variables(symbol)[0];\r\n\r\n            //unwrap sqrt\r\n            if(symbol.group === FN && symbol.fname === SQRT) {\r\n                var s = symbol.args[0],\r\n                        sp = symbol.power.clone();\r\n                //these groups go to zero anyway so why waste time?\r\n                if(s.group !== N || s.group !== P) {\r\n                    s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\r\n                    s.multiplier = s.multiplier.multiply(symbol.multiplier);\r\n                }\r\n\r\n                symbol = s;\r\n            }\r\n\r\n            if(symbol.group === FN && !isSymbol(symbol.power)) {\r\n                var a = derive(_.parse(symbol));\r\n                var b = __.diff(symbol.args[0].clone(), d);\r\n                symbol = _.multiply(a, b);//chain rule\r\n            }\r\n            else {\r\n                symbol = derive(symbol);\r\n            }\r\n\r\n            if(nth > 1) {\r\n                nth--;\r\n                symbol = __.diff(symbol, wrt, nth);\r\n            }\r\n\r\n            return symbol;\r\n\r\n            // Equivalent to \"derivative of the outside\".\r\n            function polydiff(symbol) {\r\n                if(symbol.value === d || symbol.contains(d, true)) {\r\n                    symbol.multiplier = symbol.multiplier.multiply(symbol.power);\r\n                    symbol.power = symbol.power.subtract(new Frac(1));\r\n                    if(symbol.power.equals(0)) {\r\n                        symbol = Symbol(symbol.multiplier);\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            }\r\n            \r\n            function derive(symbol) {\r\n                var g = symbol.group, a, b, cp;\r\n\r\n                if(g === N || g === S && symbol.value !== d || g === P) {\r\n                    symbol = Symbol(0);\r\n                }\r\n                else if(g === S) {\r\n                    symbol = polydiff(symbol);\r\n                }\r\n                else if(g === CB) {\r\n                    var m = symbol.multiplier.clone();\r\n                    symbol.toUnitMultiplier();\r\n                    var retval = _.multiply(product_rule(symbol), polydiff(symbol));\r\n                    retval.multiplier = retval.multiplier.multiply(m);\r\n                    return retval;\r\n                }\r\n                else if(g === FN && symbol.power.equals(1)) {\r\n                    // Table of known derivatives\r\n                    switch(symbol.fname) {\r\n                        case LOG:\r\n                            cp = symbol.clone();\r\n                            symbol = symbol.args[0].clone();//get the arguments\r\n                            symbol.power = symbol.power.negate();\r\n                            symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\r\n                            break;\r\n                        case COS:\r\n                            //cos -> -sin\r\n                            symbol.fname = SIN;\r\n                            symbol.multiplier.negate();\r\n                            break;\r\n                        case SIN:\r\n                            //sin -> cos\r\n                            symbol.fname = COS;\r\n                            break;\r\n                        case TAN:\r\n                            //tan -> sec^2\r\n                            symbol.fname = SEC;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SEC:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, TAN);\r\n                            break;\r\n                        case CSC:\r\n                            symbol = qdiff(symbol, '-cot');\r\n                            break;\r\n                        case COT:\r\n                            symbol.fname = CSC;\r\n                            symbol.multiplier.negate();\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case ASIN:\r\n                            symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ACOS:\r\n                            symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ATAN:\r\n                            symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ABS:\r\n                            m = symbol.multiplier.clone();\r\n                            symbol.toUnitMultiplier();\r\n                            //depending on the complexity of the symbol it's easier to just parse it into a new symbol\r\n                            //this should really be readdressed soon\r\n                            b = symbol.args[0].clone();\r\n                            b.toUnitMultiplier();\r\n                            symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\r\n                            symbol.multiplier = m;\r\n                            break;\r\n                        case 'parens':\r\n                            //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\r\n                            //1*g'\r\n                            symbol = Symbol(1);\r\n                            break;\r\n                        case 'cosh':\r\n                            //cosh -> -sinh\r\n                            symbol.fname = 'sinh';\r\n                            break;\r\n                        case 'sinh':\r\n                            //sinh -> cosh\r\n                            symbol.fname = 'cosh';\r\n                            break;\r\n                        case TANH:\r\n                            //tanh -> sech^2\r\n                            symbol.fname = SECH;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SECH:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, '-tanh');\r\n                            break;\r\n                        case CSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\r\n                            break;\r\n                        case COTH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-csch(' + arg + ')^2');\r\n                            break;\r\n                        case 'asinh':\r\n                            symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'acosh':\r\n                            symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'atanh':\r\n                            symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ASECH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOTH:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\r\n                            break;\r\n                        case ACSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ASEC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACSC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOT:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\r\n                            break;\r\n                        case 'S':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'C':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'Si':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Shi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ci':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Chi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ei':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Li':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\r\n                            break;\r\n                        case 'erf':\r\n                            symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\r\n                            break;\r\n                        case 'atan2':\r\n                            var x_ = String(symbol.args[0]),\r\n                                    y_ = String(symbol.args[1]);\r\n                            symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\r\n                            break;\r\n                        case 'sign':\r\n                            symbol = new Symbol(0);\r\n                            break;\r\n                        case 'sinc':\r\n                            symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\r\n                            break;\r\n                        case Settings.LOG10:\r\n                            symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\r\n                            break;\r\n                        default:\r\n                            symbol = _.symfunction('diff', [symbol, wrt]);\r\n                    }\r\n                }\r\n                else if(g === EX || g === FN && isSymbol(symbol.power)) {\r\n                    var value;\r\n                    if(g === EX) {\r\n                        value = symbol.value;\r\n                    }\r\n                    else if(g === FN && symbol.contains(d)) {\r\n                        value = symbol.fname + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    else {\r\n                        value = symbol.value + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\r\n                    b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\r\n                    symbol = _.multiply(symbol, b);\r\n                }\r\n                else if(g === FN && !symbol.power.equals(1)) {\r\n                    b = symbol.clone();\r\n                    b.toLinear();\r\n                    b.toUnitMultiplier();\r\n                    symbol = _.multiply(polydiff(symbol.clone()), derive(b));\r\n                }\r\n                else if(g === CP || g === PL) {\r\n                    // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\r\n                    var c = symbol.clone();\r\n                    var result = new Symbol(0);\r\n                    for(var x in symbol.symbols) {\r\n                        result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\r\n                    }\r\n                    symbol = _.multiply(polydiff(c), result);\r\n                }\r\n\r\n                symbol.updateHash();\r\n\r\n                return symbol;\r\n            }\r\n            ;\r\n\r\n            function qdiff(symbol, val, altVal) {\r\n                return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\r\n            }\r\n            ;\r\n\r\n            function product_rule(symbol) {\r\n                //grab all the symbols within the CB symbol\r\n                var symbols = symbol.collectSymbols(),\r\n                        result = new Symbol(0),\r\n                        l = symbols.length;\r\n                //loop over all the symbols\r\n                for(var i = 0; i < l; i++) {\r\n                    var df = __.diff(symbols[i].clone(), d);\r\n                    for(var j = 0; j < l; j++) {\r\n                        //skip the symbol of which we just pulled the derivative\r\n                        if(i !== j) {\r\n                            //multiply out the remaining symbols\r\n                            df = _.multiply(df, symbols[j].clone());\r\n                        }\r\n                    }\r\n                    //add the derivative to the result\r\n                    result = _.add(result, df);\r\n                }\r\n                return result; //done\r\n            }\r\n            ;\r\n        },\r\n        integration: {\r\n            u_substitution: function (symbols, dx) {\r\n                function try_combo(a, b, f) {\r\n                    var d = __.diff(b, dx);\r\n                    var q = f ? f(a, b) : _.divide(a.clone(), d);\r\n                    if(!q.contains(dx, true))\r\n                        return q;\r\n                    return null;\r\n                }\r\n                function do_fn_sub(fname, arg) {\r\n                    var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\r\n                    subbed = subbed.sub(new Symbol(u), arg);\r\n                    subbed.updateHash();\r\n                    return subbed;\r\n                }\r\n\r\n                var a = symbols[0].clone(),\r\n                        b = symbols[1].clone(),\r\n                        g1 = a.group,\r\n                        g2 = b.group,\r\n                        //may cause problems if person is using this already. Will need\r\n                        //to find algorithm for detecting conflict\r\n                        u = '__u__',\r\n                        Q;\r\n                if(g1 === FN && g2 !== FN) {\r\n                    //e.g. 2*x*cos(x^2)\r\n                    var arg = a.args[0];\r\n                    Q = try_combo(b, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(a.fname, arg));\r\n                    Q = try_combo(b, a);\r\n                    if(Q) {\r\n                        return __.integration.poly_integrate(a);\r\n                    }\r\n                }\r\n                else if(g2 === FN && g1 !== FN) {\r\n                    //e.g. 2*(x+1)*cos((x+1)^2\r\n                    var arg = b.args[0];\r\n                    Q = try_combo(a, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(b.fname, arg));\r\n                }\r\n                else if(g1 === FN && g2 === FN) {\r\n                    Q = try_combo(a.clone(), b.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(b.clone(), a.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                }\r\n                else if(g1 === EX && g2 !== EX) {\r\n                    var p = a.power;\r\n                    Q = try_combo(b, p.clone());\r\n                    if(!Q) {\r\n                        //one more try\r\n                        var dc = __.integration.decompose_arg(p.clone(), dx);\r\n                        //consider the possibility of a^x^(n-1)*x^n dx\r\n                        var xp = __.diff(dc[2].clone(), dx);\r\n                        var dc2 = __.integration.decompose_arg(xp.clone(), dx);\r\n                        //if their powers equal, so if dx*p == b\r\n                        if(_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\r\n                            var m = _.divide(dc[0].clone(), dc2[0].clone());\r\n\r\n                            var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\r\n                            new_val = _.multiply(new_val, new Symbol(u));\r\n                            return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\r\n                        }\r\n\r\n                    }\r\n                    var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\r\n                            retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n\r\n\r\n                    return retval;\r\n                }\r\n                else if(g2 === EX && g1 !== EX) {\r\n                    var p = b.power;\r\n                    Q = try_combo(a, p.clone());\r\n                    var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\r\n                    return _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n                }\r\n                else if(a.isComposite() || b.isComposite()) {\r\n                    var f = function (a, b) {\r\n                        var d = __.diff(b, dx);\r\n                        var A = core.Algebra.Factor.factor(a),\r\n                                B = core.Algebra.Factor.factor(d);\r\n                        var q = _.divide(A, B);\r\n                        return q;\r\n                    };\r\n                    var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\r\n                            f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\r\n                    Q = try_combo(f1.clone(), f2.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(f2.clone(), f1.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(a), Q);\r\n                }\r\n            },\r\n            //simple integration of a single polynomial x^(n+1)/(n+1)\r\n            poly_integrate: function (x) {\r\n                var p = x.power.toString(),\r\n                        m = x.multiplier.toDecimal(),\r\n                        s = x.toUnitMultiplier().toLinear();\r\n                if(Number(p) === -1) {\r\n                    return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\r\n                }\r\n                return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\r\n            },\r\n            //If we're just spinning wheels we want to stop. This is why we \r\n            //wrap integration in a try catch block and call this to stop.\r\n            stop: function (msg) {\r\n                msg = msg || 'Unable to compute integral!';\r\n                core.Utils.warn(msg);\r\n                throw new NoIntegralFound(msg);\r\n            },\r\n            partial_fraction: function (input, dx, depth, opt) {\r\n                //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\r\n                if(!isSymbol(dx))\r\n                    dx = _.parse(dx);\r\n\r\n                var result, partial_fractions;\r\n                result = new Symbol(0);\r\n                partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\r\n\r\n                if(partial_fractions.group === CB && partial_fractions.isLinear()) {\r\n                    //perform a quick check to make sure that all partial fractions are linear\r\n                    partial_fractions.each(function (x) {\r\n                        if(!x.isLinear())\r\n                            __.integration.stop();\r\n                    });\r\n                    partial_fractions.each(function (x) {\r\n                        result = _.add(result, __.integrate(x, dx, depth, opt));\r\n                    });\r\n                }\r\n                else {\r\n                    result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\r\n                }\r\n                return result;\r\n            },\r\n            get_udv: function (symbol) {\r\n                var parts = [[/*L*/], [/*I*/], [/*A*/], [/*T*/], [/*E*/]];\r\n                //first we sort them \r\n                var setSymbol = function (x) {\r\n                    var g = x.group;\r\n                    if(g === FN) {\r\n                        var fname = x.fname;\r\n                        if(core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))\r\n                            parts[3].push(x);\r\n                        else if(core.Utils.in_inverse_trig(fname))\r\n                            parts[1].push(x);\r\n                        else if(fname === LOG)\r\n                            parts[0].push(x);\r\n                        else {\r\n                            __.integration.stop();\r\n                        }\r\n                    }\r\n                    else if(g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\r\n                        parts[2].push(x);\r\n                    }\r\n                    else if(g === EX || x.isComposite() && !x.isLinear())\r\n                        parts[4].push(x);\r\n                    else\r\n                        __.integration.stop();\r\n                };\r\n\r\n                if(symbol.group === CB)\r\n                    symbol.each(function (x) {\r\n                        setSymbol(Symbol.unwrapSQRT(x, true));\r\n                    });\r\n                else\r\n                    setSymbol(symbol);\r\n                var u, dv = new Symbol(1);\r\n                //compile u and dv\r\n                for(var i = 0; i < 5; i++) {\r\n                    var part = parts[i], t,\r\n                            l = part.length;\r\n                    if(l > 0) {\r\n                        if(l > 1) {\r\n                            t = new Symbol(1);\r\n                            for(var j = 0; j < l; j++)\r\n                                t = _.multiply(t, part[j].clone());\r\n                        }\r\n                        else\r\n                            t = part[0].clone();\r\n\r\n                        if(!u) {\r\n                            u = t;//the first u encountered gets chosen\r\n                            u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\r\n                        }\r\n                        else\r\n                            dv = _.multiply(dv, t); //everything else belongs to dv\r\n                    }\r\n                }\r\n\r\n                return [u, dv];\r\n            },\r\n\r\n            trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\r\n                parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\r\n                var b = parts[3],\r\n                        ax = parts[2],\r\n                        a = parts[0],\r\n                        x = parts[1];\r\n                if(x.power.equals(2) && a.greaterThan(0)) {\r\n                    //use tan(x)\r\n                    var t = core.Utils.getU(symbol), //get an appropriate u\r\n                            u = _.parse(TAN + inBrackets(t)), //u\r\n                            du = _.parse(SEC + inBrackets(t) + '^2'), //du\r\n                            f = _.multiply(symbol.sub(x, u), du);\r\n                    var integral = __.integrate(f, t, depth, opt).sub(u, x);\r\n                    core.Utils.clearU(u);\r\n                    return integral;\r\n                }\r\n            },\r\n\r\n            by_parts: function (symbol, dx, depth, o) {\r\n                o.previous = o.previous || [];\r\n                var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;\r\n                //first LIATE\r\n                udv = __.integration.get_udv(symbol);\r\n                u = udv[0];\r\n                dv = udv[1];\r\n                du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\r\n                c = du.clone().stripVar(dx);\r\n                //strip any coefficients\r\n                du = _.divide(du, c.clone());\r\n                v = __.integrate(dv.clone(), dx, depth || 0);\r\n                vdu = _.multiply(v.clone(), du);\r\n                vdu_s = vdu.toString();\r\n                //currently only supports e^x*(some trig)\r\n                if(o.previous.indexOf(vdu_s) !== -1 && (core.Utils.in_trig(u.fname)) && dv.isE()) {\r\n                    //We're going to exploit the fact that vdu can never be constant\r\n                    //to work out way out of this cycle. We'll return the length of\r\n                    //the this.previous array until we're back at level one\r\n                    o.is_cyclic = true;\r\n                    //return the integral. \r\n                    return new Symbol(1);\r\n                }\r\n                else\r\n                    o.previous.push(vdu_s);\r\n\r\n                uv = _.multiply(u, v);\r\n                //clear the multiplier so we're dealing with a bare integral\r\n                m = vdu.multiplier.clone();\r\n                vdu.toUnitMultiplier();\r\n                integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\r\n                integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\r\n                retval = _.subtract(uv, integral_vdu);\r\n                //we know that there cannot be constants so they're a holdover from a cyclic integral\r\n                if(o.is_cyclic) {\r\n                    //start popping the previous stack so we know how deep in we are\r\n                    o.previous.pop();\r\n                    if(o.previous.length === 0) {\r\n                        retval = _.expand(retval);\r\n                        var rem = new Symbol(0);\r\n                        retval.each(function (x) {\r\n                            if(!x.contains(dx))\r\n                                rem = _.add(rem, x.clone());\r\n                        });\r\n                        //get the actual uv\r\n                        retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\r\n                    }\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            /*\r\n             * dependents: [Solve, integrate]\r\n             */\r\n            decompose_arg: core.Utils.decompose_fn\r\n        },\r\n        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\r\n        integrate: function (original_symbol, dt, depth, opt) {\r\n            //assume integration wrt independent variable if expression only has one variable\r\n            if(!dt) {\r\n                var vars = core.Utils.variables(original_symbol);\r\n                if(vars.length === 1)\r\n                    dt = vars[0];\r\n                //defaults to x\r\n                dt = dt || 'x';\r\n            }\r\n            //add support for integrating vectors\r\n            if(core.Utils.isVector(original_symbol)) {\r\n                var vector = new core.Vector([]);\r\n                original_symbol.each(function (x) {\r\n                    vector.elements.push(__.integrate(x, dt));\r\n                });\r\n                return vector;\r\n            }\r\n            if(!isNaN(dt))\r\n                _.error('variable expected but received ' + dt);\r\n            //get rid of constants right away\r\n            if(original_symbol.isConstant(true))\r\n                return _.multiply(original_symbol.clone(), _.parse(dt));\r\n\r\n            //configurations options for integral. This is needed for tracking extra options\r\n            //e.g. cyclic integrals or additional settings\r\n            opt = opt || {};\r\n            return core.Utils.block('PARSE2NUMBER', function () {\r\n                //make a note of the original symbol. Set only if undefined\r\n                depth = depth || 0;\r\n                var dx = isSymbol(dt) ? dt.toString() : dt,\r\n                        //we don't want the symbol in sqrt form. x^(1/2) is prefererred\r\n                        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\r\n                        g = symbol.group,\r\n                        retval;\r\n\r\n                try {\r\n                    //We stop integration after x amount of recursive calls\r\n                    if(++depth > core.Settings.integration_depth)\r\n                        __.integration.stop('Maximum depth reached. Exiting!');\r\n\r\n                    //constants. We first eliminate anything that doesn't have dx. Everything after this has \r\n                    //to have dx or else it would have been taken care of below\r\n                    if(!symbol.contains(dx, true)) {\r\n                        retval = _.multiply(symbol.clone(), _.parse(dx));\r\n                    }\r\n                    //e.g. 2*x\r\n                    else if(g === S) {\r\n                        retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                    }\r\n                    else if(g === EX) {\r\n                        if(symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS))\r\n                            __.integration.stop();\r\n                        //check the base\r\n                        if(symbol.contains(dx) && symbol.previousGroup !== FN) {\r\n                            //if the symbol also contains dx then we stop since we currently \r\n                            //don't know what to do with it e.g. x^x\r\n                            if(symbol.power.contains(dx))\r\n                                __.integration.stop();\r\n                            else {\r\n                                var t = __.diff(symbol.clone().toLinear(), dx);\r\n                                if(t.contains(dx))\r\n                                    __.integration.stop();\r\n                                //since at this point it's the base only then we do standard single poly integration\r\n                                //e.g. x^y\r\n                                retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                            }\r\n                        }\r\n                        //e.g. a^x or 9^x\r\n                        else {\r\n                            var a = __.diff(symbol.power.clone(), dx);\r\n                            if(a.contains(dx)) {\r\n                                var aa = a.stripVar(dx),\r\n                                        x = _.divide(a.clone(), aa.clone());\r\n                                if(x.group === S && x.isLinear()) {\r\n                                    aa.multiplier = aa.multiplier.divide(new Frac(2));\r\n                                    return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            if(symbol.isE()) {\r\n                                if(a.isLinear())\r\n                                    retval = symbol;\r\n                                else {\r\n                                    if(a.isE() && a.power.group === S && a.power.power.equals(1))\r\n                                        retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\r\n                                retval = _.divide(symbol, d);\r\n                            }\r\n                            retval = _.divide(retval, a);\r\n                        }\r\n                    }\r\n                    else if(symbol.isComposite() && symbol.isLinear()) {\r\n                        var m = _.parse(symbol.multiplier);\r\n                        symbol.toUnitMultiplier();\r\n                        retval = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            retval = _.add(retval, __.integrate(x, dx, depth));\r\n                        });\r\n                        retval = _.multiply(m, retval);\r\n                    }\r\n                    else if(g === CP) {\r\n                        if(symbol.power.greaterThan(1))\r\n                            symbol = _.expand(symbol);\r\n                        if(symbol.power.equals(1)) {\r\n                            retval = new Symbol(0);\r\n                            symbol.each(function (x) {\r\n                                retval = _.add(retval, __.integrate(x, dx, depth));\r\n                            }, true);\r\n                        }\r\n                        else {\r\n                            var p = Number(symbol.power),\r\n                                    m = symbol.multiplier.clone();//temporarily remove the multiplier\r\n                            symbol.toUnitMultiplier();\r\n                            var //below we consider the form ax+b\r\n                                    fn = symbol.clone().toLinear(), //get just the pure function without the power\r\n                                    decomp = __.integration.decompose_arg(fn, dx),\r\n                                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\r\n                                    b = decomp[3],\r\n                                    ax = decomp[2],\r\n                                    a = decomp[0],\r\n                                    x = decomp[1];\r\n                            if(p === -1 && x.group !== PL && x.power.equals(2)) {\r\n                                var b_is_positive = isInt(b) ? b > 0 : true;\r\n                                //we can now check for atan\r\n                                if(x.group === S && x.power.equals(2) && b_is_positive) {\r\n                                    ////then we have atan\r\n                                    //abs is redundants since the sign appears in both denom and num.\r\n                                    var unwrapAbs = function (s) {\r\n                                        var result = new Symbol(1);\r\n                                        s.each(function (x) {\r\n                                            result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\r\n                                        });\r\n                                        return result;\r\n                                    };\r\n                                    var A = a.clone(),\r\n                                            B = b.clone();\r\n                                    A = _.pow(A, new Symbol(1 / 2));\r\n                                    B = _.pow(B, new Symbol(1 / 2));\r\n                                    //unwrap abs\r\n\r\n                                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\r\n                                            f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\r\n                                    retval = _.divide(f, d);\r\n                                }\r\n                                else if(x.group === S && x.isLinear()) {\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                }\r\n                                else {\r\n                                    //1/(x^4+1)\r\n                                    if(x.power.equals(4)) {\r\n                                        //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\r\n                                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\r\n                                        var br = inBrackets;\r\n                                        //apply rule: ax^4+b = (√ax^2+√2∜a∜bx+√b)(√ax^2-√2∜a∜bx+√b)\r\n                                        //get quadratic factors\r\n                                        A = _.parse(SQRT + br(a) + '*' + dx + '^2');\r\n                                        B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        C = _.parse(SQRT + br(b));\r\n                                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\r\n                                        f2 = _.add(_.subtract(A, B), C);\r\n                                        //calculate numerators: [D+E, D-E] -> [√2*b^(3/4)+√b∜ax, √2*b^(3/4)-√b∜ax]\r\n                                        D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\r\n                                        E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        //let F = 2b√2∜b\r\n                                        F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4'));\r\n                                        //calculate the factors\r\n                                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\r\n                                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\r\n                                        retval = _.add(\r\n                                                __.integrate(L1, dx, depth, opt),\r\n                                                __.integrate(L2, dx, depth, opt)\r\n                                                );\r\n                                    }\r\n                                    else\r\n                                        //let's try partial fractions\r\n                                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                }\r\n                            }\r\n                            else if(p === -1 / 2) {\r\n                                //detect asin and atan\r\n                                if(x.group === S && x.power.equals(2)) {\r\n                                    if(ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\r\n                                        a.negate();\r\n                                        //it's asin\r\n                                        if(b.isConstant() && a.isConstant()) {\r\n                                            var d = _.symfunction(SQRT, [a.clone()]),\r\n                                                    d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\r\n                                            retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\r\n                                        }\r\n                                        //I'm not sure about this one. I'm trusting Wolfram Alpha here\r\n                                        else {\r\n                                            var sqrt_a = _.symfunction(SQRT, [a]),\r\n                                                    sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\r\n                                            retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\r\n                                        __.integration.stop();\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\r\n                                    __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                if(x.isLinear() && x.group !== PL)\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                else if(x.power.equals(2) && a.greaterThan(0)) {\r\n                                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv;\r\n                                    //1/(a*x^2+b^2)^n\r\n                                    //strip the value of b so b = 1\r\n                                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\r\n                                    sqb = _.parse(SQRT + inBrackets(b));\r\n                                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\r\n                                    bsqi = _.pow(b, new Symbol(symbol.power));\r\n                                    uv = core.Utils.getU(symbol);\r\n                                    u = _.multiply(aob, x.clone().toLinear());\r\n                                    v = _.parse(ATAN + inBrackets(u));\r\n                                    //the conversion will be 1+tan(x)^2 -> sec(x)^2\r\n                                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \r\n                                    //then the remaining sec will be (n-1)*2;\r\n                                    var n = (Math.abs(symbol.power) - 1) * 2;\r\n                                    //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\r\n                                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\r\n                                    core.Utils.clearU(uv);\r\n                                    return _.multiply(integral.sub(uv, v), bsqi);\r\n                                }\r\n                                else {\r\n                                    if(symbol.group !== CB && !symbol.power.lessThan(0)) {\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n                                    else {\r\n                                        var f = symbol.clone().toLinear();\r\n                                        var factored = core.Algebra.Factor.factor(f);\r\n                                        var was_factored = factored.toString() !== f.toString();\r\n                                        if(core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\r\n                                            try {\r\n                                                var f1, fx, u, sq;\r\n                                                sq = core.Algebra.sqComplete(f, dx);\r\n                                                u = core.Utils.getU(f);\r\n                                                f1 = sq.f.sub(sq.a, u);\r\n                                                fx = _.pow(f1, _.parse(symbol.power));\r\n                                                retval = __.integrate(fx, u).sub(u, sq.a);\r\n                                            }\r\n                                            catch(e) {\r\n                                                __.integration.stop();\r\n                                            }\r\n                                        }\r\n                                        else\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                    }\r\n                                }\r\n                            }\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === FN) {\r\n                        var arg = symbol.args[0],\r\n                                m = symbol.multiplier.clone();\r\n                        symbol.toUnitMultiplier();\r\n                        var decomp = __.integration.decompose_arg(arg, dx);\r\n                        //easies way I can think of to get the coefficient and to make sure\r\n                        //that the symbol is linear wrt dx. I'm not actually trying to get the \r\n                        //derivative\r\n                        var a = decomp[0],\r\n                                x = decomp[1],\r\n                                fname = symbol.fname;\r\n                        //log is a special case that can be handled with integration by parts\r\n                        if(fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) {\r\n                            /*integration by parts */\r\n                            var p = symbol.power.toString();\r\n                            if(isInt(p))\r\n                                depth = depth - p; //it needs more room to find the integral\r\n\r\n                            if(!arg.isComposite())\r\n                                retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));\r\n                            else {\r\n                                //integral u du\r\n                                var u = core.Utils.getU(symbol);\r\n                                var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\r\n                                var du = __.diff(arg, dx);\r\n                                var u_du = _.multiply(f, du);\r\n                                var integral = __.integrate(u_du, u, depth, opt);\r\n                                retval = _.multiply(_.parse(m), integral.sub(u, arg));\r\n                            }\r\n\r\n                        }\r\n                        else if(fname === TAN && symbol.power.lessThan(0)) {\r\n                            //convert to cotangent\r\n                            var sym = symbol.clone();\r\n                            sym.power.negate();\r\n                            sym.fname = COT;\r\n                            return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\r\n                        }\r\n                        else {\r\n                            if(!a.contains(dx, true) && symbol.isLinear()) { //perform a deep search for safety\r\n                                //first handle the special cases \r\n                                if(fname === ABS) {\r\n                                    //REVISIT **TODO**\r\n                                    var x = _.divide(arg.clone(), a.clone());\r\n                                    if(x.group === S && !x.power.lessThan(0)) {\r\n                                        if(core.Utils.even(x.power)) {\r\n                                            retval = __.integrate(arg, dx, depth);\r\n                                        }\r\n                                        else {\r\n                                            var integrated = __.integrate(x, dx, depth);\r\n                                            integrated.power = integrated.power.subtract(new Frac(1));\r\n                                            retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\r\n                                        }\r\n                                    }\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                                else {\r\n                                    var ag = symbol.args[0].group,\r\n                                            decomposed = __.integration.decompose_arg(arg, dx);\r\n\r\n                                    if(!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())\r\n                                        __.integration.stop();\r\n                                    /**TODO**/ //ASIN, ACOS, ATAN\r\n                                    switch(fname) {\r\n                                        case COS:\r\n                                            retval = _.symfunction(SIN, [arg]);\r\n                                            break;\r\n                                        case SIN:\r\n                                            retval = _.symfunction(COS, [arg]);\r\n                                            retval.negate();\r\n                                            break;\r\n                                        case TAN:\r\n                                            retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\r\n                                            break;\r\n                                        case SEC:\r\n                                            retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\r\n                                            break;\r\n                                        case CSC:\r\n                                            retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\r\n                                            break;\r\n                                        case COT:\r\n                                            retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\r\n                                            break;\r\n                                        case SINH:\r\n                                            retval = _.symfunction(COSH, [arg]);\r\n                                            break;\r\n                                        case COSH:\r\n                                            retval = _.symfunction(SINH, [arg]);\r\n                                            break;\r\n                                        case TANH:\r\n                                            retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\r\n                                            break;\r\n                                        case ASEC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOT:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //inverse htrig\r\n                                        case ASECH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSCH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOTH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //end inverse htrig\r\n                                            //htrigh\r\n                                        case SECH:\r\n                                            retval = _.parse(format('atan(sinh({0}))', arg));\r\n                                            break;\r\n                                        case CSCH:\r\n                                            retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\r\n                                            break;\r\n                                        case COTH:\r\n                                            retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\r\n                                            break;\r\n                                            //end htrig\r\n                                        case EXP:\r\n                                            retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\r\n                                            break;\r\n                                        case 'S':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\r\n                                            break;\r\n                                        case 'C':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\r\n                                            break;\r\n                                        case 'erf':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\r\n                                            break;\r\n                                        case 'sign':\r\n                                            retval = _.multiply(symbol.clone(), arg.clone());\r\n                                            break;\r\n                                        default:\r\n                                            __.integration.stop();\r\n                                    }\r\n\r\n                                    retval = _.divide(retval, a);\r\n                                }\r\n                            }\r\n                            else if(x.isLinear()) {\r\n                                if(fname === COS || fname === SIN) {\r\n                                    var p = Number(symbol.power);\r\n                                    //check to see if it's negative and then just transform it to sec or csc\r\n                                    if(p < 0) {\r\n                                        symbol.fname = fname === SIN ? CSC : SEC;\r\n                                        symbol.invert().updateHash();\r\n                                        retval = __.integrate(symbol, dx, depth);\r\n                                    }\r\n                                    else {\r\n                                        var arg = symbol.args[0],\r\n                                                rd = symbol.clone(), //cos^(n-1)\r\n                                                rd2 = symbol.clone(), //cos^(n-2)\r\n                                                q = new Symbol((p - 1) / p), //\r\n                                                na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\r\n                                        rd.power = rd.power.subtract(new Frac(1));\r\n                                        rd2.power = rd2.power.subtract(new Frac(2));\r\n\r\n                                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\r\n                                        if(fname === SIN)\r\n                                            t.negate();\r\n                                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\r\n                                    }\r\n                                }\r\n                                //tan(x)^n or cot(x)^n\r\n                                else if(fname === TAN || fname === COT) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    if(symbol.args[0].isLinear(dx)) {\r\n                                        var n = symbol.power.subtract(new Frac(1)).toString(),\r\n                                                r = symbol.clone().toUnitMultiplier(),\r\n                                                w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\r\n                                        r.power = r.power.subtract(new Frac(2));\r\n                                        if(r.power.equals(0))\r\n                                            r = _.parse(r);\r\n                                        retval = _.subtract(w, __.integrate(r, dx, depth));\r\n                                    }\r\n                                }\r\n                                //sec(x)^n or csc(x)^n\r\n                                else if(fname === SEC || fname === CSC) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    var n1 = symbol.power.subtract(new Frac(1)).toString(),\r\n                                            n2 = symbol.power.subtract(new Frac(2)).toString(),\r\n                                            f2 = fname === SEC ? TAN : COT,\r\n                                            r = symbol.clone().toUnitMultiplier(),\r\n                                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\r\n                                            w = _.parse(parse_str);\r\n                                    r.power = r.power.subtract(new Frac(2));\r\n                                    if(r.power.equals(0))\r\n                                        r = _.parse(r);\r\n                                    retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\r\n                                }\r\n                                else if((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\r\n                                    retval = __.integrate(symbol.fnTransform(), dx, depth);\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            else\r\n                                __.integration.stop();\r\n\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === PL) {\r\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                    }\r\n                    else if(g === CB) {\r\n                        var den = symbol.getDenom();\r\n                        if(den.group === S)\r\n                            symbol = _.expand(symbol);\r\n\r\n                        //separate the coefficient since all we care about are symbols containing dx\r\n                        var coeff = symbol.stripVar(dx);\r\n                        //now get only those that apply\r\n                        var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\r\n                        //peform a correction for stripVar. This is a serious TODO!\r\n                        if(coeff.contains(dx)) {\r\n                            cfsymbol = _.multiply(cfsymbol, coeff);\r\n                            coeff = new Symbol(1);\r\n                        }\r\n\r\n                        //if we only have one symbol left then let's not waste time. Just pull the integral\r\n                        //and let the chips fall where they may\r\n                        if(cfsymbol.group !== CB) {\r\n                            if(cfsymbol.equals(1)) {\r\n                                return __.integrate(_.expand(symbol), dx, depth);\r\n                            }\r\n\r\n                            //only factor for multivariate which are polynomials\r\n                            if(cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\r\n                                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\r\n                            }\r\n\r\n                            retval = __.integrate(cfsymbol, dx, depth);\r\n                        }\r\n                        else {\r\n                            //we collect the symbols and sort them descending group, descending power, descending alpabethically\r\n                            var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\r\n                                if(a.group === b.group) {\r\n                                    if(Number(a.power) === Number(b.power))\r\n                                        if(a < b)\r\n                                            return 1; //I want sin first\r\n                                        else\r\n                                            return -1;\r\n                                    return b.power - a.power; //descending power\r\n                                }\r\n                                return b.group - a.group; //descending groups\r\n                            }).map(function (x) {\r\n                                var unwrapped = Symbol.unwrapSQRT(x, true);\r\n                                if(unwrapped.fname === EXP) {\r\n                                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\r\n                                }\r\n                                return unwrapped;\r\n                            });\r\n                            var l = symbols.length;\r\n                            if(symbol.power < 0) {\r\n                                if(l === 2) {\r\n                                    return __.integrate(_.expand(symbol), dx, depth, opt);\r\n                                }\r\n                            }\r\n                            //otherwise the denominator is one lumped together symbol \r\n                            else {\r\n                                //generate an image for \r\n                                if(l === 2) {\r\n                                    //try u substitution\r\n                                    try {\r\n                                        retval = __.integration.u_substitution(symbols, dx);\r\n                                    }\r\n                                    catch(e) {/* failed :`(*/\r\n                                        ;\r\n                                    }\r\n\r\n                                    if(!retval) {\r\n                                        //no success with u substitution so let's try known combinations\r\n                                        //are they two functions\r\n                                        var g1 = symbols[0].group,\r\n                                                g2 = symbols[1].group,\r\n                                                sym1 = symbols[0],\r\n                                                sym2 = symbols[1],\r\n                                                fn1 = sym1.fname,\r\n                                                fn2 = sym2.fname;\r\n                                        //reset the symbol minus the coeff\r\n                                        symbol = _.multiply(sym1.clone(), sym2.clone());\r\n                                        if(g1 === FN && g2 === FN) {\r\n                                            if(fn1 === LOG || fn2 === LOG) {\r\n                                                retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\r\n                                            }\r\n                                            else {\r\n                                                symbols.sort(function (a, b) {\r\n                                                    return b.fname > a.fname;\r\n                                                });\r\n                                                var arg1 = sym1.args[0];\r\n                                                //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\r\n                                                if(!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))\r\n                                                    __.integration.stop();\r\n\r\n                                                var decomp = __.integration.decompose_arg(arg1, dx);\r\n                                                x = decomp[1],\r\n                                                        a = decomp[0];\r\n                                                if(!x.isLinear()) //again... linear arguments only wrt x\r\n                                                    __.integration.stop();\r\n\r\n                                                //they have to have the same arguments and then we have cleared all the check to \r\n                                                //make sure we can integrate FN & FN\r\n                                                var arg2 = sym2.args[0];\r\n                                                //make sure that their argument matches\r\n                                                if(arg1.equals(arg2)) {\r\n                                                    if(fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\r\n                                                        if(sym1.power.lessThan(0))\r\n                                                            __.integration.stop();//we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\r\n                                                        //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\r\n                                                        if(fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\r\n                                                            sym1.fname = TAN;\r\n                                                            sym1.updateHash();\r\n                                                            retval = __.integrate(sym1, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            if(even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\r\n                                                                //transform sin^(2*n) to (1-cos^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else if(even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\r\n                                                                //transform cos^(2*n) to (1-sin^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else {\r\n                                                                var p1_even = core.Utils.even(sym1.power),\r\n                                                                        p2_even = core.Utils.even(sym2.power);\r\n                                                                retval = new Symbol(0);\r\n                                                                if(!p1_even || !p2_even) {\r\n                                                                    var u, r, trans;\r\n                                                                    //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\r\n                                                                    //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\r\n                                                                    if(!p1_even) {\r\n                                                                        //u = sin(x)\r\n                                                                        u = sym2;\r\n                                                                        r = sym1;\r\n                                                                    }\r\n                                                                    else {\r\n                                                                        u = sym1;\r\n                                                                        r = sym2;\r\n                                                                    }\r\n                                                                    //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\r\n                                                                    var sign = u.fname === COS ? -1 : 1,\r\n                                                                            n = r.power,\r\n                                                                            //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \r\n                                                                            //even powers afterwards which can be transformed\r\n                                                                            k = (n - 1) / 2,\r\n                                                                            //make the transformation cos(x)^2 = 1 - sin(x)^2\r\n                                                                            trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\r\n                                                                            sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));\r\n                                                                    //we can now just loop through and integrate each since it's now just a polynomial with functions\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\r\n                                                                    });\r\n                                                                }\r\n                                                                else {\r\n                                                                    //performs double angle transformation\r\n                                                                    var double_angle = function (symbol) {\r\n                                                                        var p = symbol.power,\r\n                                                                                k = p / 2, e;\r\n                                                                        if(symbol.fname === COS)\r\n                                                                            e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n                                                                        else\r\n                                                                            e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n\r\n                                                                        return _.parse(e);\r\n                                                                    };\r\n                                                                    //they're both even so transform both using double angle identities and we'll just\r\n                                                                    //be able to integrate by the sum of integrals\r\n                                                                    var a = double_angle(sym1),\r\n                                                                            b = double_angle(sym2),\r\n                                                                            t = _.multiply(a, b);\r\n                                                                    var sym = _.expand(t);\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                                    });\r\n                                                                    return _.multiply(retval, coeff);\r\n                                                                }\r\n                                                            }\r\n                                                        }\r\n                                                    }\r\n                                                    //tan(x)*sec(x)^n \r\n                                                    else if(fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\r\n                                                        retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\r\n                                                    }\r\n                                                    else if(fn1 === TAN && fn2 === SEC && x.isLinear()) {\r\n                                                        //remaining: tan(x)^3*sec(x)^6\r\n                                                        if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                            retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\r\n                                                        }\r\n                                                        else if(even(sym1.power)) {\r\n                                                            var p = Number(sym1.power) / 2;\r\n                                                            //transform tangent\r\n                                                            var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\r\n                                                            retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\r\n                                                        }\r\n                                                        else\r\n                                                            __.integration.stop();\r\n                                                    }\r\n                                                    else if(fn1 === SEC && fn2 === COS) {\r\n                                                        sym1.fname = COS;\r\n                                                        sym1.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    else if(fn1 === SIN && fn2 === CSC) {\r\n                                                        sym2.fname = SIN;\r\n                                                        sym2.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    //tan/cos\r\n                                                    else if(fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2);\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                    else {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                }\r\n                                                //TODO: In progress\r\n                                                else if((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\r\n\r\n                                                    if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                        //if in the form cos(a*x)*sin(b*x)\r\n                                                        if(sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\r\n                                                            //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\r\n                                                            var ax, bx;\r\n                                                            if(fn2 === SIN) {\r\n                                                                ax = sym1.args[0];\r\n                                                                bx = sym2.args[0];\r\n                                                            }\r\n                                                            else {\r\n                                                                bx = sym1.args[0];\r\n                                                                ax = sym2.args[0];\r\n                                                            }\r\n\r\n                                                            //make the transformation\r\n                                                            f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString()));\r\n\r\n                                                            //integrate it\r\n                                                            retval = __.integrate(f, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            var transformed = trigTransform(symbols);\r\n                                                            retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                    else {\r\n                                                        var transformed = new Symbol(1);\r\n                                                        symbols.map(function (sym) {\r\n                                                            var s = sym.fnTransform();\r\n                                                            transformed = _.multiply(transformed, s);\r\n                                                        });\r\n                                                        var t = _.expand(transformed);\r\n\r\n                                                        retval = __.integrate(t, dx, depth);\r\n\r\n                                                        if(retval.hasIntegral()) {\r\n                                                            retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                                else {\r\n                                                    __.integration.stop();\r\n                                                }\r\n\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === FN && g2 === S) {\r\n                                            var sym1_is_linear = sym1.isLinear();\r\n                                            if(sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Ci', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COS && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Chi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COSH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Si', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SIN && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Shi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SINH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === LOG && sym2.power.equals(-1)) {\r\n                                                //log(x)^n/x = log(x)^(n+1)/(n+1)\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === 'erf') {\r\n                                                if(sym2.power.equals(1)) {\r\n                                                    var dc = __.integration.decompose_arg(sym1.args[0], dx),\r\n                                                            a_ = dc[0],\r\n                                                            x_ = dc[1],\r\n                                                            arg = sym1.args[0].toString();\r\n                                                    retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg))\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                //since group S is guaranteed convergence we need not worry about tracking depth of integration\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === EX && g2 === S) {\r\n                                            var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\r\n                                            if(sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\r\n                                                retval = _.symfunction('Ei', [sym1.power.clone()]);\r\n                                            }\r\n                                            else if(fn1 === LOG && x.value === sym2.value) {\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                        else if(g1 === PL && g2 === S) {\r\n                                            //first try to reduce the top\r\n                                            if(sym2.value === sym1.value && sym1.power.equals(-1)) {\r\n                                                //find the lowest power in the denominator\r\n                                                var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));\r\n                                                //get the lowest common value between denominator and numerator\r\n                                                var pc = Math.min(pd, sym2.power);\r\n                                                //reduce both denominator and numerator by that factor\r\n                                                var factor = sym2.clone();\r\n                                                factor.power = new Frac(pc);\r\n                                                sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\r\n                                                var t = new Symbol(0);\r\n                                                sym1.each(function (x) {\r\n                                                    t = _.add(t, _.divide(x.clone(), factor.clone()));\r\n                                                });\r\n                                                t.multiplier = sym1.multiplier;\r\n                                                symbol = _.divide(sym2, t);\r\n                                            }\r\n                                            else {\r\n                                                symbol = _.expand(symbol);\r\n                                            }\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                        }\r\n                                        else if(g1 === CP && g2 === S) {\r\n                                            var f = sym1.clone().toLinear(),\r\n                                                    f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);\r\n                                            //handle cases x^(2*n)/sqrt(1-x^2)\r\n                                            if(sym1.power.equals(-1 / 2)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\r\n                                                var a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\r\n                                                    //if the substitution \r\n                                                    var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)),\r\n                                                            _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])),\r\n                                                            _.pow(a.clone(), new Symbol(2)));\r\n                                                    c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\r\n                                                    var dummy = _.parse('sin(u)');\r\n                                                    dummy.power = dummy.power.multiply(sym2.power);\r\n                                                    var integral = __.integrate(dummy, 'u', depth);\r\n                                                    var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\r\n                                                    retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\r\n                                                }\r\n                                                else if(p1 === -1 / 2) {\r\n                                                    var u_transform = function (f, u) {\r\n                                                        var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\r\n                                                        if(!integral.hasIntegral())\r\n                                                            return integral;\r\n                                                    }\r\n                                                    if(p2 === -1) {\r\n                                                        retval = u_transform(\r\n                                                                _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                    else if(p2 === -2) {\r\n                                                        //apply transformation to see if it matches asin(x)\r\n                                                        retval = u_transform(\r\n                                                                _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            else if(sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\r\n                                                retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else if(!sym1.power.lessThan(0) && isInt(sym1.power)) {\r\n                                                //sum of integrals\r\n                                                var expanded = _.expand(sym1);\r\n                                                retval = new Symbol(0);\r\n                                                expanded.each(function (x) {\r\n                                                    if(x.group === PL) {\r\n                                                        x.each(function (y) {\r\n                                                            retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\r\n                                                        });\r\n                                                    }\r\n                                                    else\r\n                                                        retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\r\n                                                });\r\n                                            }\r\n                                            else if(sym1.power.lessThan(-2)) {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                            else if(sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                        a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        fn = sym1.clone().toLinear();\r\n\r\n                                                if(x.group !== PL && x.isLinear()) {\r\n                                                    var p = Number(sym2.power),\r\n                                                            du = '_u_',\r\n                                                            u = new Symbol(du),\r\n                                                            //pull the integral with the subsitution\r\n                                                            U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\r\n                                                            scope = {};\r\n\r\n                                                    //generate a scope for resubbing the symbol\r\n                                                    scope[du] = fn;\r\n                                                    var U2 = _.parse(U, scope);\r\n                                                    retval = __.integrate(U2, dx, 0);\r\n                                                }\r\n                                                else if(sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\r\n\r\n                                                    //factor out coefficients\r\n                                                    var factors = new core.Algebra.Classes.Factors();\r\n                                                    sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\r\n                                                    var div = core.Algebra.divide(sym2, sym1);\r\n                                                    //it assumed that the result will be of group CB\r\n                                                    if(div.group !== CB) {\r\n                                                        retval = new Symbol(0);\r\n                                                        div.each(function (t) {\r\n                                                            retval = _.add(retval, __.integrate(t, dx, depth));\r\n                                                        });\r\n                                                        //put back the factors\r\n                                                        factors.each(function (factor) {\r\n                                                            retval = _.divide(retval, factor);\r\n                                                        });\r\n\r\n                                                        retval = _.expand(retval);\r\n                                                    }\r\n                                                    else {\r\n                                                        //try something else\r\n                                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else {\r\n                                                //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \r\n                                                if(sym1.power.den.equals(2)) {\r\n                                                    //assume the function is in the form (a^2-b*x^n)^(m/2)\r\n                                                    var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                            //using the above definition\r\n                                                            a = dc[3], x = dc[1], b = dc[0], bx = dc[2];\r\n                                                    if(x.power.equals(2) && b.lessThan(0)) { //if n is even && b is negative\r\n                                                        //make a equal 1 so we can do a trig sub\r\n                                                        if(!a.equals(1)) { //divide a out of everything\r\n                                                            //move a to the coeff\r\n                                                            coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\r\n                                                        }\r\n                                                        var u = dx;\r\n                                                        var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\r\n                                                                du = _.symfunction(COS, [new Symbol(u)]),\r\n                                                                cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\r\n                                                                X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\r\n                                                                val = _.multiply(_.multiply(cosn, du), X),\r\n                                                                integral = __.integrate(val, u, depth);\r\n                                                        //but remember that u = asin(sqrt(b)*a*x)\r\n                                                        retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\r\n                                                    }\r\n                                                    else {\r\n                                                        retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else if(f_is_linear) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n                                        else if(sym1.isComposite() && sym2.isComposite()) {\r\n                                            //sum of integrals\r\n                                            retval = new Symbol(0);\r\n                                            if(sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\r\n                                                //combine and pull the integral of each\r\n                                                var sym = _.expand(symbol);\r\n                                                sym.each(function (x) {\r\n                                                    retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                }, true);\r\n                                            }\r\n                                            else {\r\n                                                var p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(p1 < 0 && p2 > 0) {\r\n                                                    //swap\r\n                                                    var t = sym1;\r\n                                                    sym1 = sym2;\r\n                                                    sym2 = t;\r\n                                                }\r\n                                                if(p1 === -1 && p2 === -1) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx);\r\n                                                }\r\n                                                else {\r\n                                                    sym1.each(function (x) {\r\n                                                        var k = _.multiply(x, sym2.clone());\r\n                                                        var integral = __.integrate(k, dx, depth);\r\n                                                        retval = _.add(retval, integral);\r\n                                                    });\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === CP && symbols[0].power.greaterThan(0)) {\r\n                                            sym1 = _.expand(sym1);\r\n                                            retval = new Symbol(0);\r\n                                            sym1.each(function (x) {\r\n                                                retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\r\n                                            }, true);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\r\n                                            sym1 = sym1.fnTransform();\r\n                                            retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\r\n                                            if(g2 === FN && g1 === CP) {\r\n                                                var t = sym1;\r\n                                                sym1 = sym2;\r\n                                                sym2 = t; //swap\r\n                                            }\r\n                                            var du, sym2_clone, p, q, sa, sb;\r\n                                            du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\r\n                                            sym2_clone = Symbol.unwrapSQRT(sym2, true);\r\n                                            if(du.power.equals(sym2_clone.power)) {\r\n                                                p = new Symbol(sym2.power);\r\n                                                sa = du.clone().toLinear();\r\n                                                sb = sym2.clone().toLinear();\r\n                                                q = core.Algebra.divide(sa.toLinear(), sb);\r\n                                                if(q.isConstant()) {\r\n                                                    var nq = _.pow(q, p.negate());\r\n                                                    retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            var syma = sym1.clone().toLinear();\r\n                                            var symb = sym2.clone().toLinear();\r\n                                            if(g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx)\r\n                                                    && !syma.contains(dx) && !symb.contains(dx)) {\r\n                                                retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))',\r\n                                                        syma.toString(),\r\n                                                        symb.toString(),\r\n                                                        sym1.power.multiplier.toString(),\r\n                                                        sym2.power.multiplier.toString(),\r\n                                                        dx\r\n                                                        ));\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\r\n                                    var first = symbols[0];\r\n                                    if(first.group === CP) { //TODO {support higher powers of x in the future}\r\n                                        if(first.power.greaterThan(1))\r\n                                            first = _.expand(first);\r\n                                        var r = _.multiply(symbols[1], symbols[2]);\r\n                                        retval = new Symbol(0);\r\n                                        first.each(function (x) {\r\n                                            var t = _.multiply(x, r.clone());\r\n                                            var intg = __.integrate(t, dx, depth);\r\n                                            retval = _.add(retval, intg);\r\n                                        }, true);\r\n                                    }\r\n                                    else {\r\n                                        //try integration by parts although technically it will never work\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n\r\n                                }\r\n                                else if(all_functions(symbols)) {\r\n                                    var t = new Symbol(1);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        t = _.multiply(t, symbols[i].fnTransform());\r\n                                    }\r\n                                    t = _.expand(t);\r\n                                    retval = __.integrate(t, dx, depth);\r\n                                }\r\n                                else {\r\n                                    //one more go\r\n                                    var transformed = trigTransform(symbols);\r\n                                    retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        retval = _.multiply(retval, coeff);\r\n                    }\r\n                    //if an integral was found then we return it\r\n                    if(retval)\r\n                        return retval;\r\n                }\r\n\r\n                catch(error) {\r\n                    //do nothing if it's a NoIntegralFound error otherwise let it bubble\r\n                    if(!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero))\r\n                        throw error;\r\n                }\r\n\r\n                //no symbol found so we return the integral again\r\n                return _.symfunction('integrate', [original_symbol, dt]);\r\n            }, false);\r\n        },\r\n        defint: function (symbol, from, to, dx) {\r\n            dx = dx || 'x'; //make x the default variable of integration\r\n            var get_value = function (integral, vars, point) {\r\n                try {\r\n                    return _.parse(integral, vars);\r\n                }\r\n                catch(e) {\r\n                    //it failed for some reason so return the limit\r\n                    var lim = __.Limit.limit(integral, dx, point);\r\n                    return lim;\r\n                }\r\n            };\r\n\r\n            var vars = core.Utils.variables(symbol),\r\n                    hasTrig = symbol.hasTrig();\r\n            var retval, integral;\r\n\r\n            // Fix #593 - Only assume the first variable if dx is not defined.\r\n            if(vars.length === 1 && !dx)\r\n                dx = vars[0];\r\n\r\n            if(!hasTrig) {\r\n                integral = __.integrate(symbol, dx);\r\n            }\r\n\r\n            if(!hasTrig && !integral.hasIntegral()) {\r\n                var upper = {},\r\n                        lower = {},\r\n                        a, b;\r\n                upper[dx] = to;\r\n                lower[dx] = from;\r\n\r\n                a = get_value(integral, upper, to, dx);\r\n                b = get_value(integral, lower, from, dx);\r\n                retval = _.subtract(a, b);\r\n            }\r\n            else if(vars.length === 1 && from.isConstant() && to.isConstant()) {\r\n\r\n                var f = core.Utils.build(symbol);\r\n                retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\r\n            }\r\n            else\r\n                retval = _.symfunction('defint', [symbol, from, to, dx]);\r\n            return retval;\r\n        },\r\n\r\n        Limit: {\r\n            interval: function (start, end) {\r\n                return _.parse(format('[{0}, {1}]', start, end));\r\n            },\r\n            diverges: function () {\r\n                return __.Limit.interval('-Infinity', 'Infinity');\r\n            },\r\n            divide: function (f, g, x, lim, depth) {\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                var fin = f.clone(), gin = g.clone();\r\n\r\n                //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\r\n                //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\r\n                //the two-sided limit.\r\n                //Known limit\r\n                if(g.fname === ABS) {\r\n                    var sign = f.sign();\r\n                    var lim_sign = lim.sign();\r\n\r\n                    if(lim.isInfinity)\r\n                        return _.multiply(new Symbol(sign), new Symbol(lim_sign));\r\n\r\n                    else if(lim.equals(0)) {\r\n                        var fm = _.parse(f.multiplier);\r\n                        var gm = _.parse(g.multiplier);\r\n                        return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\r\n                    }\r\n                    else {\r\n                        //TODO: Support more limits\r\n                        __.Limit.diverges();\r\n                    }\r\n                }\r\n\r\n                var isInfinity = function (L) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        for(var i = 0; i < L.elements.length; i++)\r\n                            if(!L.elements[i].isInfinity)\r\n                                return false;\r\n                        return true;\r\n                    }\r\n                    return L.isInfinity;\r\n                };\r\n\r\n                var equals = function (L, v) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        return false;\r\n                    }\r\n                    return L.equals(v);\r\n                };\r\n\r\n                var retval;\r\n                do {\r\n                    var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\r\n                    var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));\r\n\r\n                    //if it's in indeterminate form apply L'Hospital's rule\r\n                    var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);\r\n                    //pull the derivatives\r\n                    if(indeterminate) {\r\n                        var ft = __.diff(f.clone(), x);\r\n                        var gt = __.diff(g.clone(), x);\r\n\r\n                        var t_symbol = _.expand(_.divide(ft, gt));\r\n                        f = t_symbol.getNum();\r\n                        g = t_symbol.getDenom();\r\n\r\n                    }\r\n                }\r\n                while(indeterminate)\r\n\r\n                //REMEMBER: \r\n                //- 1/cos(x)\r\n                //n/0 is still possible since we only checked for 0/0\r\n                var den_is_zero = lim2.equals(0);\r\n                var p = Number(gin.power);\r\n\r\n                if(lim.isConstant(true) && den_is_zero) {\r\n                    retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\r\n                }\r\n                else if(den_is_zero) {\r\n                    retval = __.Limit.diverges();\r\n                }\r\n                else {\r\n                    retval = _.divide(lim1, lim2);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            rewriteToLog: function (symbol) {\r\n                var p = symbol.power.clone();\r\n                symbol.toLinear();\r\n                return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\r\n            },\r\n            getSubbed: function (f, x, lim) {\r\n                var retval;\r\n                //1. rewrite EX with base e\r\n                if(f.group === EX) {\r\n                    f = __.rewriteToLog(f);\r\n                }\r\n                //2. try simple substitution\r\n                try {\r\n                    retval = f.sub(x, lim);\r\n                }\r\n                catch(e) {\r\n                    //Nope. No go, so just return the unsubbed function so we can test the limit instead.\r\n                    retval = f;\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            isInterval: function (limit) {\r\n                return core.Utils.isVector(limit);\r\n            },\r\n            isConvergent: function (limit) {\r\n                //it's not convergent if it lies on the interval -Infinity to Infinity\r\n                if(\r\n                        //It lies on the interval -Infinity to Infinity\r\n                        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity ||\r\n                        //We weren't able to calculate the limit\r\n                        limit.containsFunction('limit')\r\n                        ) {\r\n                    return false; //Then no\r\n                }\r\n                return true; //It is\r\n            },\r\n            limit: function (symbol, x, lim, depth) {\r\n                //Simplify the symbol\r\n                if(symbol.isLinear() && symbol.isComposite()) {\r\n\r\n                    //Apply sum of limits\r\n                    var limit = new Symbol(0);\r\n                    symbol.each(function (s) {\r\n                        limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\r\n                    }, true);\r\n\r\n                    return limit;\r\n                }\r\n                ;\r\n\r\n                symbol = core.Algebra.Simplify.simplify(symbol);\r\n\r\n                depth = depth || 1;\r\n\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                //store the multiplier\r\n                var m = _.parse(symbol.multiplier);\r\n                //strip the multiplier\r\n                symbol.toUnitMultiplier();\r\n                try {\r\n                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                    var retval;\r\n                    //we try the simplest option first where c is some limit\r\n                    //lim a as x->c = a where c \r\n                    if(symbol.isConstant(true)) {\r\n                        retval = symbol;\r\n                    }\r\n                    else {\r\n                        var point = {};\r\n                        point[x] = lim;\r\n                        //lim x as x->c = c where c\r\n\r\n                        try {\r\n\r\n                            //evaluate the function at the given limit\r\n                            var t = _.parse(symbol.sub(x, lim), point);\r\n\r\n                            //a constant or infinity is known so we're done\r\n                            if(t.isConstant(true) || t.isInfinity)\r\n                                retval = t;\r\n\r\n                        }\r\n                        catch(e) { /*Nothing. Maybe we tried to divide by zero.*/\r\n                        }\r\n                        ;\r\n\r\n                        if(!retval) {\r\n                            //split the symbol in the numerator and the denominator\r\n                            var num = symbol.getNum();\r\n                            var den = symbol.getDenom();\r\n\r\n                            if(den.isConstant(true)) {\r\n                                //We still don't have a limit so we generate tests.\r\n                                if(symbol.group === EX) {\r\n                                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                                    //Speed boost for exponentials by detecting patterns\r\n                                    var f = symbol.clone().toLinear();\r\n                                    var p = symbol.power.clone();\r\n                                    var _num = f.getNum();\r\n                                    var _den = f.getDenom();\r\n                                    var fn = core.Utils.decompose_fn(_den, x, true);\r\n                                    //start detection of pattern (x/(x+1))^x\r\n                                    if(_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\r\n                                        retval = _.parse(format('(1/e^({0}))', fn.b));\r\n                                    }\r\n                                    else {\r\n                                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());\r\n                                        //get the base\r\n                                        var pow = symbol_.power.clone();\r\n                                        var base = symbol_.clone().toLinear();\r\n                                        var lim_base = __.Limit.limit(base, x, lim, depth);\r\n                                        var lim_pow = __.Limit.limit(pow, x, lim, depth);\r\n                                        retval = _.pow(lim_base, lim_pow);\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === FN && symbol.args.length === 1) {\r\n                                    var evaluates;\r\n                                    //Squeeze theorem lim f(g(x)) = lim f(lim g))\r\n                                    var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\r\n                                    if(core.Utils.isVector(arg)) {\r\n                                        //get the limit over that interval\r\n                                        retval = arg.map(function (e) {\r\n                                            var clone = symbol.clone();\r\n                                            clone.args[0] = e;\r\n                                            return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\r\n                                        });\r\n\r\n                                        return _.multiply(m, retval);\r\n                                    }\r\n                                    //if the argument is constant then we're done\r\n                                    else if(arg.isConstant(true)) {\r\n\r\n                                        //double check that it evaluates\r\n                                        var trial = _.symfunction(symbol.fname, [arg]);\r\n                                        //trial evaluation\r\n                                        try {\r\n                                            evaluate(trial);\r\n                                            evaluates = true;\r\n                                        }\r\n                                        catch(e) {\r\n\r\n                                            evaluates = false;\r\n                                        }\r\n                                    }\r\n                                    if(evaluates) {\r\n                                        retval = trial;\r\n                                    }\r\n                                    else {\r\n                                        //if the limit converges. We'll deal with non-convergent ones later\r\n                                        if(__.Limit.isConvergent(arg)) {\r\n                                            if(symbol.fname === LOG) {\r\n                                                switch(arg.toString()) {\r\n                                                    //lim -> 0\r\n                                                    case '0':\r\n                                                        retval = Symbol.infinity().negate();\r\n                                                        break;\r\n                                                    case 'Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                    case '-Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                }\r\n                                            }\r\n                                            else if((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\r\n                                                retval = __.Limit.interval(-1, 1);\r\n                                            }\r\n                                            else if((symbol.fname === TAN)) {\r\n                                                var s_arg = symbol.args[0];\r\n                                                var n = s_arg.getNum();\r\n                                                var d = s_arg.getDenom();\r\n                                                var pi = n.toUnitMultiplier();\r\n                                                if(lim.isInfinity || pi.equals('pi') && d.equals(2)) {\r\n                                                    retval = divergent();\r\n                                                }\r\n                                            }\r\n                                            else if(symbol.fname === Settings.FACTORIAL) {\r\n                                                if(arg.isInfinity)\r\n                                                    return Symbol.infinity();\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === S) {\r\n                                    if(symbol.power > 0)\r\n                                        //these functions always converge to the limit\r\n                                        return _.parse(symbol, point);\r\n                                    else {\r\n                                        //we're dealing with 1/x^n but remember that infinity has already been dealt\r\n                                        //with by substitution\r\n                                        if(core.Utils.even(symbol.power)) {\r\n                                            //even powers converge to infinity\r\n                                            retval = Symbol.infinity();\r\n                                        }\r\n                                        else {\r\n                                            //odd ones don't\r\n                                            retval = __.Limit.diverges();\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === CB) {\r\n\r\n                                    var lim1, lim2;\r\n                                    //loop through all the symbols\r\n                                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\r\n                                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return a.group - b.group;\r\n                                    });\r\n\r\n                                    var f = symbols.pop();\r\n                                    //calculate the first limit so we can keep going down the list\r\n                                    lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\r\n\r\n                                    //reduces all the limits one at a time\r\n                                    while(symbols.length) {\r\n                                        //get the second limit\r\n                                        var g = symbols.pop();\r\n                                        //get the limit of g\r\n                                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));\r\n\r\n                                        //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\r\n                                        if((lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2))) {\r\n                                            if(g.containsFunction(LOG)) {\r\n                                                //swap them\r\n                                                g = [f, f = g][0];\r\n                                            }\r\n                                            //invert the symbol\r\n                                            g.invert();\r\n\r\n                                            // Product of infinities\r\n                                            if(lim1.isInfinity && lim2.isInfinity) {\r\n                                                lim1 = Symbol.infinity()\r\n                                            }\r\n                                            else {\r\n                                                lim1 = __.Limit.divide(f, g, x, lim, depth);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            //lim f*g = (lim f)*(lim g)\r\n                                            lim1 = _.multiply(lim1, lim2);\r\n                                            //let f*g equal f and h equal g \r\n                                            f = _.multiply(f, g);\r\n                                        }\r\n                                    }\r\n\r\n                                    //Done, lim1 is the limit we're looking for     \r\n                                    retval = lim1;\r\n                                }\r\n                                else if(symbol.isComposite()) {\r\n                                    var _lim;\r\n                                    if(!symbol.isLinear())\r\n                                        symbol = _.expand(symbol);\r\n                                    //Apply lim f+g = (lim f)+(lim g)\r\n                                    retval = new Symbol(0);\r\n\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return b.group - a.group;\r\n                                    });\r\n\r\n                                    var _symbols = [];\r\n                                    //Analyze the functions first\r\n                                    var fns = new Symbol(0);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i].clone();\r\n                                        if(sym.group === FN || sym.group === CB && sym.hasFunc()) {\r\n                                            fns = _.add(fns, sym);\r\n                                        }\r\n                                        else\r\n                                            _symbols.push(sym);\r\n                                    }\r\n                                    _symbols.unshift(fns);\r\n\r\n                                    //make sure that we didn't just repackage the exact same symbol\r\n                                    if(_symbols.length !== 1) {\r\n                                        symbols = _symbols;\r\n                                    }\r\n\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i];\r\n                                        //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\r\n                                        try {\r\n                                            _lim = __.Limit.limit(sym, x, lim, depth);\r\n                                        }\r\n                                        catch(e) {\r\n                                            _lim = __.Limit.diverges();\r\n                                        }\r\n\r\n                                        try {\r\n                                            retval = _.add(retval, _lim);\r\n                                        }\r\n                                        catch(e) {\r\n                                            if(depth++ > Settings.max_lim_depth) {\r\n                                                return;\r\n                                            }\r\n                                            ;\r\n                                            retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                retval = __.Limit.divide(num, den, x, lim, depth);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //if we still don't have a solution\r\n                    if(!retval)\r\n                        //return it symbolically\r\n                        retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n                catch(e) {\r\n                    //if all else fails return the symbolic function\r\n                    retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n\r\n                return _.multiply(m, retval);\r\n            }\r\n        },\r\n        Fresnel: {\r\n            S: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('S', arguments);\r\n            },\r\n            C: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('C', arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'diff',\r\n            visible: true,\r\n            numargs: [1, 3],\r\n            build: function () {\r\n                return __.diff;\r\n            }\r\n        },\r\n        {\r\n            name: 'sum',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.sum;\r\n            }\r\n        },\r\n        {\r\n            name: 'product',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.product;\r\n            }\r\n        },\r\n        {\r\n            name: 'integrate',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.integrate;\r\n            }\r\n        },\r\n        {\r\n            name: 'defint',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.defint;\r\n            }\r\n        },\r\n        {\r\n            name: 'S',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.S;\r\n            }\r\n        },\r\n        {\r\n            name: 'C',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.C;\r\n            }\r\n        },\r\n        {\r\n            name: 'limit',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.Limit.limit;\r\n            }\r\n        }\r\n    ]);\r\n    //link registered functions externally\r\n    nerdamer.api();\r\n\r\n})();"]},"metadata":{},"sourceType":"script"}