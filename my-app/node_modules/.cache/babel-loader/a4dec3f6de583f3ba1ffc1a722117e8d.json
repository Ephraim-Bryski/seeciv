{"ast":null,"code":"/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\n\n/* global module */\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Calculus.js');\n\n  require('./Algebra.js');\n}\n\n(function () {\n  //handle imports\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      _A = core.Algebra,\n      _C = core.Calculus,\n      explode = _C.integration.decompose_arg,\n      evaluate = core.Utils.evaluate,\n      remove = core.Utils.remove,\n      format = core.Utils.format,\n      build = core.Utils.build,\n      knownVariable = core.Utils.knownVariable,\n      Symbol = core.Symbol,\n      isSymbol = core.Utils.isSymbol,\n      variables = core.Utils.variables,\n      S = core.groups.S,\n      PL = core.groups.PL,\n      CB = core.groups.CB,\n      CP = core.groups.CP,\n      FN = core.groups.FN,\n      Settings = core.Settings,\n      range = core.Utils.range,\n      isArray = core.Utils.isArray; // The search radius for the roots\n\n  core.Settings.SOLVE_RADIUS = 1000; // The maximum number to fish for on each side of the zero\n\n  core.Settings.ROOTS_PER_SIDE = 10; // Covert the number to multiples of pi if possible\n\n  core.Settings.make_pi_conversions = false; // The step size\n\n  core.Settings.STEP_SIZE = 0.1; // The epsilon size\n\n  core.Settings.EPSILON = 1e-13; //the maximum iterations for Newton's method\n\n  core.Settings.MAX_NEWTON_ITERATIONS = 200; //the maximum number of time non-linear solve tries another jump point\n\n  core.Settings.MAX_NON_LINEAR_TRIES = 12; //the amount of iterations the function will start to jump at\n\n  core.Settings.NON_LINEAR_JUMP_AT = 50; //the size of the jump\n\n  core.Settings.NON_LINEAR_JUMP_SIZE = 100; //the original starting point for nonlinear solving\n\n  core.Settings.NON_LINEAR_START = 0.01; //When points are generated as starting points for Newton's method, they are sliced into small\n  //slices to make sure that we have convergence on the right point. This defines the \n  //size of the slice\n\n  core.Settings.NEWTON_SLICES = 200; //The epsilon used in Newton's iteration\n\n  core.Settings.NEWTON_EPSILON = Number.EPSILON * 2; //The distance in which two solutions are deemed the same\n\n  core.Settings.SOLUTION_PROXIMITY = 1e-14; //Indicate wheter to filter the solutions are not\n\n  core.Settings.FILTER_SOLUTIONS = true; //the maximum number of recursive calls\n\n  core.Settings.MAX_SOLVE_DEPTH = 10; // The tolerance that's considered close enough to zero\n\n  core.Settings.ZERO_EPSILON = 1e-9; // The maximum iteration for the bisection method incase of some JS strangeness\n\n  core.Settings.MAX_BISECTION_ITER = 2000; // The tolerance for the bisection method\n\n  core.Settings.BI_SECTION_EPSILON = 1e-12;\n\n  core.Symbol.prototype.hasTrig = function () {\n    return this.containsFunction(['cos', 'sin', 'tan', 'cot', 'csc', 'sec']);\n  };\n\n  core.Symbol.prototype.hasNegativeTerms = function () {\n    if (this.isComposite()) {\n      for (var x in this.symbols) {\n        var sym = this.symbols[x];\n        if (sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0)) return true;\n      }\n    }\n\n    return false;\n  };\n  /* nerdamer version 0.7.x and up allows us to make better use of operator overloading\r\n   * As such we can have this data type be supported completely outside of the core.\r\n   * This is an equation that has a left hand side and a right hand side\r\n   */\n\n\n  function Equation(lhs, rhs) {\n    if (rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) || rhs.equals(core.Settings.IMAGINARY)) throw new core.exceptions.NerdamerValueError(lhs.toString() + ' does not equal ' + rhs.toString());\n    this.LHS = lhs; //left hand side\n\n    this.RHS = rhs; //right and side\n  }\n\n  ; //UTILS ##!!\n\n  Equation.prototype = {\n    toString: function () {\n      return this.LHS.toString() + '=' + this.RHS.toString();\n    },\n    text: function (option) {\n      return this.LHS.text(option) + '=' + this.RHS.text(option);\n    },\n    toLHS: function (expand) {\n      expand = typeof expand === 'undefined' ? true : false;\n      var eqn;\n\n      if (!expand) {\n        eqn = this.clone();\n      } else {\n        eqn = this.removeDenom();\n      }\n\n      var a = eqn.LHS;\n      var b = eqn.RHS;\n\n      if (a.isConstant(true) && !b.isConstant(true)) {\n        // Swap them to avoid confusing parser and cause an infinite loop\n        [a, b] = [b, a];\n      }\n\n      var _t = _.subtract(a, b);\n\n      var retval = expand ? _.expand(_t) : _t;\n      return retval;\n    },\n    removeDenom: function () {\n      var a = this.LHS.clone();\n      var b = this.RHS.clone(); //remove the denominator on both sides\n\n      var den = _.multiply(a.getDenom(), b.getDenom());\n\n      a = _.expand(_.multiply(a, den.clone()));\n      b = _.expand(_.multiply(b, den)); //swap the groups\n\n      if (b.group === CP && b.group !== CP) {\n        var t = a;\n        a = b;\n        b = t; //swap\n      } //scan to eliminate denominators\n\n\n      if (a.group === CB) {\n        var t = new Symbol(a.multiplier),\n            newRHS = b.clone();\n        a.each(function (y) {\n          if (y.power.lessThan(0)) newRHS = _.divide(newRHS, y);else t = _.multiply(t, y);\n        });\n        a = t;\n        b = newRHS;\n      } else if (a.group === CP) {\n        //the logic: loop through each and if it has a denominator then multiply it out on both ends\n        //and then start over\n        for (var x in a.symbols) {\n          var sym = a.symbols[x];\n\n          if (sym.group === CB) {\n            for (var y in sym.symbols) {\n              var sym2 = sym.symbols[y];\n\n              if (sym2.power.lessThan(0)) {\n                return new Equation(_.expand(_.multiply(sym2.clone().toLinear(), a)), _.expand(_.multiply(sym2.clone().toLinear(), b)));\n              }\n            }\n          }\n        }\n      }\n\n      return new Equation(a, b);\n    },\n    clone: function () {\n      return new Equation(this.LHS.clone(), this.RHS.clone());\n    },\n    sub: function (x, y) {\n      var clone = this.clone();\n      clone.LHS = clone.LHS.sub(x.clone(), y.clone());\n      clone.RHS = clone.RHS.sub(x.clone(), y.clone());\n      return clone;\n    },\n    isZero: function () {\n      return core.Utils.evaluate(this.toLHS()).equals(0);\n    },\n    latex: function (option) {\n      return [this.LHS.latex(option), this.RHS.latex(option)].join('=');\n    }\n  }; //overwrite the equals function\n\n  _.equals = function (a, b) {\n    return new Equation(a, b);\n  }; // Extend simplify\n\n\n  (function () {\n    var simplify = _.functions.simplify[0];\n\n    _.functions.simplify[0] = function (symbol) {\n      if (symbol instanceof Equation) {\n        symbol.LHS = simplify(symbol.LHS);\n        symbol.RHS = simplify(symbol.RHS);\n        return symbol;\n      } // Just call the original simplify\n\n\n      return simplify(symbol);\n    };\n  })();\n  /**\r\n   * Sets two expressions equal\r\n   * @param {Symbol} symbol\r\n   * @returns {Expression}\r\n   */\n\n\n  core.Expression.prototype.equals = function (symbol) {\n    if (symbol instanceof core.Expression) symbol = symbol.symbol; //grab the symbol if it's an expression\n\n    var eq = new Equation(this.symbol, symbol);\n    return eq;\n  };\n\n  core.Expression.prototype.solveFor = function (x) {\n    var symbol;\n\n    if (this.symbol instanceof Equation) {\n      //exit right away if we already have the answer\n      //check the LHS\n      if (this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x)) return new core.Expression(this.symbol.LHS); //check the RHS\n\n      if (this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x)) return new core.Expression(this.symbol.RHS); //otherwise just bring it to LHS\n\n      symbol = this.symbol.toLHS();\n    } else {\n      symbol = this.symbol;\n    }\n\n    return solve(symbol, x).map(function (x) {\n      return new core.Expression(x);\n    });\n  };\n\n  core.Expression.prototype.expand = function () {\n    if (this.symbol instanceof Equation) {\n      var clone = this.symbol.clone();\n      clone.RHS = _.expand(clone.RHS);\n      clone.LHS = _.expand(clone.LHS);\n      return new core.Expression(clone);\n    }\n\n    return new core.Expression(_.expand(this.symbol));\n  };\n\n  core.Expression.prototype.variables = function () {\n    if (this.symbol instanceof Equation) return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));\n    return variables(this.symbol);\n  };\n\n  var setEq = function (a, b) {\n    return _.equals(a, b);\n  }; //link the Equation class back to the core\n\n\n  core.Equation = Equation; //Loops through an array and attempts to fails a test. Stops if manages to fail.\n\n  var checkAll = core.Utils.checkAll = function (args, test) {\n    for (var i = 0; i < args.length; i++) if (test(args[i])) return false;\n\n    return true;\n  }; //version solve\n\n\n  var __ = core.Solve = {\n    version: '2.0.3',\n    solutions: [],\n    solve: function (eq, variable) {\n      var solution = solve(eq, String(variable));\n      return new core.Vector(solution); //return new core.Vector(solve(eq.toString(), variable ? variable.toString() : variable));\n    },\n\n    /**\r\n     * Brings the equation to LHS. A string can be supplied which will be converted to an Equation\r\n     * @param {Equation|String} eqn\r\n     * @returns {Symbol}\r\n     */\n    toLHS: function (eqn, expand) {\n      if (isSymbol(eqn)) return eqn; //If it's an equation then call its toLHS function instead\n\n      if (!(eqn instanceof Equation)) {\n        var es = eqn.split('='); //convert falsey values to zero\n\n        es[1] = es[1] || '0';\n        eqn = new Equation(_.parse(es[0]), _.parse(es[1]));\n      }\n\n      return eqn.toLHS(expand);\n    },\n    //        getSystemVariables: function(eqns) {\n    //            vars = variables(eqns[0], null, null, true);\n    //\n    //            //get all variables\n    //            for (var i = 1, l=eqns.length; i < l; i++)\n    //                vars = vars.concat(variables(eqns[i]));\n    //            //remove duplicates\n    //            vars = core.Utils.arrayUnique(vars).sort();\n    //            \n    //            //done\n    //            return vars;\n    //        },\n\n    /**\r\n     * Solve a set of circle equations. \r\n     * @param {Symbol[]} eqns\r\n     * @returns {Array}\r\n     */\n    solveCircle: function (eqns, vars) {\n      // Convert the variables to symbols\n      var svars = vars.map(function (x) {\n        return _.parse(x);\n      });\n      var deg = [];\n      var solutions = []; // Get the degree for the equations\n\n      for (var i = 0; i < eqns.length; i++) {\n        var d = [];\n\n        for (var j = 0; j < svars.length; j++) {\n          d.push(Number(core.Algebra.degree(eqns[i], svars[j])));\n        } // Store the total degree\n\n\n        d.push(core.Utils.arraySum(d, true));\n        deg.push(d);\n      }\n\n      var a = eqns[0];\n      var b = eqns[1];\n\n      if (deg[0][2] > deg[1][2]) {\n        [b, a] = [a, b];\n        [deg[1], deg[0]] = [deg[0], deg[1]];\n      } // Only solve it's truly a circle\n\n\n      if (deg[0][0] === 1 && deg[0][2] === 2 && deg[1][0] === 2 && deg[1][2] === 4) {\n        // For clarity we'll refer to the variables as x and y\n        var x = vars[0];\n        var y = vars[1]; // We can now get the two points for y\n\n        var y_points = solve(_.parse(b, knownVariable(x, solve(_.parse(a), x)[0])), y).map(function (x) {\n          return x.toString();\n        }); // Since we now know y we can get the two x points from the first equation\n\n        var x_points = [solve(_.parse(a, knownVariable(y, y_points[0])))[0].toString()];\n\n        if (y_points[1]) {\n          x_points.push(solve(_.parse(a, knownVariable(y, y_points[1])))[0].toString());\n        }\n\n        if (Settings.SOLUTIONS_AS_OBJECT) {\n          var solutions = {};\n          solutions[x] = x_points;\n          solutions[y] = y_points;\n        } else {\n          y_points.unshift(y);\n          x_points.unshift(x);\n          solutions = [x_points, y_points];\n        }\n      }\n\n      return solutions;\n    },\n\n    /**\r\n     * Solve a system of nonlinear equations\r\n     * @param {Symbol[]} eqns The array of equations\r\n     * @param {number} tries The maximum number of tries\r\n     * @param {number} start The starting point where to start looking for solutions\r\n     * @returns {Array}\r\n     */\n    solveNonLinearSystem: function (eqns, tries, start) {\n      if (tries < 0) {\n        return []; //can't find a solution\n      }\n\n      start = typeof start === 'undefined' ? core.Settings.NON_LINEAR_START : start; //the maximum number of times to jump\n\n      var max_tries = core.Settings.MAX_NON_LINEAR_TRIES; //halfway through the tries\n\n      var halfway = Math.floor(max_tries / 2); //initialize the number of tries to 10 if not specified\n\n      tries = typeof tries === 'undefined' ? max_tries : tries; //a point at which we check to see if we're converging. By inspection it seems that we can\n      //use around 20 iterations to see if we're converging. If not then we retry a jump of x\n\n      var jump_at = core.Settings.NON_LINEAR_JUMP_AT; //we jump by this many points at each pivot point\n\n      var jump = core.Settings.NON_LINEAR_JUMP_SIZE; //used to check if we actually found a solution or if we gave up. Assume we will find a solution.\n\n      var found = true;\n\n      var create_subs = function (vars, matrix) {\n        return vars.map(function (x, i) {\n          return Number(matrix.get(i, 0));\n        });\n      };\n\n      var vars = core.Utils.arrayGetVariables(eqns);\n      var jacobian = core.Matrix.jacobian(eqns, vars, function (x) {\n        return build(x, vars);\n      }, true);\n      var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;\n      var o, y, iters, xn1, norm, lnorm, xn, d;\n      var f_eqns = eqns.map(function (eq) {\n        return build(eq, vars);\n      });\n      var J = jacobian.map(function (e) {\n        return build(e, vars);\n      }, true); //initial values\n\n      xn1 = core.Matrix.cMatrix(0, vars); //initialize the c matrix with something close to 0. \n\n      var c = core.Matrix.cMatrix(start, vars);\n      iters = 0; //start of algorithm\n\n      do {\n        //if we've reached the max iterations then exit\n        if (iters > max_iter) {\n          break;\n          found = false;\n        } //set the substitution object\n\n\n        o = create_subs(vars, c); //set xn\n\n        xn = c.clone(); //make all the substitutions for each of the equations\n\n        f_eqns.forEach(function (f, i) {\n          c.set(i, 0, f.apply(null, o));\n        });\n        var m = new core.Matrix();\n        J.each(function (fn, i, j) {\n          var ans = fn.apply(null, o);\n          m.set(i, j, ans);\n        });\n        m = m.invert(); //preform the elimination\n\n        y = _.multiply(m, c).negate(); //the callback is to avoid overflow in the coeffient denonimator\n        //it converts it to a decimal and then back to a fraction. Some precision\n        //is lost be it's better than overflow. \n\n        d = y.subtract(xn1, function (x) {\n          return _.parse(Number(x));\n        });\n        xn1 = xn.add(y, function (x) {\n          return _.parse(Number(x));\n        }); //move c is now xn1\n\n        c = xn1; //get the norm\n        //the expectation is that we're converging to some answer as this point regardless of where we start\n        //this may have to be adjusted at some point because of erroneous assumptions\n\n        if (iters >= jump_at) {\n          //check the norm. If the norm is greater than one then it's time to try another point\n          if (norm > 1) {\n            //reset the start point at halway\n            if (tries === halfway) start = 0;\n            var sign = tries > halfway ? 1 : -1; //which side are we incrementing\n            //we increment +n at one side and -n at the other. \n\n            n = tries % Math.floor(halfway) + 1; //adjust the start point\n\n            start += sign * n * jump; //call restart\n\n            return __.solveNonLinearSystem(eqns, --tries, start);\n          }\n        }\n\n        lnorm = norm;\n        iters++;\n        norm = d.max(); //exit early. Revisit if we get bugs\n\n        if (Number(norm) === Number(lnorm)) {\n          break;\n        }\n      } while (Number(norm) >= Number.EPSILON); //return a blank set if nothing was found;\n\n\n      if (!found) return []; //return c since that's the answer\n\n      return __.systemSolutions(c, vars, true, function (x) {\n        return core.Utils.round(Number(x), 14);\n      });\n    },\n    systemSolutions: function (result, vars, expand_result, callback) {\n      var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];\n      result.each(function (e, idx) {\n        var solution = (expand_result ? _.expand(e) : e).valueOf();\n        if (callback) solution = callback.call(e, solution);\n        var variable = vars[idx];\n\n        if (core.Settings.SOLUTIONS_AS_OBJECT) {\n          solutions[variable] = solution;\n        } else solutions.push([variable, solution]);\n        /*NO*/\n\n      }); //done\n\n      return solutions;\n    },\n\n    /**\r\n     * Solves a system of equations by substitution. This is useful when\r\n     * no distinct solution exists. e.g. a line, plane, etc.\r\n     * @param {Array} eqns\r\n     * @returns {Array}\r\n     */\n    solveSystemBySubstitution: function (eqns) {\n      // Assume at least 2 equations. The function variables will just return an empty array if undefined is provided\n      var vars_a = variables(eqns[0]);\n      var vars_b = variables(eqns[1]); // Check if it's a circle equation\n\n      if (eqns.length === 2 && vars_a.length === 2 && core.Utils.arrayEqual(vars_a, vars_b)) {\n        return __.solveCircle(eqns, vars_a);\n      }\n\n      return []; // return an empty set\n    },\n    //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf\n\n    /**\r\n     * Solves a systems of equations\r\n     * @param {Array} eqns An array of equations\r\n     * @param {Array} var_array An array of variables\r\n     * @returns {Array|object}\r\n     */\n    solveSystem: function (eqns, var_array) {\n      //check if a var_array was specified\n      //nerdamer.clearVars();// this deleted ALL variables: not what we want\n      //parse all the equations to LHS. Remember that they come in as strings\n      for (var i = 0; i < eqns.length; i++) eqns[i] = __.toLHS(eqns[i]);\n\n      var l = eqns.length,\n          m = new core.Matrix(),\n          c = new core.Matrix(),\n          expand_result = false,\n          vars;\n\n      if (typeof var_array === 'undefined') {\n        //check to make sure that all the equations are linear\n        if (!_A.allLinear(eqns)) {\n          try {\n            return __.solveNonLinearSystem(eqns);\n          } catch (e) {\n            if (e instanceof core.exceptions.DivisionByZero) {\n              return __.solveSystemBySubstitution(eqns);\n            }\n          }\n        }\n\n        vars = core.Utils.arrayGetVariables(eqns); // Deal with redundant equations as expressed in #562\n        // The fix is to remove all but the number of equations equal to the number\n        // of variables. We then solve those and then evaluate the remaining equations\n        // with those solutions. If the all equal true then those are just redundant\n        // equations and we can return the solution set.\n\n        if (vars.length < eqns.length) {\n          var reduced = [];\n          var n = eqns.length;\n\n          for (var i = 0; i < n - 1; i++) {\n            reduced.push(_.parse(eqns[i]));\n          }\n\n          var knowns = {};\n\n          var solutions = __.solveSystem(reduced, vars); // The solutions may have come back as an array\n\n\n          if (Array.isArray(solutions)) {\n            solutions.forEach(function (sol) {\n              knowns[sol[0]] = sol[1];\n            });\n          } else {\n            knowns = solutions;\n          } // Start by assuming they will all evaluate to zero. If even one fails\n          // then all zero will be false\n\n\n          var all_zero = true; // Check if the last solution evalutes to zero given these solutions\n\n          for (var i = n - 1; i < n; i++) {\n            if (!_.parse(eqns[i], knowns).equals(0)) {\n              all_zero = false;\n            }\n          }\n\n          if (all_zero) {\n            return solutions;\n          }\n        } // deletes only the variables of the linear equations in the nerdamer namespace\n\n\n        for (var i = 0; i < vars.length; i++) {\n          nerdamer.setVar(vars[i], \"delete\");\n        } // TODO: move this to cMatrix or something similar\n        // populate the matrix\n\n\n        for (var i = 0; i < l; i++) {\n          var e = eqns[i]; //store the expression\n          // Iterate over the columns\n\n          for (var j = 0; j < vars.length; j++) {\n            var v = vars[j];\n            var coeffs = [];\n            e.each(function (x) {\n              if (x.contains(v)) {\n                coeffs = coeffs.concat(x.coeffs());\n              }\n            });\n            var cf = core.Utils.arraySum(coeffs);\n            m.set(i, j, cf);\n          } //strip the variables from the symbol so we're left with only the zeroth coefficient\n          //start with the symbol and remove each variable and its coefficient\n\n\n          var num = e.clone();\n          vars.map(function (e) {\n            num = num.stripVar(e, true);\n          });\n          c.set(i, 0, num.negate());\n        }\n      } else {\n        /**\r\n         * The idea is that we loop through each equation and then expand it. Afterwards we loop\r\n         * through each term and see if and check to see if it matches one of the variables.\r\n         * When a match is found we mark it. No other match should be found for that term. If it\r\n         * is we stop since it's not linear.\r\n         */\n        vars = var_array;\n        expand_result = true;\n\n        for (i = 0; i < l; i++) {\n          //prefill\n          c.set(i, 0, new Symbol(0));\n\n          var e = _.expand(eqns[i]).collectSymbols(); //expand and store\n          //go trough each of the variables\n\n\n          for (var j = 0; j < var_array.length; j++) {\n            m.set(i, j, new Symbol(0));\n            var v = var_array[j]; //go through the terms and sort the variables\n\n            for (var k = 0; k < e.length; k++) {\n              var term = e[k],\n                  check = false;\n\n              for (var z = 0; z < var_array.length; z++) {\n                //check to see if terms contain multiple variables\n                if (term.contains(var_array[z])) {\n                  if (check) core.err('Multiple variables found for term ' + term);\n                  check = true;\n                }\n              } //we made sure that every term contains one variable so it's safe to assume that if the\n              //variable is found then the remainder is the coefficient.\n\n\n              if (term.contains(v)) {\n                var tparts = explode(remove(e, k), v);\n                m.set(i, j, _.add(m.get(i, j), tparts[0]));\n              }\n            }\n          } //all the remaining terms go to the c matrix\n\n\n          for (k = 0; k < e.length; k++) {\n            c.set(i, 0, _.add(c.get(i, 0), e[k]));\n          }\n        } //consider case (a+b)*I+u\n\n      } //check if the system has a distinct solution\n\n\n      if (vars.length !== eqns.length || m.determinant().equals(0)) {\n        // solve the system by hand\n        //return __.solveSystemBySubstitution(eqns, vars, m, c);\n        throw new core.exceptions.SolveError('System does not have a distinct solution');\n      } // Use M^-1*c to solve system\n\n\n      m = m.invert();\n      var result = m.multiply(c); //correct the sign as per issue #410\n\n      if (core.Utils.isArray(var_array)) result.each(function (x) {\n        return x.negate();\n      });\n      return __.systemSolutions(result, vars, expand_result);\n    },\n\n    /**\r\n     * The quadratic function but only one side.\r\n     * @param {Symbol} c\r\n     * @param {Symbol} b\r\n     * @param {Symbol} a\r\n     * @returns {Symbol}\r\n     */\n    quad: function (c, b, a) {\n      var discriminant = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)))\n      /*b^2 - 4ac*/\n      ;\n\n      var det = _.pow(discriminant, Symbol(0.5));\n\n      var den = _.parse(_.multiply(new Symbol(2), a.clone()));\n\n      var retval = [_.parse(format('(-({0})+({1}))/({2})', b, det, den)), _.parse(format('(-({0})-({1}))/({2})', b, det, den))];\n      return retval;\n    },\n\n    /**\r\n     * The cubic equation\r\n     * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations\r\n     * @param {Symbol} d_o\r\n     * @param {Symbol} c_o\r\n     * @param {Symbol} b_o\r\n     * @param {Symbol} a_o\r\n     * @returns {Array}\r\n     */\n    cubic: function (d_o, c_o, b_o, a_o) {\n      //convert everything to text\n      var a = a_o.text(),\n          b = b_o.text(),\n          c = c_o.text(),\n          d = d_o.text();\n      var t = `(-(${b})^3/(27*(${a})^3)+(${b})*(${c})/(6*(${a})^2)-(${d})/(2*(${a})))`;\n      var u = `((${c})/(3*(${a}))-(${b})^2/(9*(${a})^2))`;\n      var v = `(${b})/(3*(${a}))`;\n      var x = `((${t})+sqrt((${t})^2+(${u})^3))^(1/3)+((${t})-sqrt((${t})^2+(${u})^3))^(1/3)-(${v})`; // Convert a to one\n\n      var w = '1/2+sqrt(3)/2*i'; // Cube root of unity\n\n      return [_.parse(x), _.parse(`(${x})(${w})`), _.parse(`(${x})(${w})^2`)];\n    },\n\n    /**\r\n     * The quartic equation\r\n     * @param {Symbol} e\r\n     * @param {Symbol} d\r\n     * @param {Symbol} c\r\n     * @param {Symbol} b\r\n     * @param {Symbol} a\r\n     * @returns {Array}\r\n     */\n    quartic: function (e, d, c, b, a) {\n      var scope = {};\n      core.Utils.arrayUnique(variables(a).concat(variables(b)).concat(variables(c)).concat(variables(d)).concat(variables(e))).map(function (x) {\n        scope[x] = 1;\n      });\n      a = a.toString();\n      b = b.toString();\n      c = c.toString();\n      d = d.toString();\n      e = e.toString();\n      var p, q, D, D0, D1, Q, x1, x2, x3, x4;\n      /*var D = core.Utils.block('PARSE2NUMBER', function() {\r\n       return _.parse(format(\"256*({0})^3*({4})^3-192*({0})^2*({1})*({3})*({4})^2-128*({0})^2*({2})^2*({4})^2+144*({0})^2*({2})*({3})^2*({4})\"+\r\n       \"-27*({0})^2*({3})^4+144*({0})*({1})^2*({2})*({4})^2-6*({0})*({1})^2*({3})^2*({4})-80*({0})*({1})*({2})^2*({3})*({4})+18*({0})*({1})*({2})*({3})^3\"+\r\n       \"+16*({0})*({2})^4*({4})-4*({0})*({2})^3*({3})^2-27*({1})^4*({4})^2+18*({1})^3*({2})*({3})*({4})-4*({1})^3*({3})^3-4*({1})^2*({2})^3*({4})+({1})^2*({2})^2*({3})^2\", \r\n       a, b, c, d, e), scope);\r\n       });*/\n\n      p = _.parse(format(\"(8*({0})*({2})-3*({1})^2)/(8*({0})^2)\", a, b, c)).toString(); //a, b, c\n\n      q = _.parse(format(\"(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)\", a, b, c, d)).toString(); //a, b, c, d, e\n\n      D0 = _.parse(format(\"12*({0})*({4})-3*({1})*({3})+({2})^2\", a, b, c, d, e)).toString(); //a, b, c, d, e\n\n      D1 = _.parse(format(\"2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})\", a, b, c, d, e)).toString(); //a, b, c, d, e\n\n      Q = _.parse(format(\"((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)\", D0, D1)).toString(); //D0, D1\n\n      S = _.parse(format(\"(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)\", a, p, Q, D0)).toString(); //a, p, Q, D0\n\n      x1 = _.parse(format(\"-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      x2 = _.parse(format(\"-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      x3 = _.parse(format(\"-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      x4 = _.parse(format(\"-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      return [x1, x2, x3, x4];\n    },\n\n    /**\r\n     * Breaks the equation up in its factors and tries to solve the smaller parts\r\n     * @param {Symbol} symbol\r\n     * @param {String} solve_for\r\n     * @returns {Array}\r\n     */\n    divideAndConquer: function (symbol, solve_for) {\n      var sols = []; //see if we can solve the factors\n\n      var factors = core.Algebra.Factor.factor(symbol);\n\n      if (factors.group === CB) {\n        factors.each(function (x) {\n          x = Symbol.unwrapPARENS(x);\n          sols = sols.concat(solve(x, solve_for));\n        });\n      }\n\n      return sols;\n    },\n\n    /**\r\n     * Attempts to solve the equation assuming it's a polynomial with numeric coefficients\r\n     * @param {Symbol} eq\r\n     * @param {String} solve_for\r\n     * @returns {Array}\r\n     */\n    csolve: function (eq, solve_for) {\n      return core.Utils.block('IGNORE_E', function () {\n        var f, p, pn, n, pf, r, theta, sr, sp, roots;\n        roots = [];\n        f = core.Utils.decompose_fn(eq, solve_for, true);\n\n        if (f.x.group === S) {\n          p = _.parse(f.x.power);\n          pn = Number(p);\n          n = _.pow(_.divide(f.b.negate(), f.a), p.invert());\n          pf = Symbol.toPolarFormArray(n);\n          r = pf[0];\n          theta = pf[1];\n          sr = r.toString();\n          sp = p.toString();\n          var k, root, str;\n\n          for (var i = 0; i < pn; i++) {\n            k = i;\n            str = format('({0})*e^(2*{1}*pi*{2}*{3})', sr, k, p, core.Settings.IMAGINARY);\n            root = _.parse(str);\n            roots.push(root);\n          }\n        }\n\n        return roots;\n      }, true);\n    },\n\n    /**\r\n     * Generates starting points for the Newton solver given an expression at zero.\r\n     * It beings by check if zero is a good point and starts expanding by a provided step size. \r\n     * Builds on the fact that if the sign changes over an interval then a zero\r\n     * must exist on that interval\r\n     * @param {Symbol} symbol\r\n     * @param {Number} step\r\n     * @param {Array} points\r\n     * @returns {Array}\r\n     */\n    getPoints: function (symbol, step, points) {\n      step = step || 0.01;\n      points = points || [];\n      var f = build(symbol);\n      var x0 = 0;\n      var start = Math.round(x0),\n          last = f(start),\n          last_sign = last / Math.abs(last),\n          rside = core.Settings.ROOTS_PER_SIDE,\n          // the max number of roots on right side\n      lside = rside; // the max number of roots on left side\n      // check around the starting point\n\n      points.push(Math.floor(start / 2)); //half way from zero might be a good start\n\n      points.push(Math.abs(start)); //|f(0)| could be a good start\n\n      points.push(start); //|f(0)| could be a good start\n      //adjust for log. A good starting point to include for log is 0.1\n\n      symbol.each(function (x) {\n        if (x.containsFunction(core.Settings.LOG)) points.push(0.1);\n      });\n      var left = range(-core.Settings.SOLVE_RADIUS, start, step),\n          right = range(start, core.Settings.SOLVE_RADIUS, step);\n\n      var test_side = function (side, num_roots) {\n        var xi, val, sign;\n        var hits = [];\n\n        for (var i = 0, l = side.length; i < l; i++) {\n          xi = side[i]; //the point being evaluated\n\n          val = f(xi);\n          sign = val / Math.abs(val); //Don't add non-numeric values\n\n          if (isNaN(val) || !isFinite(val) || hits.length > num_roots) {\n            continue;\n          } //compare the signs. The have to be different if they cross a zero\n\n\n          if (sign !== last_sign) {\n            hits.push(xi); //take note of the possible zero location\n          }\n\n          last_sign = sign;\n        }\n\n        points = points.concat(hits);\n      };\n\n      test_side(left, lside);\n      test_side(right, rside);\n      return points;\n    },\n\n    /**\r\n     * Implements the bisection method. Returns undefined in no solution is found\r\n     * @param {number} point\r\n     * @param {function} f\r\n     * @returns {undefined | number}\r\n     */\n    bisection: function (point, f) {\n      var left = point - 1;\n      var right = point + 1; // First test if this point is even worth evaluating. It should\n      // be crossing the x axis so the signs should be different\n\n      if (Math.sign(f(left)) !== Math.sign(f(right))) {\n        var safety = 0;\n        var epsilon, middle;\n\n        do {\n          epsilon = Math.abs(right - left); // Safety against an infinite loop\n\n          if (safety++ > core.Settings.MAX_BISECTION_ITER || isNaN(epsilon)) {\n            return;\n          } // Calculate the middle point\n\n\n          middle = (left + right) / 2;\n\n          if (f(left) * f(middle) > 0) {\n            left = middle;\n          } else {\n            right = middle;\n          }\n        } while (epsilon >= Settings.EPSILON);\n\n        var solution = (left + right) / 2; // Test the solution to make sure that it's within tolerance\n\n        var x_point = f(solution);\n\n        if (!isNaN(x_point) && Math.abs(x_point) <= core.Settings.BI_SECTION_EPSILON) {\n          // Returns too many junk solutions if not rounded at 13th place.\n          return core.Utils.round(solution, 13);\n        }\n      }\n    },\n\n    /**\r\n     * Implements Newton's iterations. Returns undefined if no solutions if found\r\n     * @param {number} point\r\n     * @param {function} f\r\n     * @param {function} fp\r\n     * @returns {undefined|number}\r\n     */\n    Newton: function (point, f, fp) {\n      var maxiter = core.Settings.MAX_NEWTON_ITERATIONS,\n          iter = 0; //first try the point itself. If it's zero viola. We're done\n\n      var x0 = point,\n          x;\n\n      do {\n        var fx0 = f(x0); //store the result of the function\n        //if the value is zero then we're done because 0 - (0/d f(x0)) = 0\n\n        if (x0 === 0 && fx0 === 0) {\n          x = 0;\n          break;\n        }\n\n        iter++;\n        if (iter > maxiter) return; //naximum iterations reached\n\n        x = x0 - fx0 / fp(x0);\n        var e = Math.abs(x - x0);\n        x0 = x;\n      } while (e > Settings.NEWTON_EPSILON); //check if the number is indeed zero. 1e-13 seems to give the most accurate results\n\n\n      if (Math.abs(f(x)) <= Settings.EPSILON) return x;\n    },\n    rewrite: function (rhs, lhs, for_variable) {\n      lhs = lhs || new Symbol(0);\n\n      if (rhs.isComposite() && rhs.isLinear()) {\n        //try to isolate the square root\n        //container for the square roots\n        var sqrts = []; //all else\n\n        var rem = [];\n        rhs.each(function (x) {\n          x = x.clone();\n\n          if (x.fname === 'sqrt' && x.contains(for_variable)) {\n            sqrts.push(x);\n          } else {\n            rem.push(x);\n          }\n        }, true);\n\n        if (sqrts.length === 1) {\n          //move the remainder to the RHS\n          lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2))); //square both sides\n\n          rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));\n        }\n      } else {\n        rhs = Symbol.unwrapSQRT(_.expand(rhs)); //expand the term expression go get rid of quotients when possible\n      }\n\n      var c = 0,\n          //a counter to see if we have all terms with the variable\n      l = rhs.length; //try to rewrite the whole thing\n\n      if (rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {\n        rhs.distributeMultiplier();\n        var t = new Symbol(0); //first bring all the terms containing the variable to the lhs\n\n        rhs.each(function (x) {\n          if (x.contains(for_variable)) {\n            c++;\n            t = _.add(t, x.clone());\n          } else lhs = _.subtract(lhs, x.clone());\n        });\n        rhs = t; //if not all the terms contain the variable so it's in the form\n        //a*x^2+x\n\n        if (c !== l) {\n          return __.rewrite(rhs, lhs, for_variable);\n        } else {\n          return [rhs, lhs];\n        }\n      } else if (rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {\n        if (rhs.multiplier.lessThan(0)) {\n          rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));\n          lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));\n        }\n\n        if (lhs.equals(0)) return new Symbol(0);else {\n          var t = new Symbol(1);\n          rhs.each(function (x) {\n            if (x.contains(for_variable)) t = _.multiply(t, x.clone());else lhs = _.divide(lhs, x.clone());\n          });\n          rhs = t;\n          return __.rewrite(rhs, lhs, for_variable);\n        }\n      } else if (!rhs.isLinear() && rhs.contains(for_variable)) {\n        var p = _.parse(rhs.power.clone().invert());\n\n        rhs = _.pow(rhs, p.clone());\n        lhs = _.pow(_.expand(lhs), p.clone());\n        return __.rewrite(rhs, lhs, for_variable);\n      } else if (rhs.group === FN || rhs.group === S || rhs.group === PL) {\n        return [rhs, lhs];\n      }\n    },\n    sqrtSolve: function (symbol, v) {\n      var sqrts = new Symbol(0);\n      var rem = new Symbol(0);\n\n      if (symbol.isComposite()) {\n        symbol.each(function (x) {\n          if (x.fname === 'sqrt' && x.contains(v)) {\n            sqrts = _.add(sqrts, x.clone());\n          } else {\n            rem = _.add(rem, x.clone());\n          }\n        }); //quick and dirty ATM\n\n        if (!sqrts.equals(0)) {\n          var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2))))); //square both sides\n\n\n          var solutions = solve(t, v); //test the points. The dumb way of getting the answers\n\n          solutions = solutions.filter(function (e) {\n            if (e.isImaginary()) return e;\n            var subs = {};\n            subs[v] = e;\n            var point = evaluate(symbol, subs);\n            if (point.equals(0)) return e;\n          });\n          return solutions;\n        }\n      }\n    }\n  };\n  /*\r\n   * \r\n   * @param {String[]|String|Equation} eqns\r\n   * @param {String} solve_for\r\n   * @param {Array} solutions\r\n   * @param {Number} depth\r\n   * @param {String|Equation} fn\r\n   * @returns {Array}\r\n   */\n\n\n  var solve = function (eqns, solve_for, solutions, depth, fn) {\n    depth = depth || 0;\n\n    if (depth++ > Settings.MAX_SOLVE_DEPTH) {\n      return solutions;\n    } //make preparations if it's an Equation\n\n\n    if (eqns instanceof Equation) {\n      //if it's zero then we're done\n      if (eqns.isZero()) {\n        return [new Symbol(0)];\n      } //if the lhs = x then we're done\n\n\n      if (eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {\n        return [eqns.RHS];\n      } //if the rhs = x then we're done\n\n\n      if (eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {\n        return [eqns.LHS];\n      }\n    } //unwrap the vector since what we want are the elements\n\n\n    if (eqns instanceof core.Vector) eqns = eqns.elements;\n    solve_for = solve_for || 'x'; //assumes x by default\n    //If it's an array then solve it as a system of equations\n\n    if (isArray(eqns)) {\n      return __.solveSystem.apply(undefined, arguments);\n    } // Parse out functions. Fix for issue #300\n    // eqns = core.Utils.evaluate(eqns);\n\n\n    solutions = solutions || []; //mark existing solutions as not to have duplicates\n\n    var existing = {}; // Easy fail. If it's a rational function and the denominator is zero\n    // the we're done. Issue #555\n\n    var known = {};\n    known[solve_for] = 0;\n\n    if (isSymbol(eqns) && evaluate(eqns.getDenom(), known).equals(0) === true) {\n      return solutions;\n    } // Is usued to add solutions to set. \n    // TODO: Set is now implemented and should be utilized\n\n\n    var add_to_result = function (r, has_trig) {\n      var r_is_symbol = isSymbol(r);\n      if (r === undefined || typeof r === 'number' && isNaN(r)) return;\n\n      if (isArray(r)) {\n        r.forEach(function (sol) {\n          add_to_result(sol);\n        });\n      } else {\n        if (r.valueOf() !== 'null') {\n          // Call the pre-add function if defined. This could be useful for rounding\n          if (typeof core.Settings.PRE_ADD_SOLUTION === 'function') {\n            r = core.Settings.PRE_ADD_SOLUTION(r);\n          }\n\n          if (!r_is_symbol) {\n            r = _.parse(r);\n          } // try to convert the number to multiples of pi\n\n\n          if (core.Settings.make_pi_conversions && has_trig) {\n            var temp = _.divide(r.clone(), new Symbol(Math.PI)),\n                m = temp.multiplier,\n                a = Math.abs(m.num),\n                b = Math.abs(m.den);\n\n            if (a < 10 && b < 10) r = _.multiply(temp, new Symbol('pi'));\n          } // And check if we get a number otherwise we might be throwing out symbolic solutions.\n\n\n          var r_str = r.toString();\n\n          if (!existing[r_str]) {\n            solutions.push(r);\n          } // Mark the answer as seen\n\n\n          existing[r_str] = true;\n        }\n      }\n    }; // Maybe we get lucky. Try the point at the function. If it works we have a point\n    // If not it failed\n\n\n    if (eqns.group === S && eqns.contains(solve_for)) {\n      try {\n        var o = {};\n        o[solve_for] = 0;\n        evaluate(fn, o, 'numer');\n        add_to_result(new Symbol(0));\n      } catch (e) {// Do nothing;\n      }\n\n      return solutions;\n    }\n\n    if (eqns.group === CB) {\n      // It suffices to solve for the numerator\n      var num = eqns.getNum();\n\n      if (num.group === CB) {\n        var sf = String(solve_for); //everything else belongs to the coeff\n        //get the denominator and make sure it doesn't have x since we don't know how to solve for those\n\n        num.each(function (x) {\n          if (x.contains(sf)) solve(x, solve_for, solutions, depth, eqns);\n        });\n        return solutions;\n      }\n\n      return solve(num, solve_for, solutions, depth, fn);\n    }\n\n    if (eqns.group === FN && eqns.fname === 'sqrt') {\n      eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));\n    } //pass in false to not expand equations such as (x+y)^5.\n    //It suffices to solve for the numerator since there's no value in the denominator which yields a zero for the function\n\n\n    var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(),\n        vars = core.Utils.variables(eq),\n        //get a list of all the variables\n    numvars = vars.length; //how many variables are we dealing with\n    //it sufficient to solve (x+y) if eq is (x+y)^n since 0^n\n\n    if (core.Utils.isInt(eq.power) && eq.power > 0) {\n      eq = _.parse(eq).toLinear();\n    } //if we're dealing with a single variable then we first check if it's a \n    //polynomial (including rationals).If it is then we use the Jenkins-Traubb algorithm.     \n    //Don't waste time\n\n\n    if (eq.group === S || eq.group === CB && eq.contains(solve_for)) {\n      return [new Symbol(0)];\n    } //force to polynomial. We go through each and then we look at what it would \n    //take for its power to be an integer\n    //if the power is a fractional we divide by the fractional power\n\n\n    var fractionals = {},\n        cfact;\n\n    var correct_denom = function (symbol) {\n      symbol = _.expand(symbol, {\n        expand_denominator: true,\n        expand_functions: true\n      });\n      var original = symbol.clone(); //preserve the original\n\n      if (symbol.symbols) {\n        for (var x in symbol.symbols) {\n          var sym = symbol.symbols[x]; //get the denominator of the sub-symbol\n\n          var den = sym.getDenom();\n\n          if (!den.isConstant(true) && symbol.isComposite()) {\n            var t = new Symbol(0);\n            symbol.each(function (e) {\n              t = _.add(t, _.multiply(e, den.clone()));\n            });\n            return correct_denom(_.multiply(_.parse(symbol.multiplier), t));\n          }\n\n          var parts = explode(sym, solve_for);\n          var is_sqrt = parts[1].fname === core.Settings.SQRT;\n          var v = Symbol.unwrapSQRT(parts[1]);\n          var p = v.power.clone(); //circular logic with sqrt. Since sqrt(x) becomes x^(1/2) which then becomes sqrt(x), this continues forever\n          //this needs to be terminated if p = 1/2\n\n          if (!isSymbol(p) && !p.equals(1 / 2)) {\n            if (p.den.gt(1)) {\n              if (is_sqrt) {\n                symbol = _.subtract(symbol, sym.clone());\n                symbol = _.add(symbol, _.multiply(parts[0].clone(), v));\n                return correct_denom(symbol);\n              }\n\n              var c = fractionals[p.den];\n              fractionals[p.den] = c ? c++ : 1;\n            } else if (p.sign() === -1) {\n              var factor = _.parse(solve_for + '^' + Math.abs(p)); //this\n              //unwrap the symbol's denoniator\n\n\n              symbol.each(function (y, index) {\n                if (y.contains(solve_for)) {\n                  symbol.symbols[index] = _.multiply(y, factor.clone());\n                }\n              });\n              fractionals = {};\n              return correct_denom(_.parse(symbol));\n            } else if (sym.group === PL) {\n              var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));\n\n              if (min_p < 0) {\n                var factor = _.parse(solve_for + '^' + Math.abs(min_p));\n\n                var corrected = new Symbol(0);\n                original.each(function (x) {\n                  corrected = _.add(corrected, _.multiply(x.clone(), factor.clone()));\n                }, true);\n                return corrected;\n              }\n            }\n          }\n        }\n      }\n\n      return symbol;\n    }; //separate the equation\n\n\n    var separate = function (eq) {\n      var lhs = new Symbol(0),\n          rhs = new Symbol(0);\n      eq.each(function (x) {\n        if (x.contains(solve_for, true)) lhs = _.add(lhs, x.clone());else rhs = _.subtract(rhs, x.clone());\n      });\n      return [lhs, rhs];\n    };\n\n    __.inverseFunctionSolve = function (name, lhs, rhs) {\n      //ax+b comes back as [a, x, ax, b];\n      var parts = explode(lhs.args[0], solve_for); //check if x is by itself\n\n      var x = parts[1];\n\n      if (x.group === S) {\n        return _.divide(_.symfunction(name, [_.divide(rhs, _.parse(lhs.multiplier))]), parts[0]);\n      }\n    }; //first remove any denominators\n\n\n    eq = correct_denom(eq);\n    if (eq.equals(0)) return [eq]; //correct fractionals. I can only handle one type right now\n\n    var fkeys = core.Utils.keys(fractionals);\n\n    if (fkeys.length === 1) {\n      //make a note of the factor\n      cfact = fkeys[0];\n      eq.each(function (x, index) {\n        if (x.contains(solve_for)) {\n          var parts = explode(x, solve_for);\n          var v = parts[1];\n          var p = v.power;\n\n          if (p.den.gt(1)) {\n            v.power = p.multiply(new core.Frac(cfact));\n            eq.symbols[index] = _.multiply(v, parts[0]);\n          }\n        }\n      });\n      eq = _.parse(eq);\n    } //try for nested sqrts as per issue #486\n\n\n    add_to_result(__.sqrtSolve(eq, solve_for)); //polynomial single variable\n\n    if (numvars === 1) {\n      if (eq.isPoly(true)) {\n        //try to factor and solve\n        var factors = new core.Algebra.Classes.Factors();\n        core.Algebra.Factor.factor(eq, factors); //if the equation has more than one symbolic factor then solve those individually\n\n        if (factors.getNumberSymbolics() > 1) {\n          for (var x in factors.factors) {\n            add_to_result(solve(factors.factors[x], solve_for));\n          }\n        } else {\n          var coeffs = core.Utils.getCoeffs(eq, solve_for),\n              deg = coeffs.length - 1,\n              was_calculated = false;\n\n          if (vars[0] === solve_for) {\n            //check to see if all the coefficients are constant\n            if (checkAll(coeffs, function (x) {\n              return x.group !== core.groups.N;\n            })) {\n              var roots = core.Algebra.proots(eq); //if all the roots are integers then return those\n\n              if (checkAll(roots, function (x) {\n                return !core.Utils.isInt(x);\n              })) {\n                //roots have been calculates\n                was_calculated = true;\n                roots.map(function (x) {\n                  add_to_result(new Symbol(x));\n                });\n              }\n            }\n\n            if (!was_calculated) {\n              eqns = _.parse(eqns);\n              if (eqns instanceof core.Equation) eqns = eqns.toLHS(); //we can solve algebraically for degrees 1, 2, 3. The remainder we switch to Jenkins-\n\n              if (deg === 1) add_to_result(_.divide(coeffs[0], coeffs[1].negate()));else if (deg === 2) {\n                add_to_result(_.expand(__.quad.apply(undefined, coeffs)));\n              } else if (deg === 3) {\n                var solutions = []; //set to blank\n                //first try to factor and solve\n\n                var factored = core.Algebra.Factor.factor(eqns); //if it was successfully factored\n\n                var solutions = [];\n                if (solutions.length > 0) add_to_result(solutions);else add_to_result(__.cubic.apply(undefined, coeffs));\n              } else {\n                /*\r\n                 var sym_roots = csolve(eq, solve_for); \r\n                 if(sym_roots.length === 0)\r\n                 sym_roots = divnconsolve(eq, solve_for);\r\n                 if(sym_roots.length > 0) \r\n                 add_to_result(sym_roots);\r\n                 else\r\n                 */\n                _A.proots(eq).map(add_to_result);\n              }\n            }\n          }\n        }\n      } else {\n        try {\n          // Attempt Newton\n          // Since it's not a polynomial then we'll try to look for a solution using Newton's method\n          var has_trig = eq.hasTrig(); // we get all the points where a possible zero might exist.\n\n          var points1 = __.getPoints(eq, 0.1);\n\n          var points2 = __.getPoints(eq, 0.05);\n\n          var points3 = __.getPoints(eq, 0.01);\n\n          var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function (a, b) {\n            return a - b;\n          });\n          var i, point, solution; // Compile the function\n\n          var f = build(eq.clone()); // First try to eliminate some points using bisection\n\n          var t_points = [];\n\n          for (i = 0; i < points.length; i++) {\n            point = points[i]; // See if there's a solution at this point\n\n            solution = __.bisection(point, f); // If there's no solution then add it to the array for further investigation\n\n            if (typeof solution === 'undefined') {\n              t_points.push(point);\n              continue;\n            } // Add the solution to the solution set\n\n\n            add_to_result(solution, has_trig);\n          } // Reset the points to the remaining points\n\n\n          points = t_points; // Build the derivative and compile a function\n\n          var d = _C.diff(eq.clone());\n\n          var fp = build(d);\n\n          for (i = 0; i < points.length; i++) {\n            point = points[i];\n            add_to_result(__.Newton(point, f, fp), has_trig);\n          }\n\n          solutions.sort();\n        } catch (e) {\n          console.log(e);\n        }\n      }\n    } else {\n      //The idea here is to go through the equation and collect the coefficients\n      //place them in an array and call the quad or cubic function to get the results\n      if (!eq.hasFunc(solve_for) && eq.isComposite()) {\n        try {\n          var factored = core.Algebra.Factor.factor(eq.clone());\n\n          if (factored.group === CB) {\n            factored.each(function (x) {\n              add_to_result(solve(x, solve_for));\n            });\n          } else {\n            var coeffs = core.Utils.getCoeffs(eq, solve_for);\n            var l = coeffs.length,\n                deg = l - 1; //the degree of the polynomial\n            //get the denominator and make sure it doesn't have x\n            //handle the problem based on the degree\n\n            switch (deg) {\n              case 0:\n                var separated = separate(eq);\n                var lhs = separated[0],\n                    rhs = separated[1];\n\n                if (lhs.group === core.groups.EX) {\n                  add_to_result(_.parse(core.Utils.format(core.Settings.LOG + '(({0})/({2}))/' + core.Settings.LOG + '({1})', rhs, lhs.value, lhs.multiplier)));\n                }\n\n                break;\n\n              case 1:\n                //nothing to do but to return the quotient of the constant and the LT\n                //e.g. 2*x-1\n                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\n                break;\n\n              case 2:\n                add_to_result(__.quad.apply(undefined, coeffs));\n                break;\n\n              case 3:\n                add_to_result(__.cubic.apply(undefined, coeffs));\n                break;\n\n              case 4:\n                add_to_result(__.quartic.apply(undefined, coeffs));\n                break;\n\n              default:\n                add_to_result(__.csolve(eq, solve_for));\n                if (solutions.length === 0) add_to_result(__.divideAndConquer(eq, solve_for));\n            }\n\n            if (solutions.length === 0) {\n              //try factoring\n              add_to_result(solve(factored, solve_for, solutions, depth));\n            }\n          }\n        } catch (e) {\n          /*something went wrong. EXITING*/\n          ;\n        }\n      } else {\n        try {\n          var rw = __.rewrite(eq, null, solve_for);\n\n          var lhs = rw[0];\n          var rhs = rw[1];\n\n          if (lhs.group === FN) {\n            if (lhs.fname === 'abs') {\n              add_to_result([rhs.clone(), rhs.negate()]);\n            } else if (lhs.fname === 'sin') {\n              //asin\n              add_to_result(__.inverseFunctionSolve('asin', lhs, rhs));\n            } else if (lhs.fname === 'cos') {\n              //asin\n              add_to_result(__.inverseFunctionSolve('acos', lhs, rhs));\n            } else if (lhs.fname === 'tan') {\n              //asin\n              add_to_result(__.inverseFunctionSolve('atan', lhs, rhs));\n            } else if (lhs.fname === core.Settings.LOG) {\n              //ax+b comes back as [a, x, ax, b];\n              var parts = explode(lhs.args[0], solve_for); //check if x is by itself\n\n              var x = parts[1];\n\n              if (x.group === S) {\n                rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol('e'), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);\n                var eq = new Equation(x, rhs).toLHS();\n                add_to_result(solve(eq, solve_for));\n              }\n            } else add_to_result(_.subtract(lhs, rhs));\n          } else {\n            var neq = new Equation(lhs, rhs).toLHS(); //create a new equation\n\n            if (neq.equals(eq)) throw new Error('Stopping. No stop condition exists');\n            add_to_result(solve(neq, solve_for));\n          }\n        } catch (error) {\n          //Let's try this another way\n          try {\n            //1. if the symbol is in the form a*b*c*... then the solution is zero if \n            //either a or b or c is zero.\n            if (eq.group === CB) add_to_result(0);else if (eq.group === CP) {\n              var separated = separate(eq);\n              var lhs = separated[0],\n                  rhs = separated[1]; //reduce the equation\n\n              if (lhs.group === core.groups.EX && lhs.value === solve_for) {\n                //change the base of both sides\n                var p = lhs.power.clone().invert();\n                add_to_result(_.pow(rhs, p));\n              }\n            }\n          } catch (error) {\n            ;\n          }\n        }\n      }\n    }\n\n    if (cfact) {\n      solutions = solutions.map(function (x) {\n        return _.pow(x, new Symbol(cfact));\n      });\n    } // Perform some cleanup but don't do it agains arrays, etc\n    // Check it actually evaluates to zero\n\n\n    if (isSymbol(eqns)) {\n      var knowns = {};\n      solutions = solutions.filter(function (x) {\n        try {\n          knowns[solve_for] = x;\n          var zero = Number(evaluate(eqns, knowns)); // Allow symbolic answers\n\n          if (isNaN(zero)) {\n            return true;\n          }\n\n          return true;\n        } catch (e) {\n          return false;\n        }\n      });\n    }\n\n    return solutions;\n  }; //Register the functions for external use\n\n\n  nerdamer.register([{\n    name: 'solveEquations',\n    parent: 'nerdamer',\n    numargs: -1,\n    visible: true,\n    build: function () {\n      return solve; //comment out to return a vector\n\n      /*\r\n       return function() {\r\n       return core.Utils.convertToVector(solve.apply(null, arguments));\r\n       };\r\n       */\n    }\n  }, {\n    name: 'solve',\n    parent: 'Solve',\n    numargs: 2,\n    visible: true,\n    build: function () {\n      return core.Solve.solve;\n    }\n  }, {\n    name: 'setEquation',\n    parent: 'Solve',\n    visible: true,\n    build: function () {\n      return setEq;\n    }\n  }]);\n  nerdamer.api();\n})();","map":{"version":3,"sources":["C:/Users/brisk/OneDrive/Documents/GitHub/seeciv/my-app/node_modules/nerdamer/Solve.js"],"names":["module","nerdamer","require","core","getCore","_","PARSER","_A","Algebra","_C","Calculus","explode","integration","decompose_arg","evaluate","Utils","remove","format","build","knownVariable","Symbol","isSymbol","variables","S","groups","PL","CB","CP","FN","Settings","range","isArray","SOLVE_RADIUS","ROOTS_PER_SIDE","make_pi_conversions","STEP_SIZE","EPSILON","MAX_NEWTON_ITERATIONS","MAX_NON_LINEAR_TRIES","NON_LINEAR_JUMP_AT","NON_LINEAR_JUMP_SIZE","NON_LINEAR_START","NEWTON_SLICES","NEWTON_EPSILON","Number","SOLUTION_PROXIMITY","FILTER_SOLUTIONS","MAX_SOLVE_DEPTH","ZERO_EPSILON","MAX_BISECTION_ITER","BI_SECTION_EPSILON","prototype","hasTrig","containsFunction","hasNegativeTerms","isComposite","x","symbols","sym","group","power","lessThan","Equation","lhs","rhs","isConstant","equals","IMAGINARY","exceptions","NerdamerValueError","toString","LHS","RHS","text","option","toLHS","expand","eqn","clone","removeDenom","a","b","_t","subtract","retval","den","multiply","getDenom","t","multiplier","newRHS","each","y","divide","sym2","toLinear","sub","isZero","latex","join","simplify","functions","symbol","Expression","eq","solveFor","solve","map","arrayUnique","concat","setEq","checkAll","args","test","i","length","__","Solve","version","solutions","variable","solution","String","Vector","es","split","parse","solveCircle","eqns","vars","svars","deg","d","j","push","degree","arraySum","y_points","x_points","SOLUTIONS_AS_OBJECT","unshift","solveNonLinearSystem","tries","start","max_tries","halfway","Math","floor","jump_at","jump","found","create_subs","matrix","get","arrayGetVariables","jacobian","Matrix","max_iter","o","iters","xn1","norm","lnorm","xn","f_eqns","J","e","cMatrix","c","forEach","f","set","apply","m","fn","ans","invert","negate","add","sign","n","max","systemSolutions","round","result","expand_result","callback","idx","valueOf","call","solveSystemBySubstitution","vars_a","vars_b","arrayEqual","solveSystem","var_array","l","allLinear","DivisionByZero","reduced","knowns","Array","sol","all_zero","setVar","v","coeffs","contains","cf","num","stripVar","collectSymbols","k","term","check","z","err","tparts","determinant","SolveError","quad","discriminant","pow","det","cubic","d_o","c_o","b_o","a_o","u","w","quartic","scope","p","q","D","D0","D1","Q","x1","x2","x3","x4","divideAndConquer","solve_for","sols","factors","Factor","factor","unwrapPARENS","csolve","block","pn","pf","r","theta","sr","sp","roots","decompose_fn","toPolarFormArray","root","str","getPoints","step","points","x0","last","last_sign","abs","rside","lside","LOG","left","right","test_side","side","num_roots","xi","val","hits","isNaN","isFinite","bisection","point","safety","epsilon","middle","x_point","Newton","fp","maxiter","iter","fx0","rewrite","for_variable","isLinear","sqrts","rem","fname","unwrapSQRT","distributeMultiplier","Frac","sqrtSolve","filter","isImaginary","subs","depth","elements","undefined","arguments","existing","known","add_to_result","has_trig","r_is_symbol","PRE_ADD_SOLUTION","temp","PI","r_str","getNum","sf","numvars","isInt","fractionals","cfact","correct_denom","expand_denominator","expand_functions","original","parts","is_sqrt","SQRT","gt","index","min_p","arrayMin","keys","corrected","separate","inverseFunctionSolve","name","symfunction","fkeys","isPoly","Classes","Factors","getNumberSymbolics","getCoeffs","was_calculated","N","proots","factored","points1","points2","points3","sort","t_points","diff","console","log","hasFunc","separated","EX","value","rw","neq","Error","error","zero","register","parent","numargs","visible","api"],"mappings":"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","sourcesContent":["/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n/* global module */\r\n\r\nif((typeof module) !== 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Calculus.js');\r\n    require('./Algebra.js');\r\n}\r\n\r\n(function () {\r\n    //handle imports\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            _A = core.Algebra,\r\n            _C = core.Calculus,\r\n            explode = _C.integration.decompose_arg,\r\n            evaluate = core.Utils.evaluate,\r\n            remove = core.Utils.remove,\r\n            format = core.Utils.format,\r\n            build = core.Utils.build,\r\n            knownVariable = core.Utils.knownVariable,\r\n            Symbol = core.Symbol,\r\n            isSymbol = core.Utils.isSymbol,\r\n            variables = core.Utils.variables,\r\n            S = core.groups.S,\r\n            PL = core.groups.PL,\r\n            CB = core.groups.CB,\r\n            CP = core.groups.CP,\r\n            FN = core.groups.FN,\r\n            Settings = core.Settings,\r\n            range = core.Utils.range,\r\n            isArray = core.Utils.isArray;\r\n\r\n\r\n    // The search radius for the roots\r\n    core.Settings.SOLVE_RADIUS = 1000;\r\n    // The maximum number to fish for on each side of the zero\r\n    core.Settings.ROOTS_PER_SIDE = 10;\r\n    // Covert the number to multiples of pi if possible\r\n    core.Settings.make_pi_conversions = false;\r\n    // The step size\r\n    core.Settings.STEP_SIZE = 0.1;\r\n    // The epsilon size\r\n    core.Settings.EPSILON = 1e-13;\r\n    //the maximum iterations for Newton's method\r\n    core.Settings.MAX_NEWTON_ITERATIONS = 200;\r\n    //the maximum number of time non-linear solve tries another jump point\r\n    core.Settings.MAX_NON_LINEAR_TRIES = 12;\r\n    //the amount of iterations the function will start to jump at\r\n    core.Settings.NON_LINEAR_JUMP_AT = 50;\r\n    //the size of the jump\r\n    core.Settings.NON_LINEAR_JUMP_SIZE = 100;\r\n    //the original starting point for nonlinear solving\r\n    core.Settings.NON_LINEAR_START = 0.01;\r\n    //When points are generated as starting points for Newton's method, they are sliced into small\r\n    //slices to make sure that we have convergence on the right point. This defines the \r\n    //size of the slice\r\n    core.Settings.NEWTON_SLICES = 200;\r\n    //The epsilon used in Newton's iteration\r\n    core.Settings.NEWTON_EPSILON = Number.EPSILON * 2;\r\n    //The distance in which two solutions are deemed the same\r\n    core.Settings.SOLUTION_PROXIMITY = 1e-14;\r\n    //Indicate wheter to filter the solutions are not\r\n    core.Settings.FILTER_SOLUTIONS = true;\r\n    //the maximum number of recursive calls\r\n    core.Settings.MAX_SOLVE_DEPTH = 10;\r\n    // The tolerance that's considered close enough to zero\r\n    core.Settings.ZERO_EPSILON = 1e-9;\r\n    // The maximum iteration for the bisection method incase of some JS strangeness\r\n    core.Settings.MAX_BISECTION_ITER = 2000;\r\n    // The tolerance for the bisection method\r\n    core.Settings.BI_SECTION_EPSILON = 1e-12;\r\n\r\n\r\n    core.Symbol.prototype.hasTrig = function () {\r\n        return this.containsFunction(['cos', 'sin', 'tan', 'cot', 'csc', 'sec']);\r\n    };\r\n\r\n    core.Symbol.prototype.hasNegativeTerms = function () {\r\n        if(this.isComposite()) {\r\n            for(var x in this.symbols) {\r\n                var sym = this.symbols[x];\r\n                if(sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0))\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /* nerdamer version 0.7.x and up allows us to make better use of operator overloading\r\n     * As such we can have this data type be supported completely outside of the core.\r\n     * This is an equation that has a left hand side and a right hand side\r\n     */\r\n    function Equation(lhs, rhs) {\r\n        if(rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) || rhs.equals(core.Settings.IMAGINARY))\r\n            throw new core.exceptions.NerdamerValueError(lhs.toString() + ' does not equal ' + rhs.toString());\r\n        this.LHS = lhs; //left hand side\r\n        this.RHS = rhs; //right and side\r\n    }\r\n    ;\r\n\r\n    //UTILS ##!!\r\n\r\n    Equation.prototype = {\r\n        toString: function () {\r\n            return this.LHS.toString() + '=' + this.RHS.toString();\r\n        },\r\n        text: function (option) {\r\n            return this.LHS.text(option) + '=' + this.RHS.text(option);\r\n        },\r\n        toLHS: function (expand) {\r\n            expand = typeof expand === 'undefined' ? true : false;\r\n            var eqn;\r\n            if(!expand) {\r\n                eqn = this.clone();\r\n            }\r\n            else {\r\n                eqn = this.removeDenom();\r\n            }\r\n            var a = eqn.LHS;\r\n            var b = eqn.RHS;\r\n            if(a.isConstant(true) && !b.isConstant(true)) {\r\n                // Swap them to avoid confusing parser and cause an infinite loop\r\n                [a, b] = [b, a];\r\n            }\r\n            var _t = _.subtract(a, b);\r\n            var retval = expand ? _.expand(_t) : _t;\r\n            return retval;\r\n        },\r\n        removeDenom: function () {\r\n            var a = this.LHS.clone();\r\n            var b = this.RHS.clone();\r\n            //remove the denominator on both sides\r\n            var den = _.multiply(a.getDenom(), b.getDenom());\r\n            a = _.expand(_.multiply(a, den.clone()));\r\n            b = _.expand(_.multiply(b, den));\r\n            //swap the groups\r\n            if(b.group === CP && b.group !== CP) {\r\n                var t = a;\r\n                a = b;\r\n                b = t; //swap\r\n            }\r\n\r\n            //scan to eliminate denominators\r\n            if(a.group === CB) {\r\n                var t = new Symbol(a.multiplier),\r\n                        newRHS = b.clone();\r\n                a.each(function (y) {\r\n                    if(y.power.lessThan(0))\r\n                        newRHS = _.divide(newRHS, y);\r\n                    else\r\n                        t = _.multiply(t, y);\r\n                });\r\n                a = t;\r\n                b = newRHS;\r\n\r\n            }\r\n            else if(a.group === CP) {\r\n                //the logic: loop through each and if it has a denominator then multiply it out on both ends\r\n                //and then start over\r\n                for(var x in a.symbols) {\r\n                    var sym = a.symbols[x];\r\n                    if(sym.group === CB) {\r\n                        for(var y in sym.symbols) {\r\n                            var sym2 = sym.symbols[y];\r\n                            if(sym2.power.lessThan(0)) {\r\n                                return new Equation(\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), a)),\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), b))\r\n                                        );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return new Equation(a, b);\r\n        },\r\n        clone: function () {\r\n            return new Equation(this.LHS.clone(), this.RHS.clone());\r\n        },\r\n        sub: function (x, y) {\r\n            var clone = this.clone();\r\n            clone.LHS = clone.LHS.sub(x.clone(), y.clone());\r\n            clone.RHS = clone.RHS.sub(x.clone(), y.clone());\r\n            return clone;\r\n        },\r\n        isZero: function () {\r\n            return core.Utils.evaluate(this.toLHS()).equals(0);\r\n        },\r\n        latex: function (option) {\r\n            return [this.LHS.latex(option), this.RHS.latex(option)].join('=');\r\n        }\r\n    };\r\n    //overwrite the equals function\r\n    _.equals = function (a, b) {\r\n        return new Equation(a, b);\r\n    };\r\n\r\n    // Extend simplify\r\n    (function () {\r\n        var simplify = _.functions.simplify[0];\r\n        _.functions.simplify[0] = function (symbol) {\r\n            if(symbol instanceof Equation) {\r\n                symbol.LHS = simplify(symbol.LHS);\r\n                symbol.RHS = simplify(symbol.RHS);\r\n                return symbol;\r\n            }\r\n            // Just call the original simplify\r\n            return simplify(symbol);\r\n        };\r\n    })();\r\n\r\n    /**\r\n     * Sets two expressions equal\r\n     * @param {Symbol} symbol\r\n     * @returns {Expression}\r\n     */\r\n    core.Expression.prototype.equals = function (symbol) {\r\n        if(symbol instanceof core.Expression)\r\n            symbol = symbol.symbol; //grab the symbol if it's an expression\r\n        var eq = new Equation(this.symbol, symbol);\r\n        return eq;\r\n    };\r\n\r\n    core.Expression.prototype.solveFor = function (x) {\r\n        var symbol;\r\n        if(this.symbol instanceof Equation) {\r\n            //exit right away if we already have the answer\r\n            //check the LHS\r\n            if(this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x))\r\n                return new core.Expression(this.symbol.LHS);\r\n\r\n            //check the RHS\r\n            if(this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x))\r\n                return new core.Expression(this.symbol.RHS);\r\n\r\n            //otherwise just bring it to LHS\r\n            symbol = this.symbol.toLHS();\r\n        }\r\n        else {\r\n            symbol = this.symbol;\r\n        }\r\n\r\n        return solve(symbol, x).map(function (x) {\r\n            return new core.Expression(x);\r\n        });\r\n    };\r\n\r\n    core.Expression.prototype.expand = function () {\r\n        if(this.symbol instanceof Equation) {\r\n            var clone = this.symbol.clone();\r\n            clone.RHS = _.expand(clone.RHS);\r\n            clone.LHS = _.expand(clone.LHS);\r\n            return new core.Expression(clone);\r\n        }\r\n        return new core.Expression(_.expand(this.symbol));\r\n    };\r\n\r\n    core.Expression.prototype.variables = function () {\r\n        if(this.symbol instanceof Equation)\r\n            return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));\r\n        return variables(this.symbol);\r\n    };\r\n\r\n\r\n\r\n    var setEq = function (a, b) {\r\n        return _.equals(a, b);\r\n    };\r\n\r\n    //link the Equation class back to the core\r\n    core.Equation = Equation;\r\n\r\n    //Loops through an array and attempts to fails a test. Stops if manages to fail.\r\n    var checkAll = core.Utils.checkAll = function (args, test) {\r\n        for(var i = 0; i < args.length; i++)\r\n            if(test(args[i]))\r\n                return false;\r\n        return true;\r\n    };\r\n\r\n    //version solve\r\n    var __ = core.Solve = {\r\n        version: '2.0.3',\r\n        solutions: [],\r\n        solve: function (eq, variable) {\r\n            var solution = solve(eq, String(variable));\r\n            return new core.Vector(solution);\r\n            //return new core.Vector(solve(eq.toString(), variable ? variable.toString() : variable));\r\n        },\r\n        /**\r\n         * Brings the equation to LHS. A string can be supplied which will be converted to an Equation\r\n         * @param {Equation|String} eqn\r\n         * @returns {Symbol}\r\n         */\r\n        toLHS: function (eqn, expand) {\r\n            if(isSymbol(eqn))\r\n                return eqn;\r\n            //If it's an equation then call its toLHS function instead\r\n            if(!(eqn instanceof Equation)) {\r\n                var es = eqn.split('=');\r\n                //convert falsey values to zero\r\n                es[1] = es[1] || '0';\r\n                eqn = new Equation(_.parse(es[0]), _.parse(es[1]));\r\n            }\r\n            return eqn.toLHS(expand);\r\n        },\r\n//        getSystemVariables: function(eqns) {\r\n//            vars = variables(eqns[0], null, null, true);\r\n//\r\n//            //get all variables\r\n//            for (var i = 1, l=eqns.length; i < l; i++)\r\n//                vars = vars.concat(variables(eqns[i]));\r\n//            //remove duplicates\r\n//            vars = core.Utils.arrayUnique(vars).sort();\r\n//            \r\n//            //done\r\n//            return vars;\r\n//        },\r\n        /**\r\n         * Solve a set of circle equations. \r\n         * @param {Symbol[]} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveCircle: function (eqns, vars) {\r\n            // Convert the variables to symbols\r\n            var svars = vars.map(function (x) {\r\n                return _.parse(x)\r\n            });\r\n\r\n            var deg = [];\r\n\r\n            var solutions = [];\r\n\r\n            // Get the degree for the equations\r\n            for(var i = 0; i < eqns.length; i++) {\r\n                var d = [];\r\n                for(var j = 0; j < svars.length; j++) {\r\n                    d.push(Number(core.Algebra.degree(eqns[i], svars[j])));\r\n                }\r\n                // Store the total degree\r\n                d.push(core.Utils.arraySum(d, true));\r\n                deg.push(d);\r\n            }\r\n\r\n            var a = eqns[0];\r\n            var b = eqns[1];\r\n\r\n            if(deg[0][2] > deg[1][2]) {\r\n                [b, a] = [a, b];\r\n                [deg[1], deg[0]] = [deg[0], deg[1]];\r\n            }\r\n\r\n            // Only solve it's truly a circle\r\n            if(deg[0][0] === 1 && deg[0][2] === 2 && deg[1][0] === 2 && deg[1][2] === 4) {\r\n                // For clarity we'll refer to the variables as x and y\r\n                var x = vars[0];\r\n                var y = vars[1];\r\n\r\n                // We can now get the two points for y\r\n                var y_points = solve(_.parse(b, knownVariable(x, solve(_.parse(a), x)[0])), y).map(function (x) {\r\n                    return x.toString();\r\n                });\r\n\r\n                // Since we now know y we can get the two x points from the first equation\r\n                var x_points = [\r\n                    solve(_.parse(a, knownVariable(y, y_points[0])))[0].toString()\r\n                ];\r\n\r\n                if(y_points[1]) {\r\n                    x_points.push(solve(_.parse(a, knownVariable(y, y_points[1])))[0].toString());\r\n                }\r\n\r\n                if(Settings.SOLUTIONS_AS_OBJECT) {\r\n                    var solutions = {};\r\n                    solutions[x] = x_points;\r\n                    solutions[y] = y_points;\r\n                }\r\n                else {\r\n                    y_points.unshift(y);\r\n                    x_points.unshift(x);\r\n                    solutions = [x_points, y_points];\r\n                }\r\n            }\r\n\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solve a system of nonlinear equations\r\n         * @param {Symbol[]} eqns The array of equations\r\n         * @param {number} tries The maximum number of tries\r\n         * @param {number} start The starting point where to start looking for solutions\r\n         * @returns {Array}\r\n         */\r\n        solveNonLinearSystem: function (eqns, tries, start) {\r\n            if(tries < 0) {\r\n                return [];//can't find a solution\r\n            }\r\n\r\n            start = typeof start === 'undefined' ? core.Settings.NON_LINEAR_START : start;\r\n\r\n            //the maximum number of times to jump\r\n            var max_tries = core.Settings.MAX_NON_LINEAR_TRIES;\r\n\r\n            //halfway through the tries\r\n            var halfway = Math.floor(max_tries / 2);\r\n\r\n            //initialize the number of tries to 10 if not specified\r\n            tries = typeof tries === 'undefined' ? max_tries : tries;\r\n\r\n            //a point at which we check to see if we're converging. By inspection it seems that we can\r\n            //use around 20 iterations to see if we're converging. If not then we retry a jump of x\r\n            var jump_at = core.Settings.NON_LINEAR_JUMP_AT;\r\n\r\n            //we jump by this many points at each pivot point\r\n            var jump = core.Settings.NON_LINEAR_JUMP_SIZE;\r\n\r\n            //used to check if we actually found a solution or if we gave up. Assume we will find a solution.\r\n            var found = true;\r\n\r\n            var create_subs = function (vars, matrix) {\r\n                return vars.map(function (x, i) {\r\n                    return Number(matrix.get(i, 0));\r\n                });\r\n            };\r\n\r\n            var vars = core.Utils.arrayGetVariables(eqns);\r\n            var jacobian = core.Matrix.jacobian(eqns, vars, function (x) {\r\n                return build(x, vars);\r\n            }, true);\r\n\r\n            var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;\r\n            var o, y, iters, xn1, norm, lnorm, xn, d;\r\n\r\n            var f_eqns = eqns.map(function (eq) {\r\n                return build(eq, vars);\r\n            });\r\n\r\n            var J = jacobian.map(function (e) {\r\n                return build(e, vars);\r\n            }, true);\r\n            //initial values\r\n            xn1 = core.Matrix.cMatrix(0, vars);\r\n\r\n            //initialize the c matrix with something close to 0. \r\n            var c = core.Matrix.cMatrix(start, vars);\r\n\r\n            iters = 0;\r\n\r\n            //start of algorithm\r\n            do {\r\n                //if we've reached the max iterations then exit\r\n                if(iters > max_iter) {\r\n                    break;\r\n                    found = false;\r\n                }\r\n\r\n                //set the substitution object\r\n                o = create_subs(vars, c);\r\n\r\n                //set xn\r\n                xn = c.clone();\r\n\r\n                //make all the substitutions for each of the equations\r\n                f_eqns.forEach(function (f, i) {\r\n                    c.set(i, 0, f.apply(null, o));\r\n                });\r\n\r\n                var m = new core.Matrix();\r\n                J.each(function (fn, i, j) {\r\n                    var ans = fn.apply(null, o);\r\n                    m.set(i, j, ans);\r\n                });\r\n\r\n                m = m.invert();\r\n\r\n                //preform the elimination\r\n                y = _.multiply(m, c).negate();\r\n\r\n                //the callback is to avoid overflow in the coeffient denonimator\r\n                //it converts it to a decimal and then back to a fraction. Some precision\r\n                //is lost be it's better than overflow. \r\n                d = y.subtract(xn1, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                xn1 = xn.add(y, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                //move c is now xn1\r\n                c = xn1;\r\n\r\n                //get the norm\r\n\r\n                //the expectation is that we're converging to some answer as this point regardless of where we start\r\n                //this may have to be adjusted at some point because of erroneous assumptions\r\n                if(iters >= jump_at) {\r\n                    //check the norm. If the norm is greater than one then it's time to try another point\r\n                    if(norm > 1) {\r\n                        //reset the start point at halway\r\n                        if(tries === halfway)\r\n                            start = 0;\r\n                        var sign = tries > halfway ? 1 : -1; //which side are we incrementing\r\n                        //we increment +n at one side and -n at the other. \r\n                        n = (tries % Math.floor(halfway)) + 1;\r\n                        //adjust the start point\r\n                        start += (sign * n * jump);\r\n                        //call restart\r\n                        return __.solveNonLinearSystem(eqns, --tries, start);\r\n                    }\r\n                }\r\n                lnorm = norm;\r\n                iters++;\r\n                norm = d.max();\r\n\r\n                //exit early. Revisit if we get bugs\r\n                if(Number(norm) === Number(lnorm)) {\r\n                    break;\r\n                }\r\n            }\r\n            while(Number(norm) >= Number.EPSILON)\r\n\r\n            //return a blank set if nothing was found;\r\n            if(!found)\r\n                return [];\r\n\r\n            //return c since that's the answer\r\n            return __.systemSolutions(c, vars, true, function (x) {\r\n                return core.Utils.round(Number(x), 14);\r\n            });\r\n        },\r\n        systemSolutions: function (result, vars, expand_result, callback) {\r\n            var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];\r\n\r\n            result.each(function (e, idx) {\r\n                var solution = (expand_result ? _.expand(e) : e).valueOf();\r\n                if(callback)\r\n                    solution = callback.call(e, solution);\r\n                var variable = vars[idx];\r\n                if(core.Settings.SOLUTIONS_AS_OBJECT) {\r\n                    solutions[variable] = solution;\r\n                }\r\n                else\r\n                    solutions.push([variable, solution]); /*NO*/\r\n            });\r\n            //done\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solves a system of equations by substitution. This is useful when\r\n         * no distinct solution exists. e.g. a line, plane, etc.\r\n         * @param {Array} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveSystemBySubstitution: function (eqns) {\r\n            // Assume at least 2 equations. The function variables will just return an empty array if undefined is provided\r\n            var vars_a = variables(eqns[0]);\r\n            var vars_b = variables(eqns[1]);\r\n            // Check if it's a circle equation\r\n            if(eqns.length === 2 && vars_a.length === 2 && core.Utils.arrayEqual(vars_a, vars_b)) {\r\n                return __.solveCircle(eqns, vars_a);\r\n            }\r\n\r\n            return []; // return an empty set\r\n        },\r\n\r\n        //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf\r\n        /**\r\n         * Solves a systems of equations\r\n         * @param {Array} eqns An array of equations\r\n         * @param {Array} var_array An array of variables\r\n         * @returns {Array|object}\r\n         */\r\n        solveSystem: function (eqns, var_array) {\r\n            //check if a var_array was specified\r\n            //nerdamer.clearVars();// this deleted ALL variables: not what we want\r\n            //parse all the equations to LHS. Remember that they come in as strings\r\n            for(var i = 0; i < eqns.length; i++)\r\n                eqns[i] = __.toLHS(eqns[i]);\r\n\r\n            var l = eqns.length,\r\n                    m = new core.Matrix(),\r\n                    c = new core.Matrix(),\r\n                    expand_result = false,\r\n                    vars;\r\n\r\n            if(typeof var_array === 'undefined') {\r\n                //check to make sure that all the equations are linear\r\n                if(!_A.allLinear(eqns)) {\r\n                    try {\r\n                        return __.solveNonLinearSystem(eqns);\r\n                    }\r\n                    catch(e) {\r\n                        if(e instanceof core.exceptions.DivisionByZero) {\r\n                            return __.solveSystemBySubstitution(eqns);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                vars = core.Utils.arrayGetVariables(eqns);\r\n\r\n                // Deal with redundant equations as expressed in #562\r\n                // The fix is to remove all but the number of equations equal to the number\r\n                // of variables. We then solve those and then evaluate the remaining equations\r\n                // with those solutions. If the all equal true then those are just redundant\r\n                // equations and we can return the solution set.\r\n                if(vars.length < eqns.length) {\r\n                    var reduced = [];\r\n                    var n = eqns.length;\r\n                    for(var i = 0; i < n - 1; i++) {\r\n                        reduced.push(_.parse(eqns[i]));\r\n                    }\r\n\r\n                    var knowns = {};\r\n                    var solutions = __.solveSystem(reduced, vars);\r\n                    // The solutions may have come back as an array\r\n                    if(Array.isArray(solutions)) {\r\n                        solutions.forEach(function (sol) {\r\n                            knowns[sol[0]] = sol[1];\r\n                        });\r\n                    }\r\n                    else {\r\n                        knowns = solutions;\r\n                    }\r\n\r\n                    // Start by assuming they will all evaluate to zero. If even one fails\r\n                    // then all zero will be false\r\n                    var all_zero = true;\r\n                    // Check if the last solution evalutes to zero given these solutions\r\n                    for(var i = n - 1; i < n; i++) {\r\n                        if(!_.parse(eqns[i], knowns).equals(0)) {\r\n                            all_zero = false;\r\n                        }\r\n                    }\r\n\r\n                    if(all_zero) {\r\n                        return solutions;\r\n                    }\r\n                }\r\n\r\n                // deletes only the variables of the linear equations in the nerdamer namespace\r\n                for(var i = 0; i < vars.length; i++) {\r\n                    nerdamer.setVar(vars[i], \"delete\");\r\n                }\r\n                // TODO: move this to cMatrix or something similar\r\n                // populate the matrix\r\n                for(var i = 0; i < l; i++) {\r\n                    var e = eqns[i]; //store the expression\r\n                    // Iterate over the columns\r\n                    for(var j = 0; j < vars.length; j++) {\r\n                        var v = vars[j];\r\n                        var coeffs = [];\r\n                        e.each(function (x) {\r\n                            if(x.contains(v)) {\r\n                                coeffs = coeffs.concat(x.coeffs());\r\n                            }\r\n                        });\r\n\r\n                        var cf = core.Utils.arraySum(coeffs);\r\n                        m.set(i, j, cf);\r\n                    }\r\n\r\n                    //strip the variables from the symbol so we're left with only the zeroth coefficient\r\n                    //start with the symbol and remove each variable and its coefficient\r\n                    var num = e.clone();\r\n                    vars.map(function (e) {\r\n                        num = num.stripVar(e, true);\r\n                    });\r\n                    c.set(i, 0, num.negate());\r\n                }\r\n            }\r\n            else {\r\n                /**\r\n                 * The idea is that we loop through each equation and then expand it. Afterwards we loop\r\n                 * through each term and see if and check to see if it matches one of the variables.\r\n                 * When a match is found we mark it. No other match should be found for that term. If it\r\n                 * is we stop since it's not linear.\r\n                 */\r\n                vars = var_array;\r\n                expand_result = true;\r\n                for(i = 0; i < l; i++) {\r\n                    //prefill\r\n                    c.set(i, 0, new Symbol(0));\r\n                    var e = _.expand(eqns[i]).collectSymbols(); //expand and store\r\n                    //go trough each of the variables\r\n                    for(var j = 0; j < var_array.length; j++) {\r\n                        m.set(i, j, new Symbol(0));\r\n                        var v = var_array[j];\r\n                        //go through the terms and sort the variables\r\n                        for(var k = 0; k < e.length; k++) {\r\n                            var term = e[k],\r\n                                    check = false;\r\n                            for(var z = 0; z < var_array.length; z++) {\r\n                                //check to see if terms contain multiple variables\r\n                                if(term.contains(var_array[z])) {\r\n                                    if(check)\r\n                                        core.err('Multiple variables found for term ' + term);\r\n                                    check = true;\r\n                                }\r\n                            }\r\n                            //we made sure that every term contains one variable so it's safe to assume that if the\r\n                            //variable is found then the remainder is the coefficient.\r\n                            if(term.contains(v)) {\r\n                                var tparts = explode(remove(e, k), v);\r\n                                m.set(i, j, _.add(m.get(i, j), tparts[0]));\r\n                            }\r\n                        }\r\n                    }\r\n                    //all the remaining terms go to the c matrix\r\n                    for(k = 0; k < e.length; k++) {\r\n                        c.set(i, 0, _.add(c.get(i, 0), e[k]));\r\n                    }\r\n                }\r\n                //consider case (a+b)*I+u\r\n            }\r\n\r\n            //check if the system has a distinct solution\r\n            if(vars.length !== eqns.length || m.determinant().equals(0)) {\r\n                // solve the system by hand\r\n                //return __.solveSystemBySubstitution(eqns, vars, m, c);\r\n                throw new core.exceptions.SolveError('System does not have a distinct solution');\r\n            }\r\n\r\n            // Use M^-1*c to solve system\r\n            m = m.invert();\r\n            var result = m.multiply(c);\r\n            //correct the sign as per issue #410\r\n            if(core.Utils.isArray(var_array))\r\n                result.each(function (x) {\r\n                    return x.negate();\r\n                });\r\n\r\n            return __.systemSolutions(result, vars, expand_result);\r\n        },\r\n        /**\r\n         * The quadratic function but only one side.\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Symbol}\r\n         */\r\n        quad: function (c, b, a) {\r\n            var discriminant = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)))/*b^2 - 4ac*/;\r\n            var det = _.pow(discriminant, Symbol(0.5));\r\n            var den = _.parse(_.multiply(new Symbol(2), a.clone()));\r\n            var retval = [\r\n                _.parse(format('(-({0})+({1}))/({2})', b, det, den)),\r\n                _.parse(format('(-({0})-({1}))/({2})', b, det, den))\r\n            ];\r\n\r\n            return retval;\r\n        },\r\n        /**\r\n         * The cubic equation\r\n         * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations\r\n         * @param {Symbol} d_o\r\n         * @param {Symbol} c_o\r\n         * @param {Symbol} b_o\r\n         * @param {Symbol} a_o\r\n         * @returns {Array}\r\n         */\r\n        cubic: function (d_o, c_o, b_o, a_o) {\r\n            //convert everything to text\r\n            var a = a_o.text(), b = b_o.text(), c = c_o.text(), d = d_o.text();\r\n\r\n            var t = `(-(${b})^3/(27*(${a})^3)+(${b})*(${c})/(6*(${a})^2)-(${d})/(2*(${a})))`;\r\n            var u = `((${c})/(3*(${a}))-(${b})^2/(9*(${a})^2))`;\r\n            var v = `(${b})/(3*(${a}))`;\r\n            var x = `((${t})+sqrt((${t})^2+(${u})^3))^(1/3)+((${t})-sqrt((${t})^2+(${u})^3))^(1/3)-(${v})`;\r\n\r\n            // Convert a to one\r\n            var w = '1/2+sqrt(3)/2*i'; // Cube root of unity\r\n\r\n            return [\r\n                _.parse(x),\r\n                _.parse(`(${x})(${w})`),\r\n                _.parse(`(${x})(${w})^2`)\r\n            ];\r\n        },\r\n        /**\r\n         * The quartic equation\r\n         * @param {Symbol} e\r\n         * @param {Symbol} d\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Array}\r\n         */\r\n        quartic: function (e, d, c, b, a) {\r\n            var scope = {};\r\n            core.Utils.arrayUnique(variables(a).concat(variables(b))\r\n                    .concat(variables(c)).concat(variables(d)).concat(variables(e)))\r\n                    .map(function (x) {\r\n                        scope[x] = 1;\r\n                    });\r\n            a = a.toString();\r\n            b = b.toString();\r\n            c = c.toString();\r\n            d = d.toString();\r\n            e = e.toString();\r\n            var p, q, D, D0, D1, Q, x1, x2, x3, x4;\r\n            /*var D = core.Utils.block('PARSE2NUMBER', function() {\r\n             return _.parse(format(\"256*({0})^3*({4})^3-192*({0})^2*({1})*({3})*({4})^2-128*({0})^2*({2})^2*({4})^2+144*({0})^2*({2})*({3})^2*({4})\"+\r\n             \"-27*({0})^2*({3})^4+144*({0})*({1})^2*({2})*({4})^2-6*({0})*({1})^2*({3})^2*({4})-80*({0})*({1})*({2})^2*({3})*({4})+18*({0})*({1})*({2})*({3})^3\"+\r\n             \"+16*({0})*({2})^4*({4})-4*({0})*({2})^3*({3})^2-27*({1})^4*({4})^2+18*({1})^3*({2})*({3})*({4})-4*({1})^3*({3})^3-4*({1})^2*({2})^3*({4})+({1})^2*({2})^2*({3})^2\", \r\n             a, b, c, d, e), scope);\r\n             });*/\r\n\r\n            p = _.parse(format(\"(8*({0})*({2})-3*({1})^2)/(8*({0})^2)\", a, b, c)).toString(); //a, b, c\r\n            q = _.parse(format(\"(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)\", a, b, c, d)).toString();//a, b, c, d, e\r\n            D0 = _.parse(format(\"12*({0})*({4})-3*({1})*({3})+({2})^2\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            D1 = _.parse(format(\"2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            Q = _.parse(format(\"((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)\", D0, D1)).toString(); //D0, D1\r\n            S = _.parse(format(\"(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)\", a, p, Q, D0)).toString(); //a, p, Q, D0\r\n            x1 = _.parse(format(\"-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x2 = _.parse(format(\"-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x3 = _.parse(format(\"-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x4 = _.parse(format(\"-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            return [x1, x2, x3, x4];\r\n        },\r\n        /**\r\n         * Breaks the equation up in its factors and tries to solve the smaller parts\r\n         * @param {Symbol} symbol\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        divideAndConquer: function (symbol, solve_for) {\r\n            var sols = [];\r\n            //see if we can solve the factors\r\n            var factors = core.Algebra.Factor.factor(symbol);\r\n            if(factors.group === CB) {\r\n                factors.each(function (x) {\r\n                    x = Symbol.unwrapPARENS(x);\r\n                    sols = sols.concat(solve(x, solve_for));\r\n                });\r\n            }\r\n            return sols;\r\n        },\r\n        /**\r\n         * Attempts to solve the equation assuming it's a polynomial with numeric coefficients\r\n         * @param {Symbol} eq\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        csolve: function (eq, solve_for) {\r\n            return core.Utils.block('IGNORE_E', function () {\r\n                var f, p, pn, n, pf, r, theta, sr, sp, roots;\r\n                roots = [];\r\n                f = core.Utils.decompose_fn(eq, solve_for, true);\r\n                if(f.x.group === S) {\r\n                    p = _.parse(f.x.power);\r\n                    pn = Number(p);\r\n                    n = _.pow(_.divide(f.b.negate(), f.a), p.invert());\r\n                    pf = Symbol.toPolarFormArray(n);\r\n                    r = pf[0];\r\n                    theta = pf[1];\r\n                    sr = r.toString();\r\n                    sp = p.toString();\r\n                    var k, root, str;\r\n                    for(var i = 0; i < pn; i++) {\r\n                        k = i;\r\n                        str = format('({0})*e^(2*{1}*pi*{2}*{3})', sr, k, p, core.Settings.IMAGINARY);\r\n                        root = _.parse(str);\r\n                        roots.push(root);\r\n                    }\r\n                }\r\n                return roots;\r\n            }, true);\r\n        },\r\n        /**\r\n         * Generates starting points for the Newton solver given an expression at zero.\r\n         * It beings by check if zero is a good point and starts expanding by a provided step size. \r\n         * Builds on the fact that if the sign changes over an interval then a zero\r\n         * must exist on that interval\r\n         * @param {Symbol} symbol\r\n         * @param {Number} step\r\n         * @param {Array} points\r\n         * @returns {Array}\r\n         */\r\n        getPoints: function (symbol, step, points) {\r\n            step = step || 0.01;\r\n            points = points || [];\r\n            var f = build(symbol);\r\n            var x0 = 0;\r\n\r\n            var start = Math.round(x0),\r\n                    last = f(start),\r\n                    last_sign = last / Math.abs(last),\r\n                    rside = core.Settings.ROOTS_PER_SIDE, // the max number of roots on right side\r\n                    lside = rside; // the max number of roots on left side\r\n            // check around the starting point\r\n            points.push(Math.floor(start / 2)); //half way from zero might be a good start\r\n            points.push(Math.abs(start)); //|f(0)| could be a good start\r\n            points.push(start);//|f(0)| could be a good start\r\n            //adjust for log. A good starting point to include for log is 0.1\r\n            symbol.each(function (x) {\r\n                if(x.containsFunction(core.Settings.LOG))\r\n                    points.push(0.1);\r\n            });\r\n\r\n            var left = range(-core.Settings.SOLVE_RADIUS, start, step),\r\n                    right = range(start, core.Settings.SOLVE_RADIUS, step);\r\n\r\n            var test_side = function (side, num_roots) {\r\n                var xi, val, sign;\r\n                var hits = [];\r\n                for(var i = 0, l = side.length; i < l; i++) {\r\n                    xi = side[i]; //the point being evaluated\r\n                    val = f(xi);\r\n                    sign = val / Math.abs(val);\r\n                    //Don't add non-numeric values\r\n                    if(isNaN(val) || !isFinite(val) || hits.length > num_roots) {\r\n                        continue;\r\n                    }\r\n\r\n                    //compare the signs. The have to be different if they cross a zero\r\n                    if(sign !== last_sign) {\r\n                        hits.push(xi); //take note of the possible zero location\r\n                    }\r\n                    last_sign = sign;\r\n                }\r\n\r\n                points = points.concat(hits);\r\n            };\r\n\r\n            test_side(left, lside);\r\n            test_side(right, rside);\r\n\r\n            return points;\r\n        },\r\n        /**\r\n         * Implements the bisection method. Returns undefined in no solution is found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @returns {undefined | number}\r\n         */\r\n        bisection: function (point, f) {\r\n            var left = point - 1;\r\n            var right = point + 1;\r\n            // First test if this point is even worth evaluating. It should\r\n            // be crossing the x axis so the signs should be different\r\n            if(Math.sign(f(left)) !== Math.sign(f(right))) {\r\n                var safety = 0;\r\n\r\n                var epsilon, middle;\r\n\r\n                do {\r\n                    epsilon = Math.abs(right - left);\r\n                    // Safety against an infinite loop\r\n                    if(safety++ > core.Settings.MAX_BISECTION_ITER || isNaN(epsilon)) {\r\n                        return;\r\n                    }\r\n                    // Calculate the middle point\r\n                    middle = (left + right) / 2;\r\n\r\n                    if(f(left) * f(middle) > 0) {\r\n                        left = middle;\r\n                    }\r\n                    else {\r\n                        right = middle;\r\n                    }\r\n                }\r\n                while(epsilon >= Settings.EPSILON);\r\n\r\n                var solution = (left + right) / 2;\r\n\r\n                // Test the solution to make sure that it's within tolerance\r\n                var x_point = f(solution);\r\n\r\n                if(!isNaN(x_point) && Math.abs(x_point) <= core.Settings.BI_SECTION_EPSILON) {\r\n                    // Returns too many junk solutions if not rounded at 13th place.\r\n                    return core.Utils.round(solution, 13);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Implements Newton's iterations. Returns undefined if no solutions if found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @param {function} fp\r\n         * @returns {undefined|number}\r\n         */\r\n        Newton: function (point, f, fp) {\r\n            var maxiter = core.Settings.MAX_NEWTON_ITERATIONS,\r\n                    iter = 0;\r\n            //first try the point itself. If it's zero viola. We're done\r\n            var x0 = point, x;\r\n            do {\r\n                var fx0 = f(x0); //store the result of the function\r\n                //if the value is zero then we're done because 0 - (0/d f(x0)) = 0\r\n                if(x0 === 0 && fx0 === 0) {\r\n                    x = 0;\r\n                    break;\r\n                }\r\n\r\n                iter++;\r\n                if(iter > maxiter)\r\n                    return; //naximum iterations reached\r\n\r\n                x = x0 - fx0 / fp(x0);\r\n                var e = Math.abs(x - x0);\r\n                x0 = x;\r\n            }\r\n            while(e > Settings.NEWTON_EPSILON)\r\n\r\n            //check if the number is indeed zero. 1e-13 seems to give the most accurate results\r\n            if(Math.abs(f(x)) <= Settings.EPSILON)\r\n                return x;\r\n        },\r\n        rewrite: function (rhs, lhs, for_variable) {\r\n            lhs = lhs || new Symbol(0);\r\n            if(rhs.isComposite() && rhs.isLinear()) {\r\n                //try to isolate the square root\r\n                //container for the square roots\r\n                var sqrts = [];\r\n                //all else\r\n                var rem = [];\r\n                rhs.each(function (x) {\r\n                    x = x.clone();\r\n                    if(x.fname === 'sqrt' && x.contains(for_variable)) {\r\n                        sqrts.push(x);\r\n                    }\r\n                    else {\r\n                        rem.push(x);\r\n                    }\r\n                }, true);\r\n\r\n                if(sqrts.length === 1) {\r\n                    //move the remainder to the RHS\r\n                    lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2)));\r\n                    //square both sides\r\n                    rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));\r\n                }\r\n            }\r\n            else {\r\n                rhs = Symbol.unwrapSQRT(_.expand(rhs)); //expand the term expression go get rid of quotients when possible\r\n            }\r\n\r\n            var c = 0, //a counter to see if we have all terms with the variable\r\n                    l = rhs.length;\r\n            //try to rewrite the whole thing\r\n            if(rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                rhs.distributeMultiplier();\r\n                var t = new Symbol(0);\r\n                //first bring all the terms containing the variable to the lhs\r\n                rhs.each(function (x) {\r\n                    if(x.contains(for_variable)) {\r\n                        c++;\r\n                        t = _.add(t, x.clone());\r\n                    }\r\n                    else\r\n                        lhs = _.subtract(lhs, x.clone());\r\n                });\r\n                rhs = t;\r\n\r\n                //if not all the terms contain the variable so it's in the form\r\n                //a*x^2+x\r\n                if(c !== l) {\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n                }\r\n                else {\r\n                    return [rhs, lhs];\r\n                }\r\n            }\r\n            else if(rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                if(rhs.multiplier.lessThan(0)) {\r\n                    rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));\r\n                    lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));\r\n                }\r\n                if(lhs.equals(0))\r\n                    return new Symbol(0);\r\n                else {\r\n                    var t = new Symbol(1);\r\n                    rhs.each(function (x) {\r\n                        if(x.contains(for_variable))\r\n                            t = _.multiply(t, x.clone());\r\n                        else\r\n                            lhs = _.divide(lhs, x.clone());\r\n                    });\r\n                    rhs = t;\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n\r\n                }\r\n            }\r\n            else if(!rhs.isLinear() && rhs.contains(for_variable)) {\r\n                var p = _.parse(rhs.power.clone().invert());\r\n                rhs = _.pow(rhs, p.clone());\r\n                lhs = _.pow(_.expand(lhs), p.clone());\r\n                return __.rewrite(rhs, lhs, for_variable);\r\n            }\r\n            else if(rhs.group === FN || rhs.group === S || rhs.group === PL) {\r\n                return [rhs, lhs];\r\n            }\r\n        },\r\n        sqrtSolve: function (symbol, v) {\r\n            var sqrts = new Symbol(0);\r\n            var rem = new Symbol(0);\r\n            if(symbol.isComposite()) {\r\n                symbol.each(function (x) {\r\n                    if(x.fname === 'sqrt' && x.contains(v)) {\r\n                        sqrts = _.add(sqrts, x.clone());\r\n                    }\r\n                    else {\r\n                        rem = _.add(rem, x.clone());\r\n                    }\r\n                });\r\n                //quick and dirty ATM\r\n                if(!sqrts.equals(0)) {\r\n                    var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2)))));\r\n                    //square both sides\r\n                    var solutions = solve(t, v);\r\n                    //test the points. The dumb way of getting the answers\r\n                    solutions = solutions.filter(function (e) {\r\n                        if(e.isImaginary())\r\n                            return e;\r\n                        var subs = {};\r\n                        subs[v] = e;\r\n                        var point = evaluate(symbol, subs);\r\n                        if(point.equals(0))\r\n                            return e;\r\n                    });\r\n                    return solutions;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     * \r\n     * @param {String[]|String|Equation} eqns\r\n     * @param {String} solve_for\r\n     * @param {Array} solutions\r\n     * @param {Number} depth\r\n     * @param {String|Equation} fn\r\n     * @returns {Array}\r\n     */\r\n    var solve = function (eqns, solve_for, solutions, depth, fn) {\r\n        depth = depth || 0;\r\n\r\n        if(depth++ > Settings.MAX_SOLVE_DEPTH) {\r\n            return solutions;\r\n        }\r\n\r\n        //make preparations if it's an Equation\r\n        if(eqns instanceof Equation) {\r\n            //if it's zero then we're done\r\n            if(eqns.isZero()) {\r\n                return [new Symbol(0)];\r\n            }\r\n            //if the lhs = x then we're done\r\n            if(eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {\r\n                return [eqns.RHS];\r\n            }\r\n            //if the rhs = x then we're done\r\n            if(eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {\r\n                return [eqns.LHS];\r\n            }\r\n        }\r\n\r\n        //unwrap the vector since what we want are the elements\r\n        if(eqns instanceof core.Vector)\r\n            eqns = eqns.elements;\r\n        solve_for = solve_for || 'x'; //assumes x by default\r\n        //If it's an array then solve it as a system of equations\r\n        if(isArray(eqns)) {\r\n            return __.solveSystem.apply(undefined, arguments);\r\n        }\r\n\r\n        // Parse out functions. Fix for issue #300\r\n        // eqns = core.Utils.evaluate(eqns);\r\n        solutions = solutions || [];\r\n        //mark existing solutions as not to have duplicates\r\n        var existing = {};\r\n\r\n        // Easy fail. If it's a rational function and the denominator is zero\r\n        // the we're done. Issue #555\r\n        var known = {};\r\n        known[solve_for] = 0;\r\n        if(isSymbol(eqns) && evaluate(eqns.getDenom(), known).equals(0) === true) {\r\n            return solutions;\r\n        }\r\n\r\n        // Is usued to add solutions to set. \r\n        // TODO: Set is now implemented and should be utilized\r\n        var add_to_result = function (r, has_trig) {\r\n            var r_is_symbol = isSymbol(r);\r\n            if(r === undefined || typeof r === 'number' && isNaN(r))\r\n                return;\r\n            if(isArray(r)) {\r\n                r.forEach(function (sol) {\r\n                    add_to_result(sol);\r\n                });\r\n            }\r\n            else {\r\n                if(r.valueOf() !== 'null') {\r\n                    // Call the pre-add function if defined. This could be useful for rounding\r\n                    if(typeof core.Settings.PRE_ADD_SOLUTION === 'function') {\r\n                        r = core.Settings.PRE_ADD_SOLUTION(r);\r\n                    }\r\n\r\n                    if(!r_is_symbol) {\r\n                        r = _.parse(r);\r\n                    }\r\n                    // try to convert the number to multiples of pi\r\n                    if(core.Settings.make_pi_conversions && has_trig) {\r\n                        var temp = _.divide(r.clone(), new Symbol(Math.PI)),\r\n                                m = temp.multiplier,\r\n                                a = Math.abs(m.num),\r\n                                b = Math.abs(m.den);\r\n                        if(a < 10 && b < 10)\r\n                            r = _.multiply(temp, new Symbol('pi'));\r\n                    }\r\n\r\n                    // And check if we get a number otherwise we might be throwing out symbolic solutions.\r\n                    var r_str = r.toString();\r\n\r\n                    if(!existing[r_str]) {\r\n                        solutions.push(r);\r\n                    }\r\n                    // Mark the answer as seen\r\n                    existing[r_str] = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        // Maybe we get lucky. Try the point at the function. If it works we have a point\r\n        // If not it failed\r\n        if(eqns.group === S && eqns.contains(solve_for)) {\r\n            try {\r\n                var o = {};\r\n                o[solve_for] = 0;\r\n                evaluate(fn, o, 'numer');\r\n                add_to_result(new Symbol(0));\r\n            }\r\n            catch(e) {\r\n                // Do nothing;\r\n            }\r\n\r\n            return solutions;\r\n        }\r\n        if(eqns.group === CB) {\r\n            // It suffices to solve for the numerator\r\n            var num = eqns.getNum();\r\n\r\n            if(num.group === CB) {\r\n                var sf = String(solve_for); //everything else belongs to the coeff\r\n                //get the denominator and make sure it doesn't have x since we don't know how to solve for those\r\n                num.each(function (x) {\r\n                    if(x.contains(sf))\r\n                        solve(x, solve_for, solutions, depth, eqns);\r\n                });\r\n\r\n                return solutions;\r\n            }\r\n\r\n            return solve(num, solve_for, solutions, depth, fn);\r\n        }\r\n\r\n        if(eqns.group === FN && eqns.fname === 'sqrt') {\r\n            eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));\r\n        }\r\n        //pass in false to not expand equations such as (x+y)^5.\r\n        //It suffices to solve for the numerator since there's no value in the denominator which yields a zero for the function\r\n        var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(),\r\n                vars = core.Utils.variables(eq), //get a list of all the variables\r\n                numvars = vars.length;//how many variables are we dealing with\r\n\r\n        //it sufficient to solve (x+y) if eq is (x+y)^n since 0^n\r\n        if(core.Utils.isInt(eq.power) && eq.power > 0) {\r\n            eq = _.parse(eq).toLinear();\r\n        }\r\n\r\n        //if we're dealing with a single variable then we first check if it's a \r\n        //polynomial (including rationals).If it is then we use the Jenkins-Traubb algorithm.     \r\n        //Don't waste time\r\n        if(eq.group === S || eq.group === CB && eq.contains(solve_for)) {\r\n            return [new Symbol(0)];\r\n        }\r\n        //force to polynomial. We go through each and then we look at what it would \r\n        //take for its power to be an integer\r\n        //if the power is a fractional we divide by the fractional power\r\n        var fractionals = {},\r\n                cfact;\r\n\r\n        var correct_denom = function (symbol) {\r\n            symbol = _.expand(symbol, {\r\n                expand_denominator: true,\r\n                expand_functions: true\r\n            });\r\n            var original = symbol.clone(); //preserve the original\r\n\r\n            if(symbol.symbols) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n\r\n                    //get the denominator of the sub-symbol\r\n                    var den = sym.getDenom();\r\n\r\n                    if(!den.isConstant(true) && symbol.isComposite()) {\r\n                        var t = new Symbol(0);\r\n                        symbol.each(function (e) {\r\n                            t = _.add(t, _.multiply(e, den.clone()));\r\n                        });\r\n\r\n                        return correct_denom(_.multiply(_.parse(symbol.multiplier), t));\r\n                    }\r\n\r\n                    var parts = explode(sym, solve_for);\r\n                    var is_sqrt = parts[1].fname === core.Settings.SQRT;\r\n                    var v = Symbol.unwrapSQRT(parts[1]);\r\n                    var p = v.power.clone();\r\n                    //circular logic with sqrt. Since sqrt(x) becomes x^(1/2) which then becomes sqrt(x), this continues forever\r\n                    //this needs to be terminated if p = 1/2\r\n                    if(!isSymbol(p) && !p.equals(1 / 2)) {\r\n                        if(p.den.gt(1)) {\r\n                            if(is_sqrt) {\r\n                                symbol = _.subtract(symbol, sym.clone());\r\n                                symbol = _.add(symbol, _.multiply(parts[0].clone(), v));\r\n                                return correct_denom(symbol);\r\n                            }\r\n                            var c = fractionals[p.den];\r\n                            fractionals[p.den] = c ? c++ : 1;\r\n                        }\r\n                        else if(p.sign() === -1) {\r\n                            var factor = _.parse(solve_for + '^' + Math.abs(p)); //this\r\n                            //unwrap the symbol's denoniator\r\n                            symbol.each(function (y, index) {\r\n                                if(y.contains(solve_for)) {\r\n                                    symbol.symbols[index] = _.multiply(y, factor.clone());\r\n                                }\r\n                            });\r\n                            fractionals = {};\r\n                            return correct_denom(_.parse(symbol));\r\n                        }\r\n                        else if(sym.group === PL) {\r\n                            var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));\r\n                            if(min_p < 0) {\r\n                                var factor = _.parse(solve_for + '^' + Math.abs(min_p));\r\n                                var corrected = new Symbol(0);\r\n                                original.each(function (x) {\r\n                                    corrected = _.add(corrected, _.multiply(x.clone(), factor.clone()));\r\n                                }, true);\r\n                                return corrected;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return symbol;\r\n        };\r\n\r\n        //separate the equation\r\n        var separate = function (eq) {\r\n            var lhs = new Symbol(0),\r\n                    rhs = new Symbol(0);\r\n            eq.each(function (x) {\r\n                if(x.contains(solve_for, true))\r\n                    lhs = _.add(lhs, x.clone());\r\n                else\r\n                    rhs = _.subtract(rhs, x.clone());\r\n            });\r\n            return [lhs, rhs];\r\n        };\r\n\r\n        __.inverseFunctionSolve = function (name, lhs, rhs) {\r\n            //ax+b comes back as [a, x, ax, b];\r\n            var parts = explode(lhs.args[0], solve_for);\r\n            //check if x is by itself\r\n            var x = parts[1];\r\n            if(x.group === S) {\r\n                return _.divide(_.symfunction(name, [_.divide(rhs, _.parse(lhs.multiplier))]), parts[0]);\r\n            }\r\n\r\n        };\r\n\r\n        //first remove any denominators\r\n        eq = correct_denom(eq);\r\n\r\n        if(eq.equals(0))\r\n            return [eq];\r\n        //correct fractionals. I can only handle one type right now\r\n        var fkeys = core.Utils.keys(fractionals);\r\n        if(fkeys.length === 1) {\r\n            //make a note of the factor\r\n            cfact = fkeys[0];\r\n            eq.each(function (x, index) {\r\n                if(x.contains(solve_for)) {\r\n                    var parts = explode(x, solve_for);\r\n                    var v = parts[1];\r\n                    var p = v.power;\r\n                    if(p.den.gt(1)) {\r\n                        v.power = p.multiply(new core.Frac(cfact));\r\n                        eq.symbols[index] = _.multiply(v, parts[0]);\r\n                    }\r\n                }\r\n            });\r\n            eq = _.parse(eq);\r\n        }\r\n\r\n        //try for nested sqrts as per issue #486\r\n        add_to_result(__.sqrtSolve(eq, solve_for));\r\n\r\n        //polynomial single variable\r\n        if(numvars === 1) {\r\n            if(eq.isPoly(true)) {\r\n                //try to factor and solve\r\n                var factors = new core.Algebra.Classes.Factors();\r\n\r\n                core.Algebra.Factor.factor(eq, factors);\r\n                //if the equation has more than one symbolic factor then solve those individually\r\n                if(factors.getNumberSymbolics() > 1) {\r\n                    for(var x in factors.factors) {\r\n                        add_to_result(solve(factors.factors[x], solve_for));\r\n                    }\r\n                }\r\n                else {\r\n                    var coeffs = core.Utils.getCoeffs(eq, solve_for),\r\n                            deg = coeffs.length - 1,\r\n                            was_calculated = false;\r\n                    if(vars[0] === solve_for) {\r\n                        //check to see if all the coefficients are constant\r\n                        if(checkAll(coeffs, function (x) {\r\n                            return x.group !== core.groups.N;\r\n                        })) {\r\n                            var roots = core.Algebra.proots(eq);\r\n                            //if all the roots are integers then return those\r\n                            if(checkAll(roots, function (x) {\r\n                                return !core.Utils.isInt(x);\r\n                            })) {\r\n                                //roots have been calculates\r\n                                was_calculated = true;\r\n                                roots.map(function (x) {\r\n                                    add_to_result(new Symbol(x));\r\n                                });\r\n                            }\r\n                        }\r\n\r\n                        if(!was_calculated) {\r\n                            eqns = _.parse(eqns);\r\n                            if(eqns instanceof core.Equation)\r\n                                eqns = eqns.toLHS();\r\n\r\n                            //we can solve algebraically for degrees 1, 2, 3. The remainder we switch to Jenkins-\r\n                            if(deg === 1)\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                            else if(deg === 2) {\r\n                                add_to_result(_.expand(__.quad.apply(undefined, coeffs)));\r\n                            }\r\n\r\n                            else if(deg === 3) {\r\n                                var solutions = []; //set to blank\r\n                                //first try to factor and solve\r\n                                var factored = core.Algebra.Factor.factor(eqns);\r\n\r\n                                //if it was successfully factored\r\n                                var solutions = [];\r\n                                if(solutions.length > 0)\r\n                                    add_to_result(solutions);\r\n                                else\r\n                                    add_to_result(__.cubic.apply(undefined, coeffs));\r\n                            }\r\n\r\n                            else {\r\n                                /*\r\n                                 var sym_roots = csolve(eq, solve_for); \r\n                                 if(sym_roots.length === 0)\r\n                                 sym_roots = divnconsolve(eq, solve_for);\r\n                                 if(sym_roots.length > 0) \r\n                                 add_to_result(sym_roots);\r\n                                 else\r\n                                 */\r\n                                _A.proots(eq).map(add_to_result);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    // Attempt Newton\r\n                    // Since it's not a polynomial then we'll try to look for a solution using Newton's method\r\n                    var has_trig = eq.hasTrig();\r\n                    // we get all the points where a possible zero might exist.\r\n                    var points1 = __.getPoints(eq, 0.1);\r\n                    var points2 = __.getPoints(eq, 0.05);\r\n                    var points3 = __.getPoints(eq, 0.01);\r\n                    var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function (a, b) {\r\n                        return a - b;\r\n                    });\r\n                    var i, point, solution;\r\n\r\n                    // Compile the function\r\n                    var f = build(eq.clone());\r\n\r\n                    // First try to eliminate some points using bisection\r\n                    var t_points = [];\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        // See if there's a solution at this point\r\n                        solution = __.bisection(point, f);\r\n\r\n                        // If there's no solution then add it to the array for further investigation\r\n                        if(typeof solution === 'undefined') {\r\n                            t_points.push(point);\r\n                            continue;\r\n                        }\r\n\r\n                        // Add the solution to the solution set\r\n                        add_to_result(solution, has_trig);\r\n                    }\r\n\r\n                    // Reset the points to the remaining points\r\n                    points = t_points;\r\n\r\n                    // Build the derivative and compile a function\r\n                    var d = _C.diff(eq.clone());\r\n                    var fp = build(d);\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        add_to_result(__.Newton(point, f, fp), has_trig);\r\n                    }\r\n                    solutions.sort();\r\n                }\r\n                catch(e) {\r\n                    console.log(e);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            //The idea here is to go through the equation and collect the coefficients\r\n            //place them in an array and call the quad or cubic function to get the results\r\n            if(!eq.hasFunc(solve_for) && eq.isComposite()) {\r\n                try {\r\n                    var factored = core.Algebra.Factor.factor(eq.clone());\r\n\r\n                    if(factored.group === CB) {\r\n                        factored.each(function (x) {\r\n                            add_to_result(solve(x, solve_for));\r\n                        });\r\n                    }\r\n                    else {\r\n                        var coeffs = core.Utils.getCoeffs(eq, solve_for);\r\n\r\n                        var l = coeffs.length,\r\n                                deg = l - 1; //the degree of the polynomial\r\n                        //get the denominator and make sure it doesn't have x\r\n\r\n                        //handle the problem based on the degree\r\n                        switch(deg) {\r\n                            case 0:\r\n                                var separated = separate(eq);\r\n                                var lhs = separated[0],\r\n                                        rhs = separated[1];\r\n                                if(lhs.group === core.groups.EX) {\r\n                                    add_to_result(_.parse(core.Utils.format(core.Settings.LOG + '(({0})/({2}))/' + core.Settings.LOG + '({1})', rhs, lhs.value, lhs.multiplier)));\r\n                                }\r\n                                break;\r\n                            case 1:\r\n                                //nothing to do but to return the quotient of the constant and the LT\r\n                                //e.g. 2*x-1\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                                break;\r\n                            case 2:\r\n                                add_to_result(__.quad.apply(undefined, coeffs));\r\n                                break;\r\n                            case 3:\r\n                                add_to_result(__.cubic.apply(undefined, coeffs));\r\n                                break;\r\n                            case 4:\r\n                                add_to_result(__.quartic.apply(undefined, coeffs));\r\n                                break;\r\n                            default:\r\n                                add_to_result(__.csolve(eq, solve_for));\r\n                                if(solutions.length === 0)\r\n                                    add_to_result(__.divideAndConquer(eq, solve_for));\r\n                        }\r\n\r\n                        if(solutions.length === 0) {\r\n                            //try factoring\r\n                            add_to_result(solve(factored, solve_for, solutions, depth));\r\n                        }\r\n                    }\r\n\r\n                }\r\n                catch(e) { /*something went wrong. EXITING*/\r\n                    ;\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    var rw = __.rewrite(eq, null, solve_for);\r\n                    var lhs = rw[0];\r\n                    var rhs = rw[1];\r\n                    if(lhs.group === FN) {\r\n                        if(lhs.fname === 'abs') {\r\n                            add_to_result([rhs.clone(), rhs.negate()]);\r\n                        }\r\n                        else if(lhs.fname === 'sin') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('asin', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'cos') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('acos', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'tan') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('atan', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === core.Settings.LOG) {\r\n                            //ax+b comes back as [a, x, ax, b];\r\n                            var parts = explode(lhs.args[0], solve_for);\r\n                            //check if x is by itself\r\n                            var x = parts[1];\r\n                            if(x.group === S) {\r\n                                rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol('e'), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);\r\n                                var eq = new Equation(x, rhs).toLHS();\r\n                                add_to_result(solve(eq, solve_for));\r\n                            }\r\n                        }\r\n                        else\r\n                            add_to_result(_.subtract(lhs, rhs));\r\n                    }\r\n                    else {\r\n                        var neq = new Equation(lhs, rhs).toLHS(); //create a new equation\r\n\r\n                        if(neq.equals(eq))\r\n                            throw new Error('Stopping. No stop condition exists');\r\n                        add_to_result(solve(neq, solve_for));\r\n                    }\r\n                }\r\n                catch(error) {\r\n                    //Let's try this another way\r\n                    try {\r\n                        //1. if the symbol is in the form a*b*c*... then the solution is zero if \r\n                        //either a or b or c is zero.\r\n                        if(eq.group === CB)\r\n                            add_to_result(0);\r\n                        else if(eq.group === CP) {\r\n                            var separated = separate(eq);\r\n                            var lhs = separated[0],\r\n                                    rhs = separated[1];\r\n\r\n                            //reduce the equation\r\n                            if(lhs.group === core.groups.EX && lhs.value === solve_for) {\r\n                                //change the base of both sides\r\n                                var p = lhs.power.clone().invert();\r\n                                add_to_result(_.pow(rhs, p));\r\n                            }\r\n                        }\r\n                    }\r\n                    catch(error) {\r\n                        ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(cfact) {\r\n            solutions = solutions.map(function (x) {\r\n                return _.pow(x, new Symbol(cfact));\r\n            });\r\n        }\r\n\r\n        // Perform some cleanup but don't do it agains arrays, etc\r\n        // Check it actually evaluates to zero\r\n        if(isSymbol(eqns)) {\r\n            var knowns = {};\r\n            solutions = solutions.filter(function (x) {\r\n                try {\r\n                    knowns[solve_for] = x;\r\n                    var zero = Number(evaluate(eqns, knowns));\r\n\r\n                    // Allow symbolic answers\r\n                    if(isNaN(zero)) {\r\n                        return true;\r\n                    }\r\n                    return true;\r\n                }\r\n                catch(e) {\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n\r\n        return solutions;\r\n    };\r\n\r\n    //Register the functions for external use\r\n    nerdamer.register([\r\n        {\r\n            name: 'solveEquations',\r\n            parent: 'nerdamer',\r\n            numargs: -1,\r\n            visible: true,\r\n            build: function () {\r\n                return solve; //comment out to return a vector\r\n                /*\r\n                 return function() {\r\n                 return core.Utils.convertToVector(solve.apply(null, arguments));\r\n                 };\r\n                 */\r\n            }\r\n        },\r\n        {\r\n            name: 'solve',\r\n            parent: 'Solve',\r\n            numargs: 2,\r\n            visible: true,\r\n            build: function () {\r\n                return core.Solve.solve;\r\n            }\r\n        },\r\n        {\r\n            name: 'setEquation',\r\n            parent: 'Solve',\r\n            visible: true,\r\n            build: function () {\r\n                return setEq;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.api();\r\n})();"]},"metadata":{},"sourceType":"script"}