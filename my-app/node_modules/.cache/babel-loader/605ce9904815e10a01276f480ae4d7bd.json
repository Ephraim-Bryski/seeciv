{"ast":null,"code":"/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\n\n/* global module, Function */\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Calculus.js');\n}\n\n(function () {\n  \"use strict\";\n  /*shortcuts*/\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      N = core.groups.N,\n      P = core.groups.P,\n      S = core.groups.S,\n      EX = core.groups.EX,\n      FN = core.groups.FN,\n      PL = core.groups.PL,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      keys = core.Utils.keys,\n      even = core.Utils.even,\n      variables = core.Utils.variables,\n      format = core.Utils.format,\n      round = core.Utils.round,\n      Frac = core.Frac,\n      isInt = core.Utils.isInt,\n      Symbol = core.Symbol,\n      CONST_HASH = core.Settings.CONST_HASH,\n      math = core.Utils.importFunctions(),\n      evaluate = core.Utils.evaluate; //*************** CLASSES ***************//\n\n  /**\r\n   * Converts a symbol into an equivalent polynomial arrays of \r\n   * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n   * Univariate polymials only. \r\n   * @param {Symbol|Number} symbol\r\n   * @param {String} variable The variable name of the polynomial\r\n   * @param {int} order\r\n   */\n\n  function Polynomial(symbol, variable, order) {\n    if (core.Utils.isSymbol(symbol)) {\n      this.parse(symbol);\n      this.variable = this.variable || variable;\n    } else if (!isNaN(symbol)) {\n      order = order || 0;\n      if (variable === undefined) throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\n      this.coeffs = [];\n      this.coeffs[order] = symbol;\n      this.fill(symbol);\n    } else if (typeof symbol === 'string') {\n      this.parse(_.parse(symbol));\n    }\n  }\n  /**\r\n   * Creates a Polynomial given an array of coefficients\r\n   * @param {int[]} arr\r\n   * @param {String} variable\r\n   * @returns {Polynomial}\r\n   */\n\n\n  Polynomial.fromArray = function (arr, variable) {\n    if (typeof variable === 'undefined') throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\n    var p = new Polynomial();\n    p.coeffs = arr;\n    p.variable = variable;\n    return p;\n  };\n\n  Polynomial.fit = function (c1, c2, n, base, p, variable) {\n    //after having looped through and mod 10 the number to get the matching factor\n    var terms = new Array(p + 1),\n        t = n - c2;\n    terms[0] = c2; //the constants is assumed to be correct\n    //constant for x^p is also assumed know so add\n\n    terms[p] = c1;\n    t -= c1 * Math.pow(base, p); //start fitting\n\n    for (var i = p - 1; i > 0; i--) {\n      var b = Math.pow(base, i),\n          //we want as many wholes as possible\n      q = t / b,\n          sign = Math.sign(q);\n      var c = sign * Math.floor(Math.abs(q));\n      t -= c * b;\n      terms[i] = c;\n    }\n\n    if (t !== 0) return null;\n\n    for (var i = 0; i < terms.length; i++) terms[i] = new Frac(terms[i]);\n\n    return Polynomial.fromArray(terms, variable);\n  };\n\n  Polynomial.prototype = {\n    /**\r\n     * Converts Symbol to Polynomial\r\n     * @param {Symbol} symbol\r\n     * @param {Array} c - a collector array\r\n     * @returns {Polynomial}\r\n     */\n    parse: function (symbol, c) {\n      this.variable = variables(symbol)[0];\n      if (!symbol.isPoly()) throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\n      c = c || [];\n      if (!symbol.power.absEquals(1)) symbol = _.expand(symbol);\n\n      if (symbol.group === core.groups.N) {\n        c[0] = symbol.multiplier;\n      } else if (symbol.group === core.groups.S) {\n        c[symbol.power.toDecimal()] = symbol.multiplier;\n      } else {\n        for (var x in symbol.symbols) {\n          var sub = symbol.symbols[x],\n              p = sub.power;\n          if (core.Utils.isSymbol(p)) throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\n          p = sub.group === N ? 0 : p.toDecimal();\n\n          if (sub.symbols) {\n            this.parse(sub, c);\n          } else {\n            c[p] = sub.multiplier;\n          }\n        }\n      }\n\n      this.coeffs = c;\n      this.fill();\n    },\n\n    /**\r\n     * Fills in the holes in a polynomial with zeroes\r\n     * @param {Number} x - The number to fill the holes with\r\n     */\n    fill: function (x) {\n      x = Number(x) || 0;\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        if (this.coeffs[i] === undefined) {\n          this.coeffs[i] = new Frac(x);\n        }\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Removes higher order zeros or a specific coefficient\r\n     * @returns {Array}\r\n     */\n    trim: function () {\n      var l = this.coeffs.length;\n\n      while (l--) {\n        var c = this.coeffs[l];\n        var equalsZero = c.equals(0);\n\n        if (c && equalsZero) {\n          if (l === 0) break;\n          this.coeffs.pop();\n        } else break;\n      }\n\n      return this;\n    },\n\n    /*\r\n     * Returns polynomial mod p **currently fails**\r\n     * @param {Number} p\r\n     * @returns {Polynomial}\r\n     */\n    modP: function (p) {\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var c = this.coeffs[i];\n\n        if (c < 0) {\n          //go borrow\n          var b; //a coefficient > 0\n\n          for (var j = i; j < l; j++) {\n            //starting from where we left off\n            if (this.coeffs[j] > 0) {\n              b = this.coeffs[j];\n              break;\n            }\n          }\n\n          if (b) {\n            //if such a coefficient exists\n            for (j; j > i; j--) {\n              //go down the line and adjust using p\n              this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\n              this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\n            }\n\n            c = this.coeffs[i]; //reset c\n          }\n        }\n\n        var d = c.mod(p);\n        var w = c.subtract(d).divide(p);\n\n        if (!w.equals(0)) {\n          var up_one = i + 1;\n          var next = this.coeffs[up_one] || new Frac(0);\n          next = next.add(w);\n          this.coeffs[up_one] = new Frac(next);\n          this.coeffs[i] = new Frac(d);\n        }\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Adds together 2 polynomials\r\n     * @param {Polynomial} poly\r\n     */\n    add: function (poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n            b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.add(b);\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Adds together 2 polynomials\r\n     * @param {Polynomial} poly\r\n     */\n    subtract: function (poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n            b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.subtract(b);\n      }\n\n      return this;\n    },\n    divide: function (poly) {\n      var variable = this.variable,\n          dividend = core.Utils.arrayClone(this.coeffs),\n          divisor = core.Utils.arrayClone(poly.coeffs),\n          n = dividend.length,\n          mp = divisor.length - 1,\n          quotient = []; //loop through the dividend\n\n      for (var i = 0; i < n; i++) {\n        var p = n - (i + 1); //get the difference of the powers\n\n        var d = p - mp; //get the quotient of the coefficients\n\n        var q = dividend[p].divide(divisor[mp]);\n        if (d < 0) break; //the divisor is not greater than the dividend\n        //place it in the quotient\n\n        quotient[d] = q;\n\n        for (var j = 0; j <= mp; j++) {\n          //reduce the dividend\n          dividend[j + d] = dividend[j + d].subtract(divisor[j].multiply(q));\n        }\n      } //clean up\n\n\n      var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(),\n          //pass in x for safety\n      p2 = Polynomial.fromArray(quotient, variable || 'x');\n      return [p2, p1];\n    },\n    multiply: function (poly) {\n      var l1 = this.coeffs.length,\n          l2 = poly.coeffs.length,\n          c = []; //array to be returned\n\n      for (var i = 0; i < l1; i++) {\n        var x1 = this.coeffs[i];\n\n        for (var j = 0; j < l2; j++) {\n          var k = i + j,\n              //add the powers together\n          x2 = poly.coeffs[j],\n              e = c[k] || new Frac(0); //get the existing term from the new array\n\n          c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\n        }\n      }\n\n      this.coeffs = c;\n      return this;\n    },\n\n    /**\r\n     * Checks if a polynomial is zero\r\n     * @returns {Boolean}\r\n     */\n    isZero: function () {\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var e = this.coeffs[i];\n        if (!e.equals(0)) return false;\n      }\n\n      return true;\n    },\n\n    /** \r\n     * Substitutes in a number n into the polynomial p(n)\r\n     * @param {Number} n\r\n     * @returns {Frac}\r\n     */\n    sub: function (n) {\n      var sum = new Frac(0),\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var t = this.coeffs[i];\n        if (!t.equals(0)) sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\n      }\n\n      return sum;\n    },\n\n    /**\r\n     * Returns a clone of the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    clone: function () {\n      var p = new Polynomial();\n      p.coeffs = this.coeffs;\n      p.variable = this.variable;\n      return p;\n    },\n\n    /**\r\n     * Gets the degree of the polynomial\r\n     * @returns {Number}\r\n     */\n    deg: function () {\n      this.trim();\n      return this.coeffs.length - 1;\n    },\n\n    /**\r\n     * Returns a lead coefficient\r\n     * @returns {Frac}\r\n     */\n    lc: function () {\n      return this.coeffs[this.deg()].clone();\n    },\n\n    /**\r\n     * Converts polynomial into a monic polynomial\r\n     * @returns {Polynomial}\r\n     */\n    monic: function () {\n      var lc = this.lc(),\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) this.coeffs[i] = this.coeffs[i].divide(lc);\n\n      return this;\n    },\n\n    /**\r\n     * Returns the GCD of two polynomials\r\n     * @param {Polynomial} poly\r\n     * @returns {Polynomial}\r\n     */\n    gcd: function (poly) {\n      //get the maximum power of each\n      var mp1 = this.coeffs.length - 1,\n          mp2 = poly.coeffs.length - 1,\n          T; //swap so we always have the greater power first\n\n      if (mp1 < mp2) {\n        return poly.gcd(this);\n      }\n\n      var a = this;\n\n      while (!poly.isZero()) {\n        var t = poly.clone();\n        a = a.clone();\n        T = a.divide(t);\n        poly = T[1];\n        a = t;\n      }\n\n      var gcd = core.Math2.QGCD.apply(null, a.coeffs);\n\n      if (!gcd.equals(1)) {\n        var l = a.coeffs.length;\n\n        for (var i = 0; i < l; i++) {\n          a.coeffs[i] = a.coeffs[i].divide(gcd);\n        }\n      }\n\n      return a;\n    },\n\n    /**\r\n     * Differentiates the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    diff: function () {\n      var new_array = [],\n          l = this.coeffs.length;\n\n      for (var i = 1; i < l; i++) new_array.push(this.coeffs[i].multiply(new Frac(i)));\n\n      this.coeffs = new_array;\n      return this;\n    },\n\n    /**\r\n     * Integrates the polynomial\r\n     * @returns {Polynomial} \r\n     */\n    integrate: function () {\n      var new_array = [0],\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var c = new Frac(i + 1);\n        new_array[c] = this.coeffs[i].divide(c);\n      }\n\n      this.coeffs = new_array;\n      return this;\n    },\n\n    /**\r\n     * Returns the Greatest common factor of the polynomial\r\n     * @param {bool} toPolynomial - true if a polynomial is wanted\r\n     * @returns {Frac|Polynomial}\r\n     */\n    gcf: function (toPolynomial) {\n      //get the first nozero coefficient and returns its power\n      var fnz = function (a) {\n        for (var i = 0; i < a.length; i++) if (!a[i].equals(0)) return i;\n      },\n          ca = [];\n\n      for (var i = 0; i < this.coeffs.length; i++) {\n        var c = this.coeffs[i];\n        if (!c.equals(0) && ca.indexOf(c) === -1) ca.push(c);\n      }\n\n      var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\n\n      if (toPolynomial) {\n        var parr = [];\n        parr[p[1] - 1] = p[0];\n        p = Polynomial.fromArray(parr, this.variable).fill();\n      }\n\n      return p;\n    },\n\n    /**\r\n     * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n     * @param {bool} incl_img - Include imaginary numbers \r\n     */\n    quad: function (incl_img) {\n      var roots = [];\n      if (this.coeffs.length > 3) throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\n      if (this.coeffs.length === 0) throw new Error('Polynomial array has no terms');\n      var a = this.coeffs[2] || 0,\n          b = this.coeffs[1] || 0,\n          c = this.coeffs[0];\n      var dsc = b * b - 4 * a * c;\n      if (dsc < 0 && !incl_img) return roots;else {\n        roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\n        roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\n      }\n      return roots;\n    },\n\n    /**\r\n     * Makes polynomial square free\r\n     * @returns {Array}\r\n     */\n    squareFree: function () {\n      var a = this.clone(),\n          i = 1,\n          b = a.clone().diff(),\n          c = a.clone().gcd(b),\n          w = a.divide(c)[0];\n      var output = Polynomial.fromArray([new Frac(1)], a.variable);\n\n      while (!c.equalsNumber(1)) {\n        var y = w.gcd(c);\n        var z = w.divide(y)[0]; //one of the factors may have shown up since it's square but smaller than the \n        //one where finding\n\n        if (!z.equalsNumber(1) && i > 1) {\n          var t = z.clone();\n\n          for (var j = 1; j < i; j++) t.multiply(z.clone());\n\n          z = t;\n        }\n\n        output = output.multiply(z);\n        i++;\n        w = y;\n        c = c.divide(y)[0];\n      }\n\n      return [output, w, i];\n    },\n\n    /**\r\n     * Converts polynomial to Symbol\r\n     * @returns {Symbol}\r\n     */\n    toSymbol: function () {\n      var l = this.coeffs.length,\n          variable = this.variable;\n      if (l === 0) return new core.Symbol(0);\n      var end = l - 1,\n          str = '';\n\n      for (var i = 0; i < l; i++) {\n        //place the plus sign for all but the last one\n        var plus = i === end ? '' : '+',\n            e = this.coeffs[i];\n        if (!e.equals(0)) str += e + '*' + variable + '^' + i + plus;\n      }\n\n      return _.parse(str);\n    },\n\n    /**\r\n     * Checks if polynomial is equal to a number\r\n     * @param {Number} x\r\n     * @returns {Boolean}\r\n     */\n    equalsNumber: function (x) {\n      this.trim();\n      return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\n    },\n    toString: function () {\n      return this.toSymbol().toString();\n    }\n  };\n  /**\r\n   * TODO\r\n   * ===================================================================================\r\n   * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n   * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n   * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n   * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n   * ===================================================================================\r\n   * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n   * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n   * so the symbol multiplier carries the coefficients for all contained symbols.\r\n   * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n   * @param {Array} c The coefficient array\r\n   * @param {boolean} with_order \r\n   * @return {Array}\r\n   */\n\n  Symbol.prototype.coeffs = function (c, with_order) {\n    if (with_order && !this.isPoly(true)) _.error('Polynomial expected when requesting coefficients with order');\n    c = c || [];\n    var s = this.clone().distributeMultiplier();\n\n    if (s.isComposite()) {\n      for (var x in s.symbols) {\n        var sub = s.symbols[x];\n\n        if (sub.isComposite()) {\n          sub.clone().distributeMultiplier().coeffs(c, with_order);\n        } else {\n          if (with_order) c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;else {\n            c.push(sub.multiplier);\n          }\n        }\n      }\n    } else {\n      if (with_order) c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;else {\n        if (s.group === CB && s.isImaginary()) {\n          var m = new Symbol(s.multiplier);\n          s.each(function (x) {\n            //add the imaginary part\n            if (x.isConstant(true) || x.imaginary) m = _.multiply(m, x);\n          });\n          c.push(m);\n        } else c.push(s.multiplier);\n      }\n    } //fill the holes\n\n\n    if (with_order) {\n      for (var i = 0; i < c.length; i++) if (c[i] === undefined) c[i] = new Symbol(0);\n    }\n\n    return c;\n  };\n\n  Symbol.prototype.tBase = function (map) {\n    if (typeof map === 'undefined') throw new Error('Symbol.tBase requires a map object!');\n    var terms = [];\n    var symbols = this.collectSymbols(null, null, null, true),\n        l = symbols.length;\n\n    for (var i = 0; i < l; i++) {\n      var symbol = symbols[i],\n          g = symbol.group,\n          nterm = new MVTerm(symbol.multiplier, [], map);\n\n      if (g === CB) {\n        for (var x in symbol.symbols) {\n          var sym = symbol.symbols[x];\n          nterm.terms[map[x]] = sym.power;\n        }\n      } else {\n        nterm.terms[map[symbol.value]] = symbol.power;\n      }\n\n      terms.push(nterm.fill());\n      nterm.updateCount();\n    }\n\n    return terms;\n  };\n\n  Symbol.prototype.altVar = function (x) {\n    var m = this.multiplier.toString(),\n        p = this.power.toString();\n    return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\n  };\n  /**\r\n   * Checks to see if the symbols contain the same variables\r\n   * @param {Symbol} symbol\r\n   * @returns {Boolean}\r\n   */\n\n\n  Symbol.prototype.sameVars = function (symbol) {\n    if (!(this.symbols || this.group === symbol.group)) return false;\n\n    for (var x in this.symbols) {\n      var a = this.symbols[x],\n          b = symbol.symbols[x];\n      if (!b) return false;\n      if (a.value !== b.value) return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Groups the terms in a symbol with respect to a variable\r\n   * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n   * @returns {Factors}\r\n   */\n\n\n  Symbol.prototype.groupTerms = function (x) {\n    x = String(x);\n    var f, p, egrouped;\n    var grouped = [];\n    this.each(function (e) {\n      if (e.group === PL) {\n        egrouped = e.groupTerms(x);\n\n        for (var i = 0; i < egrouped.length; i++) {\n          var el = egrouped[i];\n          if (el) grouped[i] = el;\n        }\n      } else {\n        f = core.Utils.decompose_fn(e, x, true);\n        p = f.x.value === x ? Number(f.x.power) : 0; //check if there's an existing value\n\n        grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\n      }\n    });\n    return grouped;\n  };\n  /**\r\n   * Use this to collect Factors\r\n   * @returns {Symbol[]}\r\n   */\n\n\n  Symbol.prototype.collectFactors = function () {\n    var factors = [];\n    if (this.group === CB) this.each(function (x) {\n      factors.push(x.clone());\n    });else factors.push(this.clone());\n    return factors;\n  };\n  /**\r\n   * A container class for factors\r\n   * @returns {Factors}\r\n   */\n\n\n  function Factors() {\n    this.factors = {};\n    this.length = 0;\n  }\n\n  ;\n\n  Factors.prototype.getNumberSymbolics = function () {\n    var n = 0;\n    this.each(function (x) {\n      if (!x.isConstant(true)) n++;\n    });\n    return n;\n  };\n  /**\r\n   * Adds the factors to the factor object\r\n   * @param {Symbo} s\r\n   * @returns {Factors}\r\n   */\n\n\n  Factors.prototype.add = function (s) {\n    if (s.equals(0)) return this; //nothing to add\n    //we don't want to carry -1 as a factor. If a factor already exists,\n    //then add the minus one to that factor and return.\n\n    if (s.equals(-1) && this.length > 0) {\n      var fo = core.Utils.firstObject(this.factors, null, true);\n      this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\n      delete this.factors[fo.key];\n      this.length--;\n      return this;\n    }\n\n    if (s.group === CB) {\n      var factors = this;\n      if (!s.multiplier.equals(1)) factors.add(new Symbol(s.multiplier));\n      s.each(function (x) {\n        factors.add(x);\n      });\n    } else {\n      if (this.preAdd) //if a preAdd function was defined call it to do prep\n        s = this.preAdd(s);\n      if (this.pFactor) //if the symbol isn't linear add back the power\n        s = _.pow(s, new Symbol(this.pFactor));\n      var is_constant = s.isConstant();\n      if (is_constant && s.equals(1)) return this; //don't add 1\n\n      var v = is_constant ? s.value : s.text();\n\n      if (v in this.factors) {\n        this.factors[v] = _.multiply(this.factors[v], s); //did the addition cancel out the existing factor? If so remove it and decrement the length\n\n        if (this.factors[v].equals(1)) {\n          delete this.factors[v];\n          this.length--;\n        }\n      } else {\n        this.factors[v] = s;\n        this.length++;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Converts the factor object to a Symbol\r\n   * @returns {Symbol}\r\n   */\n\n\n  Factors.prototype.toSymbol = function () {\n    var factored = new Symbol(1);\n    var factors = Object.values(this.factors).sort(function (a, b) {\n      return a.group > b.group;\n    });\n\n    for (var i = 0, l = factors.length; i < l; i++) {\n      var f = factors[i]; //don't wrap group S or FN\n\n      var factor = f.power.equals(1) && f.fname !== ''\n      /* don't wrap it twice */\n      ? _.symfunction(core.PARENTHESIS, [f]) : f;\n      factored = _.multiply(factored, factor);\n    }\n\n    if (factored.fname === '') factored = Symbol.unwrapPARENS(factored);\n    return factored;\n  };\n  /**\r\n   * Merges 2 factor objects into one\r\n   * @param {Factor} o\r\n   * @returns {Factors}\r\n   */\n\n\n  Factors.prototype.merge = function (o) {\n    for (var x in o) {\n      if (x in this.factors) this.factors[x] = _.multiply(this.factors[x], o[x]);else this.factors[x] = o[x];\n    }\n\n    return this;\n  };\n  /**\r\n   * The iterator for the factor object\r\n   * @param {Function} f - callback\r\n   * @returns {Factor}\r\n   */\n\n\n  Factors.prototype.each = function (f) {\n    for (var x in this.factors) {\n      var factor = this.factors[x];\n      if (factor.fname === core.PARENTHESIS && factor.isLinear()) factor = factor.args[0];\n      f.call(this, factor, x);\n    }\n\n    return this;\n  };\n  /**\r\n   * Return the number of factors contained in the factor object\r\n   * @returns {int}\r\n   */\n\n\n  Factors.prototype.count = function () {\n    return keys(this.factors).length;\n  };\n  /**\r\n   * Cleans up factors from -1\r\n   * @returns {undefined}\r\n   */\n\n\n  Factors.prototype.clean = function () {\n    try {\n      var h = core.Settings.CONST_HASH;\n\n      if (this.factors[h].lessThan(0)) {\n        if (this.factors[h].equals(-1)) delete this.factors[h];else this.factors[h].negate();\n        this.each(function (x) {\n          x.negate();\n        });\n      }\n    } catch (e) {}\n\n    ;\n  };\n\n  Factors.prototype.toString = function () {\n    return this.toSymbol().toString();\n  }; //a wrapper for performing multivariate division\n\n\n  function MVTerm(coeff, terms, map) {\n    this.terms = terms || [];\n    this.coeff = coeff;\n    this.map = map; //careful! all maps are the same object\n\n    this.sum = new core.Frac(0);\n    this.image = undefined;\n  }\n\n  ;\n\n  MVTerm.prototype.updateCount = function () {\n    this.count = this.count || 0;\n\n    for (var i = 0; i < this.terms.length; i++) {\n      if (!this.terms[i].equals(0)) this.count++;\n    }\n\n    return this;\n  };\n\n  MVTerm.prototype.getVars = function () {\n    var vars = [];\n\n    for (var i = 0; i < this.terms.length; i++) {\n      var term = this.terms[i],\n          rev_map = this.getRevMap();\n      if (!term.equals(0)) vars.push(this.rev_map[i]);\n    }\n\n    return vars.join(' ');\n  };\n\n  MVTerm.prototype.len = function () {\n    if (typeof this.count === 'undefined') {\n      this.updateCount();\n    }\n\n    return this.count;\n  };\n\n  MVTerm.prototype.toSymbol = function (rev_map) {\n    rev_map = rev_map || this.getRevMap();\n    var symbol = new Symbol(this.coeff);\n\n    for (var i = 0; i < this.terms.length; i++) {\n      var v = rev_map[i],\n          t = this.terms[i];\n      if (t.equals(0) || v === CONST_HASH) continue;\n      var mapped = new Symbol(v);\n      mapped.power = t;\n      symbol = _.multiply(symbol, mapped);\n    }\n\n    return symbol;\n  };\n\n  MVTerm.prototype.getRevMap = function () {\n    if (this.rev_map) return this.rev_map;\n    var o = {};\n\n    for (var x in this.map) o[this.map[x]] = x;\n\n    this.rev_map = o;\n    return o;\n  };\n\n  MVTerm.prototype.generateImage = function () {\n    this.image = this.terms.join(' ');\n    return this;\n  }, MVTerm.prototype.getImg = function () {\n    if (!this.image) this.generateImage();\n    return this.image;\n  }, MVTerm.prototype.fill = function () {\n    var l = this.map.length;\n\n    for (var i = 0; i < l; i++) {\n      if (typeof this.terms[i] === 'undefined') this.terms[i] = new core.Frac(0);else {\n        this.sum = this.sum.add(this.terms[i]);\n      }\n    }\n\n    return this;\n  };\n\n  MVTerm.prototype.divide = function (mvterm) {\n    var c = this.coeff.divide(mvterm.coeff),\n        l = this.terms.length,\n        new_mvterm = new MVTerm(c, [], this.map);\n\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n\n    return new_mvterm;\n  };\n\n  MVTerm.prototype.multiply = function (mvterm) {\n    var c = this.coeff.multiply(mvterm.coeff),\n        l = this.terms.length,\n        new_mvterm = new MVTerm(c, [], this.map);\n\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n\n    return new_mvterm;\n  };\n\n  MVTerm.prototype.isZero = function () {\n    return this.coeff.equals(0);\n  };\n\n  MVTerm.prototype.toString = function () {\n    return '{ coeff: ' + this.coeff.toString() + ', terms: [' + this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\n  };\n\n  core.Utils.toMapObj = function (arr) {\n    var c = 0,\n        o = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      var v = arr[i];\n\n      if (typeof o[v] === 'undefined') {\n        o[v] = c;\n        c++;\n      }\n    }\n\n    o.length = c;\n    return o;\n  };\n\n  core.Utils.filledArray = function (v, n, clss) {\n    var a = [];\n\n    while (n--) {\n      a[n] = clss ? new clss(v) : v;\n    }\n\n    return a;\n  };\n\n  core.Utils.arrSum = function (arr) {\n    var sum = 0,\n        l = arr.length;\n\n    for (var i = 0; i < l; i++) sum += arr[i];\n\n    return sum;\n  };\n  /**\r\n   * Determines if 2 arrays have intersecting elements.\r\n   * @param {Array} a\r\n   * @param {Array} b\r\n   * @returns {Boolean} True if a and b have intersecting elements.\r\n   */\n\n\n  core.Utils.haveIntersection = function (a, b) {\n    var t;\n    if (b.length > a.length) t = b, b = a, a = t; // indexOf to loop over shorter\n\n    return a.some(function (e) {\n      return b.indexOf(e) > -1;\n    });\n  };\n  /**\r\n   * Substitutes out functions as variables so they can be used in regular algorithms\r\n   * @param {Symbol} symbol\r\n   * @param {Object} map\r\n   * @returns {String} The expression string\r\n   */\n\n\n  core.Utils.subFunctions = function (symbol, map) {\n    map = map || {};\n    var subbed = [];\n    symbol.each(function (x) {\n      if (x.group === FN || x.previousGroup === FN) {\n        //we need a new variable name so why not use one of the existing\n        var val = core.Utils.text(x, 'hash'),\n            tvar = map[val];\n\n        if (!tvar) {\n          //generate a unique enough name\n          var t = x.fname + keys(map).length;\n          map[val] = t;\n          subbed.push(x.altVar(t));\n        } else subbed.push(x.altVar(tvar));\n      } else if (x.group === CB || x.group === PL || x.group === CP) {\n        subbed.push(core.Utils.subFunctions(x, map));\n      } else subbed.push(x.text());\n    });\n    if (symbol.group === CP || symbol.group === PL) return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\n    ;\n    if (symbol.group === CB) return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\n    return symbol.text();\n  };\n\n  core.Utils.getFunctionsSubs = function (map) {\n    var subs = {}; //prepare substitutions\n\n    for (var x in map) subs[map[x]] = _.parse(x);\n\n    return subs;\n  };\n\n  var __ = core.Algebra = {\n    version: '1.4.6',\n    proots: function (symbol, decp) {\n      //the roots will be rounded up to 7 decimal places.\n      //if this causes trouble you can explicitly pass in a different number of places\n      //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\n      decp = decp || 7;\n      var zeros = 0;\n      var known_roots = [];\n\n      var get_roots = function (rarr, powers, max) {\n        var roots = calcroots(rarr, powers, max).concat(known_roots);\n\n        for (var i = 0; i < zeros; i++) roots.unshift(0);\n\n        return roots;\n      };\n\n      if (symbol instanceof Symbol && symbol.isPoly()) {\n        symbol.distributeMultiplier(); //make it so the symbol has a constants as the lowest term\n\n        if (symbol.group === PL) {\n          var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\n          var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\n          symbol = _.expand(_.divide(symbol, lowest_symbol));\n          known_roots.push(0); //add zero since this is a known root\n        }\n\n        if (symbol.group === core.groups.S) {\n          return [0];\n        } else if (symbol.group === core.groups.PL) {\n          var powers = keys(symbol.symbols),\n              minpower = core.Utils.arrayMin(powers),\n              symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\n        }\n\n        var variable = keys(symbol.symbols).sort().pop(),\n            sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\n            g = sym.group,\n            powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\n            rarr = [],\n            max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\n        // Prepare the data\n\n        for (var i = 1; i <= max; i++) {\n          var c = 0; //if there is no power then the hole must be filled with a zero\n\n          if (powers.indexOf(i + '') !== -1) {\n            if (g === S) {\n              c = sym.multiplier;\n            } else {\n              c = sym.symbols[i].multiplier;\n            }\n          } // Insert the coeffient but from the front\n\n\n          rarr.unshift(c);\n        }\n\n        rarr.push(symbol.symbols[CONST_HASH].multiplier);\n        if (sym.group === S) rarr[0] = sym.multiplier; //the symbol maybe of group CP with one variable\n\n        return get_roots(rarr, powers, max);\n      } else if (core.Utils.isArray(symbol)) {\n        var parr = symbol;\n        var rarr = [],\n            powers = [],\n            last_power = 0;\n\n        for (var i = 0; i < parr.length; i++) {\n          var coeff = parr[i][0],\n              pow = parr[i][1],\n              d = pow - last_power - 1; //insert the zeros\n\n          for (var j = 0; j < d; j++) rarr.unshift(0);\n\n          rarr.unshift(coeff);\n          if (pow !== 0) powers.push(pow);\n          last_power = pow;\n        }\n\n        var max = Math.max.apply(undefined, powers);\n        return get_roots(rarr, powers, max);\n      } else {\n        throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\n      }\n\n      function calcroots(rarr, powers, max) {\n        var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\n        // Make a clone of the coefficients before appending the max power\n\n        var p = rarr.slice(0); // Divide the string up into its individual entries, which--presumably--are separated by whitespace\n\n        rarr.unshift(max);\n\n        if (max > MAXDEGREE) {\n          throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\n        }\n\n        var zeroi = [],\n            // Vector of imaginary components of roots\n        degreePar = {}; // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\n\n        degreePar.Degree = max;\n\n        for (i = 0; i < max; i++) {\n          zeroi.push(0);\n        }\n\n        var zeror = zeroi.slice(0); // Vector of real components of roots\n        // Find the roots\n        //--> Begin Jenkins-Traub\n\n        /*\r\n         * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n         */\n\n        function QuadSD_ak1(NN, u, v, p, q, iPar) {\n          // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\n          // iPar is a dummy variable for passing in the two parameters--a and b--by reference\n          q[0] = iPar.b = p[0];\n          q[1] = iPar.a = -(u * iPar.b) + p[1];\n\n          for (var i = 2; i < NN; i++) {\n            q[i] = -(u * iPar.a + v * iPar.b) + p[i];\n            iPar.b = iPar.a;\n            iPar.a = q[i];\n          }\n\n          return;\n        }\n\n        function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\n          // This routine calculates scalar quantities used to compute the next K polynomial and\n          // new estimates of the quadratic coefficients.\n          // calcSC -\tinteger variable set here indicating how the calculations are normalized\n          // to avoid overflow.\n          // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\n          // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\n          var sdPar = new Object(),\n              // TYPE = 3 indicates the quadratic is almost a factor of K\n          dumFlag = 3; // Synthetic division of K by the quadratic 1, u, v\n\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(N, u, v, K, qk, sdPar);\n          iPar.c = sdPar.a;\n          iPar.d = sdPar.b;\n\n          if (Math.abs(iPar.c) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 1])) {\n            if (Math.abs(iPar.d) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 2])) return dumFlag;\n          }\n\n          iPar.h = v * b;\n\n          if (Math.abs(iPar.d) >= Math.abs(iPar.c)) {\n            // TYPE = 2 indicates that all formulas are divided by d\n            dumFlag = 2;\n            iPar.e = a / iPar.d;\n            iPar.f = iPar.c / iPar.d;\n            iPar.g = u * b;\n            iPar.a3 = iPar.e * (iPar.g + a) + iPar.h * (b / iPar.d);\n            iPar.a1 = -a + iPar.f * b;\n            iPar.a7 = iPar.h + (iPar.f + u) * a;\n          } else {\n            // TYPE = 1 indicates that all formulas are divided by c;\n            dumFlag = 1;\n            iPar.e = a / iPar.c;\n            iPar.f = iPar.d / iPar.c;\n            iPar.g = iPar.e * u;\n            iPar.a3 = iPar.e * a + (iPar.g + iPar.h / iPar.c) * b;\n            iPar.a1 = -(a * (iPar.d / iPar.c)) + b;\n            iPar.a7 = iPar.g * iPar.d + iPar.h * iPar.f + a;\n          }\n\n          return dumFlag;\n        }\n\n        function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\n          // Computes the next K polynomials using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\n          var temp;\n\n          if (tFlag == 3) {\n            // Use unscaled form of the recurrence\n            K[1] = K[0] = 0.0;\n\n            for (var i = 2; i < N; i++) {\n              K[i] = qk[i - 2];\n            }\n\n            return;\n          }\n\n          temp = tFlag == 1 ? b : a;\n\n          if (Math.abs(iPar.a1) > 10.0 * DBL_EPSILON * Math.abs(temp)) {\n            // Use scaled form of the recurrence\n            iPar.a7 /= iPar.a1;\n            iPar.a3 /= iPar.a1;\n            K[0] = qp[0];\n            K[1] = -(qp[0] * iPar.a7) + qp[1];\n\n            for (var i = 2; i < N; i++) K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\n          } else {\n            // If a1 is nearly zero, then use a special form of the recurrence\n            K[0] = 0.0;\n            K[1] = -(qp[0] * iPar.a7);\n\n            for (var i = 2; i < N; i++) {\n              K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\n            }\n          }\n\n          return;\n        }\n\n        function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\n          // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\n          // iPar.a = uu, iPar.b = vv\n          var a4, a5, b1, b2, c1, c2, c3, c4, temp;\n          iPar.b = iPar.a = 0.0; // The quadratic is zeroed\n\n          if (tFlag != 3) {\n            if (tFlag != 2) {\n              a4 = a + u * b + h * f;\n              a5 = c + (u + v * f) * d;\n            } else {\n              a4 = (a + g) * f + h;\n              a5 = (f + u) * c + v * d;\n            } // Evaluate new quadratic coefficients\n\n\n            b1 = -(K[N - 1] / p[N]);\n            b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\n            c1 = v * b2 * a1;\n            c2 = b1 * a7;\n            c3 = b1 * b1 * a3;\n            c4 = -(c2 + c3) + c1;\n            temp = -c4 + a5 + b1 * a4;\n\n            if (temp != 0.0) {\n              iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\n              iPar.b = v * (1.0 + c4 / temp);\n            }\n          }\n\n          return;\n        }\n\n        function Quad_ak1(a, b1, c, iPar) {\n          // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\n          // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\n          // zeros are real and both zeros are complex. The smaller real zero is found directly from\n          // the product of the zeros c/a.\n          // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\n          var b, d, e;\n          iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\n\n          if (a == 0) {\n            iPar.sr = b1 != 0 ? -(c / b1) : iPar.sr;\n            return;\n          }\n\n          if (c == 0) {\n            iPar.lr = -(b1 / a);\n            return;\n          } // Compute discriminant avoiding overflow\n\n\n          b = b1 / 2.0;\n\n          if (Math.abs(b) < Math.abs(c)) {\n            e = c >= 0 ? a : -a;\n            e = -e + b * (b / Math.abs(c));\n            d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\n          } else {\n            e = -(a / b * (c / b)) + 1.0;\n            d = Math.sqrt(Math.abs(e)) * Math.abs(b);\n          }\n\n          if (e >= 0) {\n            // Real zeros\n            d = b >= 0 ? -d : d;\n            iPar.lr = (-b + d) / a;\n            iPar.sr = iPar.lr != 0 ? c / iPar.lr / a : iPar.sr;\n          } else {\n            // Complex conjugate zeros\n            iPar.lr = iPar.sr = -(b / a);\n            iPar.si = Math.abs(d / a);\n            iPar.li = -iPar.si;\n          }\n\n          return;\n        }\n\n        function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\n          // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\n          // zeros are equimodular or nearly so.\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\n          // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\n          // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\n          var qPar = new Object(),\n              ee,\n              mp,\n              omp,\n              relstp,\n              t,\n              u,\n              ui,\n              v,\n              vi,\n              zm,\n              i,\n              j = 0,\n              tFlag,\n              triedFlag = 0; // Integer variables\n\n          iPar.NZ = 0; // Number of zeros found\n\n          u = uu; // uu and vv are coefficients of the starting quadratic\n\n          v = vv;\n\n          do {\n            qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n            Quad_ak1(1.0, u, v, qPar);\n            iPar.szr = qPar.sr;\n            iPar.szi = qPar.si;\n            iPar.lzr = qPar.lr;\n            iPar.lzi = qPar.li; // Return if roots of the quadratic are real and not close to multiple or nearly\n            // equal and of opposite sign.\n\n            if (Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr)) break; // Evaluate polynomial by quadratic synthetic division\n\n            QuadSD_ak1(NN, u, v, p, qp, sdPar);\n            mp = Math.abs(-(iPar.szr * sdPar.b) + sdPar.a) + Math.abs(iPar.szi * sdPar.b); // Compute a rigorous bound on the rounding error in evaluating p\n\n            zm = Math.sqrt(Math.abs(v));\n            ee = 2.0 * Math.abs(qp[0]);\n            t = -(iPar.szr * sdPar.b);\n\n            for (i = 1; i < N; i++) {\n              ee = ee * zm + Math.abs(qp[i]);\n            }\n\n            ee = ee * zm + Math.abs(t + sdPar.a);\n            ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs(sdPar.a + t) + zm * Math.abs(sdPar.b))) * DBL_EPSILON; // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\n\n            if (mp <= 20.0 * ee) {\n              iPar.NZ = 2;\n              break;\n            }\n\n            j++; // Stop iteration after 20 steps\n\n            if (j > 20) break;\n\n            if (j >= 2) {\n              if (relstp <= 0.01 && mp >= omp && !triedFlag) {\n                // A cluster appears to be stalling the convergence. Five fixed shift\n                // steps are taken with a u, v close to the cluster.\n                relstp = relstp < DBL_EPSILON ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp);\n                u -= u * relstp;\n                v += v * relstp;\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n\n                for (i = 0; i < 5; i++) {\n                  tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n                  nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n                }\n\n                triedFlag = 1;\n                j = 0;\n              }\n            }\n\n            omp = mp; // Calculate next K polynomial and new u and v\n\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vi = sdPar.b; // If vi is zero, the iteration is not converging\n\n            if (vi != 0) {\n              relstp = Math.abs((-v + vi) / vi);\n              u = ui;\n              v = vi;\n            }\n          } while (vi != 0);\n\n          return;\n        }\n\n        function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\n          // Variable-shift H-polynomial iteration for a real zero\n          // sss\t- starting iterate = sdPar.a\n          // NZ\t\t- number of zeros found = iPar.NZ\n          // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\n          var ee,\n              kv,\n              mp,\n              ms,\n              omp,\n              pv,\n              s,\n              t,\n              dumFlag,\n              i,\n              j,\n              nm1 = N - 1; // Integer variables\n\n          iPar.NZ = j = dumFlag = 0;\n          s = sdPar.a;\n\n          for (;;) {\n            pv = p[0]; // Evaluate p at s\n\n            qp[0] = pv;\n\n            for (i = 1; i < NN; i++) {\n              qp[i] = pv = pv * s + p[i];\n            }\n\n            mp = Math.abs(pv); // Compute a rigorous bound on the error in evaluating p\n\n            ms = Math.abs(s);\n            ee = 0.5 * Math.abs(qp[0]);\n\n            for (i = 1; i < NN; i++) {\n              ee = ee * ms + Math.abs(qp[i]);\n            } // Iteration has converged sufficiently if the polynomial value is less than\n            // 20 times this bound\n\n\n            if (mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\n              iPar.NZ = 1;\n              iPar.szr = s;\n              iPar.szi = 0.0;\n              break;\n            }\n\n            j++; // Stop iteration after 10 steps\n\n            if (j > 10) break;\n\n            if (j >= 2) {\n              if (Math.abs(t) <= 0.001 * Math.abs(-t + s) && mp > omp) {\n                // A cluster of zeros near the real axis has been encountered.\n                // Return with iFlag set to initiate a quadratic iteration.\n                dumFlag = 1;\n                iPar.a = s;\n                break;\n              } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\n\n            } //End if (j >= 2)\n            // Return if the polynomial value has increased significantly\n\n\n            omp = mp; // Compute t, the next polynomial and the new iterate\n\n            qk[0] = kv = K[0];\n\n            for (i = 1; i < N; i++) {\n              qk[i] = kv = kv * s + K[i];\n            }\n\n            if (Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\n              // Use the scaled form of the recurrence if the value of K at s is non-zero\n              t = -(pv / kv);\n              K[0] = qp[0];\n\n              for (i = 1; i < N; i++) {\n                K[i] = t * qk[i - 1] + qp[i];\n              }\n            } else {\n              // Use unscaled form\n              K[0] = 0.0;\n\n              for (i = 1; i < N; i++) K[i] = qk[i - 1];\n            }\n\n            kv = K[0];\n\n            for (i = 1; i < N; i++) {\n              kv = kv * s + K[i];\n            }\n\n            t = Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON ? -(pv / kv) : 0.0;\n            s += t;\n          }\n\n          return dumFlag;\n        }\n\n        function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\n          // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\n          // quadratic case. Initiates one of the variable shift iterations and returns with the\n          // number of zeros found.\n          // L2\tlimit of fixed shift steps\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // NZ\tnumber of zeros found\n          var sdPar = new Object(),\n              // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\n          calcPar = new Object(),\n              // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\n          qk = new Array(MDP1),\n              svk = new Array(MDP1),\n              a,\n              b,\n              betas,\n              betav,\n              oss,\n              ots,\n              otv,\n              ovv,\n              s,\n              ss,\n              ts,\n              tss,\n              tv,\n              tvv,\n              ui,\n              vi,\n              vv,\n              fflag,\n              i,\n              iFlag = 1,\n              j,\n              spass,\n              stry,\n              tFlag,\n              vpass,\n              vtry; // Integer variables\n\n          iPar.NZ = 0;\n          betav = betas = 0.25;\n          oss = sr;\n          ovv = v; //Evaluate polynomial by synthetic division\n\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(NN, u, v, p, qp, sdPar);\n          a = sdPar.a;\n          b = sdPar.b;\n          calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\n          tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n\n          for (j = 0; j < L2; j++) {\n            fflag = 1; // Calculate next K polynomial and estimate v\n\n            nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk); // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\n            // sdPar.a = ui, sdPar.b = vi\n\n            newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vv = vi = sdPar.b; // Estimate s\n\n            ss = K[N - 1] != 0.0 ? -(p[N] / K[N - 1]) : 0.0;\n            ts = tv = 1.0;\n\n            if (j != 0 && tFlag != 3) {\n              // Compute relative measures of convergence of s and v sequences\n              tv = vv != 0.0 ? Math.abs((vv - ovv) / vv) : tv;\n              ts = ss != 0.0 ? Math.abs((ss - oss) / ss) : ts; // If decreasing, multiply the two most recent convergence measures\n\n              tvv = tv < otv ? tv * otv : 1.0;\n              tss = ts < ots ? ts * ots : 1.0; // Compare with convergence criteria\n\n              vpass = tvv < betav ? 1 : 0;\n              spass = tss < betas ? 1 : 0;\n\n              if (spass || vpass) {\n                // At least one sequence has passed the convergence test.\n                // Store variables before iterating\n                for (i = 0; i < N; i++) {\n                  svk[i] = K[i];\n                }\n\n                s = ss; // Choose iteration according to the fastest converging sequence\n\n                stry = vtry = 0;\n\n                for (;;) {\n                  if (fflag && (fflag = 0) == 0 && spass && (!vpass || tss < tvv)) {\n                    ; // Do nothing. Provides a quick \"short circuit\".\n                  } else {\n                    QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\n                    a = sdPar.a;\n                    b = sdPar.b;\n                    if (iPar.NZ > 0) return; // Quadratic iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n\n                    iFlag = vtry = 1;\n                    betav *= 0.25; // Try linear iteration if it has not been tried and the s sequence is converging\n\n                    if (stry || !spass) {\n                      iFlag = 0;\n                    } else {\n                      for (i = 0; i < N; i++) K[i] = svk[i];\n                    }\n                  } //fflag = 0;\n\n\n                  if (iFlag != 0) {\n                    // Use sdPar for passing in s instead of defining a brand-new variable.\n                    // sdPar.a = s\n                    sdPar.a = s;\n                    iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\n                    s = sdPar.a;\n                    if (iPar.NZ > 0) return; // Linear iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n\n                    stry = 1;\n                    betas *= 0.25;\n\n                    if (iFlag != 0) {\n                      // If linear iteration signals an almost double real zero, attempt quadratic iteration\n                      ui = -(s + s);\n                      vi = s * s;\n                      continue;\n                    }\n                  } // Restore variables\n\n\n                  for (i = 0; i < N; i++) K[i] = svk[i]; // Try quadratic iteration if it has not been tried and the v sequence is converging\n\n\n                  if (!vpass || vtry) break; // Break out of infinite for loop\n                } // Re-compute qp and scalar values to continue the second stage\n\n\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n                a = sdPar.a;\n                b = sdPar.b;\n                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n              }\n            }\n\n            ovv = vv;\n            oss = ss;\n            otv = tv;\n            ots = ts;\n          }\n\n          return;\n        }\n\n        function rpSolve(degPar, p, zeror, zeroi) {\n          var N = degPar.Degree,\n              RADFAC = 3.14159265358979323846 / 180,\n              // Degrees-to-radians conversion factor = PI/180\n          LB2 = Math.LN2,\n              // Dummy variable to avoid re-calculating this value in loop below\n          MDP1 = degPar.Degree + 1,\n              K = new Array(MDP1),\n              pt = new Array(MDP1),\n              qp = new Array(MDP1),\n              temp = new Array(MDP1),\n              // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\n          qPar = new Object(),\n              // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\n          Fxshfr_Par = new Object(),\n              bnd,\n              DBL_EPSILON,\n              df,\n              dx,\n              factor,\n              ff,\n              moduli_max,\n              moduli_min,\n              sc,\n              x,\n              xm,\n              aa,\n              bb,\n              cc,\n              sr,\n              t,\n              u,\n              xxx,\n              j,\n              jj,\n              l,\n              NM1,\n              NN,\n              zerok; // Integer variables\n          // Calculate the machine epsilon and store in the variable DBL_EPSILON.\n          // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\n\n          aa = 1.0;\n\n          do {\n            DBL_EPSILON = aa;\n            aa /= 2;\n            bb = 1.0 + aa;\n          } while (bb > 1.0);\n\n          var LO = Number.MIN_VALUE / DBL_EPSILON,\n              cosr = Math.cos(94.0 * RADFAC),\n              // = -0.069756474\n          sinr = Math.sin(94.0 * RADFAC),\n              // = 0.99756405\n          xx = Math.sqrt(0.5),\n              // = 0.70710678\n          yy = -xx;\n          Fxshfr_Par.NZ = j = 0;\n          Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0; // Remove zeros at the origin, if any\n\n          while (p[N] == 0) {\n            zeror[j] = zeroi[j] = 0;\n            N--;\n            j++;\n          }\n\n          NN = N + 1; // >>>>> Begin Main Loop <<<<<\n\n          while (N >= 1) {\n            // Main loop\n            // Start the algorithm for one zero\n            if (N <= 2) {\n              // Calculate the final zero or pair of zeros\n              if (N < 2) {\n                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\n                zeroi[degPar.Degree - 1] = 0;\n              } else {\n                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n                Quad_ak1(p[0], p[1], p[2], qPar);\n                zeror[degPar.Degree - 2] = qPar.sr;\n                zeroi[degPar.Degree - 2] = qPar.si;\n                zeror[degPar.Degree - 1] = qPar.lr;\n                zeroi[degPar.Degree - 1] = qPar.li;\n              }\n\n              break;\n            } // Find the largest and smallest moduli of the coefficients\n\n\n            moduli_max = 0.0;\n            moduli_min = Number.MAX_VALUE;\n\n            for (i = 0; i < NN; i++) {\n              x = Math.abs(p[i]);\n              if (x > moduli_max) moduli_max = x;\n              if (x != 0 && x < moduli_min) moduli_min = x;\n            } // Scale if there are large or very small coefficients\n            // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\n            // is done to avoid overflow and to avoid undetected underflow interfering with the\n            // convergence criterion.\n            // The factor is a power of the base.\n\n\n            sc = LO / moduli_min;\n\n            if (sc <= 1.0 && moduli_max >= 10 || sc > 1.0 && Number.MAX_VALUE / sc >= moduli_max) {\n              sc = sc == 0 ? Number.MIN_VALUE : sc;\n              l = Math.floor(Math.log(sc) / LB2 + 0.5);\n              factor = Math.pow(2.0, l);\n\n              if (factor != 1.0) {\n                for (i = 0; i < NN; i++) p[i] *= factor;\n              }\n            } // Compute lower bound on moduli of zeros\n\n\n            for (var i = 0; i < NN; i++) pt[i] = Math.abs(p[i]);\n\n            pt[N] = -pt[N];\n            NM1 = N - 1; // Compute upper estimate of bound\n\n            x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\n\n            if (pt[NM1] != 0) {\n              // If Newton step at the origin is better, use it\n              xm = -pt[N] / pt[NM1];\n              x = xm < x ? xm : x;\n            } // Chop the interval (0, x) until ff <= 0\n\n\n            xm = x;\n\n            do {\n              x = xm;\n              xm = 0.1 * x;\n              ff = pt[0];\n\n              for (var i = 1; i < NN; i++) {\n                ff = ff * xm + pt[i];\n              }\n            } while (ff > 0); // End do-while loop\n\n\n            dx = x; // Do Newton iteration until x converges to two decimal places\n\n            do {\n              df = ff = pt[0];\n\n              for (var i = 1; i < N; i++) {\n                ff = x * ff + pt[i];\n                df = x * df + ff;\n              } // End for i\n\n\n              ff = x * ff + pt[N];\n              dx = ff / df;\n              x -= dx;\n            } while (Math.abs(dx / x) > 0.005); // End do-while loop\n\n\n            bnd = x; // Compute the derivative as the initial K polynomial and do 5 steps with no shift\n\n            for (var i = 1; i < N; i++) K[i] = (N - i) * p[i] / N;\n\n            K[0] = p[0];\n            aa = p[N];\n            bb = p[NM1];\n            zerok = K[NM1] == 0 ? 1 : 0;\n\n            for (jj = 0; jj < 5; jj++) {\n              cc = K[NM1];\n\n              if (zerok) {\n                // Use unscaled form of recurrence\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = K[j - 1];\n                } // End for i\n\n\n                K[0] = 0;\n                zerok = K[NM1] == 0 ? 1 : 0;\n              } else {\n                // Used scaled form of recurrence if value of K at 0 is nonzero\n                t = -aa / cc;\n\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = t * K[j - 1] + p[j];\n                } // End for i\n\n\n                K[0] = p[0];\n                zerok = Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0 ? 1 : 0;\n              }\n            } // Save K for restarts with new shifts\n\n\n            for (var i = 0; i < N; i++) temp[i] = K[i]; // Loop to select the quadratic corresponding to each new shift\n\n\n            for (jj = 1; jj <= 20; jj++) {\n              // Quadratic corresponds to a double shift to a non-real point and its\n              // complex conjugate. The point has modulus BND and amplitude rotated\n              // by 94 degrees from the previous shift.\n              xxx = -(sinr * yy) + cosr * xx;\n              yy = sinr * xx + cosr * yy;\n              xx = xxx;\n              sr = bnd * xx;\n              u = -(2.0 * sr); // Second stage calculation, fixed quadratic\n\n              Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\n\n              if (Fxshfr_Par.NZ != 0) {\n                // The second stage jumps directly to one of the third stage iterations and\n                // returns here if successful. Deflate the polynomial, store the zero or\n                // zeros, and return to the main algorithm.\n                j = degPar.Degree - N;\n                zeror[j] = Fxshfr_Par.szr;\n                zeroi[j] = Fxshfr_Par.szi;\n                NN = NN - Fxshfr_Par.NZ;\n                N = NN - 1;\n\n                for (var i = 0; i < NN; i++) p[i] = qp[i];\n\n                if (Fxshfr_Par.NZ != 1) {\n                  zeror[j + 1] = Fxshfr_Par.lzr;\n                  zeroi[j + 1] = Fxshfr_Par.lzi;\n                }\n\n                break;\n              } else {\n                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\n                for (var i = 0; i < N; i++) {\n                  K[i] = temp[i];\n                }\n              }\n            } // Return with failure if no convergence with 20 shifts\n\n\n            if (jj > 20) {\n              degPar.Degree -= N;\n              break;\n            }\n          } // >>>>> End Main Loop <<<<<\n\n\n          return;\n        } //--> End Jenkins-Traub\n\n\n        rpSolve(degreePar, p, zeror, zeroi);\n        var l = zeroi.length; //format the output\n\n        for (i = 0; i < l; i++) {\n          // We round the imaginary part to avoid having something crazy like 5.67e-16.\n          var img = round(zeroi[i], decp + 8),\n              real = round(zeror[i], decp + 8); // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\n          // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \n          // the original otherwise the rounding was worth it.\n\n          real = decp - String(real).length > 2 ? real : zeror[i];\n          var sign = img < 0 ? '-' : ''; // Remove the zeroes\n\n          if (real === 0) {\n            real = '';\n          }\n\n          if (img === 0) {\n            img = '';\n          } // Remove 1 as the multiplier and discard imaginary part if there isn't one.\n\n\n          img = Math.abs(img) === 1 ? sign + 'i' : img ? img + '*i' : '';\n          var num = real && img ? real + '+' + img : real + img;\n          zeror[i] = num.replace(/\\+\\-/g, '-');\n        }\n\n        return zeror;\n      }\n    },\n    roots: function (symbol) {\n      if (symbol.isConstant(true, true)) {\n        return core.Utils.nroots(symbol);\n      }\n\n      var roots = __.proots(symbol).map(function (x) {\n        return _.parse(x);\n      });\n\n      return core.Vector.fromArray(roots);\n    },\n    froot: function (f, guess, dx) {\n      var newtonraph = function (xn) {\n        var mesh = 1e-12,\n            // If the derivative was already provided then don't recalculate.\n        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\n            // If the function was passed in as a function then don't recalculate.\n        fn = f instanceof Function ? f : core.Utils.build(f),\n            max = 10000,\n            done = false,\n            safety = 0;\n\n        while (!done) {\n          var x = xn - fn(xn) / df(xn); //absolute values for both x & xn ensures that we indeed have the radius    \n\n          var r = Math.abs(x) - Math.abs(xn),\n              delta = Math.abs(r);\n          xn = x;\n          if (delta < mesh) done = true;else if (safety > max) {\n            xn = null;\n            done = true;\n          }\n          safety++;\n        }\n\n        return xn;\n      };\n\n      return newtonraph(Number(guess));\n    },\n    quad: function (a, b, c) {\n      var q = function (a, b, c, sign) {\n        return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\n      };\n\n      return [q(a, b, c, 1), q(a, b, c, -1)];\n    },\n    sumProd: function (a, b) {\n      return __.quad(-b, a, -1).map(function (x) {\n        return x.invert();\n      });\n    },\n    coeffs: function (symbol, wrt, coeffs) {\n      wrt = String(wrt);\n      symbol = _.expand(symbol);\n      coeffs = coeffs || [new Symbol(0)]; //we cannot get coeffs for group EX\n\n      if (symbol.group === EX && symbol.contains(wrt, true)) _.error('Unable to get coefficients using expression ' + symbol.toString());\n      var vars = variables(symbol);\n\n      if (vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\n        var a = new Polynomial(symbol).coeffs.map(function (x) {\n          return new Symbol(x);\n        });\n\n        for (var i = 0, l = a.length; i < l; i++) {\n          var coeff = a[i],\n              e = coeffs[i];\n          if (e) coeff = _.add(e, coeff);\n          coeffs[i] = coeff; //transfer it all over\n        }\n      } else {\n        if (!wrt) _.error('Polynomial contains more than one variable. Please specify which variable is to be used!'); //if the variable isn't part of this polynomial then we're looking at x^0\n\n        if (vars.indexOf(wrt) === -1) {\n          coeffs[0] = _.add(symbol, coeffs[0]);\n        } else {\n          coeffs = coeffs || [new Symbol(0)];\n\n          if (symbol.group === CB) {\n            var s = symbol.symbols[wrt];\n            if (!s) _.error('Expression is not a polynomial!');\n            var p = Number(s.power);\n            coeff = _.divide(symbol.clone(), s.clone());\n            if (coeff.contains(wrt, true) || p < 0 || !isInt(p)) _.error('Expression is not a polynomial!');\n            var e = coeffs[p];\n            if (e) coeff = _.add(e, coeff);\n            coeffs[p] = coeff;\n          } else if (symbol.group === CP) {\n            symbol.each(function (x) {\n              __.coeffs(x.clone(), wrt, coeffs);\n            }, true);\n          }\n        }\n      } //fill holes\n\n\n      for (var i = 0, l = coeffs.length; i < l; i++) if (typeof coeffs[i] === 'undefined') coeffs[i] = new Symbol(0);\n\n      return coeffs;\n    },\n\n    /**\r\n     * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n     * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n     * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n     * @param {Symbol} e\r\n     * @param {String} for_variable\r\n     * @param {Array} powers\r\n     * @returns {Array} An array of the powers\r\n     */\n    //assumes you've already verified that it's a polynomial\n    polyPowers: function (e, for_variable, powers) {\n      powers = powers || [];\n      var g = g = e.group;\n\n      if (g === PL && for_variable === e.value) {\n        powers = powers.concat(keys(e.symbols));\n      } else if (g === CP) {\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s];\n          var g = symbol.group,\n              v = symbol.value;\n          if (g === S && for_variable === v) powers.push(symbol.power);else if (g === PL || g === CP) powers = __.polyPowers(symbol, for_variable, powers);else if (g === CB && symbol.contains(for_variable)) {\n            var t = symbol.symbols[for_variable];\n            if (t) powers.push(t.power);\n          } else if (g === N || for_variable !== v) powers.push(0);\n        }\n      } else if (g === CB && e.contains(for_variable)) {\n        powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\n      }\n\n      return core.Utils.arrayUnique(powers).sort();\n    },\n    //The factor object\n    Factor: {\n      //splits the symbol in symbol and constant\n      split: function (symbol) {\n        var c = new Symbol(1); //the constants part\n\n        var s = new Symbol(1); //the symbolic part\n\n        __.Factor.factor(symbol, new Factors()).each(function (x) {\n          var t = _.parse(x);\n\n          if (x.isConstant(true)) {\n            c = _.multiply(c, t);\n          } else {\n            s = _.multiply(s, t);\n          }\n        });\n\n        return [c, s];\n      },\n      mix: function (o, include_negatives) {\n        var factors = keys(o);\n        var l = factors.length;\n        var m = []; //create a row which we'r going to be mixing\n\n        for (var i = 0; i < l; i++) {\n          var factor = factors[i],\n              p = o[factor];\n          var ll = m.length;\n\n          for (var j = 0; j < ll; j++) {\n            var t = m[j] * factor;\n            m.push(t);\n            if (include_negatives) m.push(-t);\n          }\n\n          for (var j = 1; j <= p; j++) m.push(Math.pow(factor, j));\n        }\n\n        return m;\n      },\n      //TODO: this method is to replace common factoring\n      common: function (symbol, factors) {\n        try {\n          if (symbol.group === CP) {\n            //this may have the unfortunate side effect of expanding and factoring again\n            //to only end up with the same result. \n            //TODO: try to avoid this\n            //collect the symbols and sort to have the longest first. Thinking is that the longest terms \n            //has to contain the variable in order for it to be factorable\n            var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\n              return (b.length || 1) - (a.length || 1);\n            });\n\n            var map = {}; //create a map of common factors\n\n            var coeffs = [];\n\n            for (var i = 0; i < symbols.length; i++) {\n              var sym = symbols[i];\n              coeffs.push(sym.multiplier.clone());\n              sym.each(function (x) {\n                var p = Number(x.power); //This check exits since we have a symbolic power.\n                //For the future... think about removing this check and modify for symbolic powers\n\n                if (isNaN(p)) throw new Error('exiting'); //loop through the symbols and lump together common terms\n\n                if (x.value in map) {\n                  if (p < map[x.value][0]) map[x.value][0] = p;\n                  map[x.value][1].push(x);\n                } else map[x.value] = [p, [x]];\n              });\n            } //the factor\n\n\n            var factor = new Symbol(1);\n\n            for (var x in map) {\n              //if this factor is found in all terms since the length of \n              //matching variable terms matches the number of original terms\n              if (map[x][1].length === symbols.length) {\n                //generate a symbol and multiply into the factor\n                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\n              }\n            } //get coefficient factor\n\n\n            var c = core.Math2.QGCD.apply(null, coeffs);\n\n            if (!c.equals(1)) {\n              factors.add(new Symbol(c));\n\n              for (var i = 0; i < symbols.length; i++) {\n                symbols[i].multiplier = symbols[i].multiplier.divide(c);\n              }\n            } //if we actuall found any factors\n\n\n            if (!factor.equals(1)) {\n              factors.add(factor);\n              symbol = new Symbol(0);\n\n              for (var i = 0; i < symbols.length; i++) {\n                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n\n        return symbol;\n      },\n      zeroes: function (symbol, factors) {\n        var exit = function () {\n          throw new core.exceptions.ValueLimitExceededError('Exiting');\n        };\n\n        try {\n          var vars, term, sum, p, e;\n          symbol = _.expand(symbol.clone());\n          e = symbol.toString();\n          vars = variables(symbol);\n          sum = new Symbol(0);\n          var terms = [];\n          var powers = []; //start setting each variable to zero\n\n          for (var i = 0, l = vars.length; i < vars.length; i++) {\n            var subs = {}; //we want to create a subs object with all but the current variable set to zero\n\n            for (var j = 0; j < l; j++) if (i !== j) //make sure we're not looking at the same variable\n              subs[vars[j]] = 0;\n\n            term = _.parse(e, subs);\n            var tp = term.power; //the temporary power has to be an integer as well\n\n            if (!isInt(tp)) exit();\n            terms.push(term);\n            powers.push(term.power);\n          } //get the gcd. This will be the p in (a^n+b^m)^p\n          //if the gcd equals 1 meaning n = m then we need a tie breakder\n\n\n          if (core.Utils.allSame(powers)) {\n            //get p given x number of terms\n            var n_terms = symbol.length; //the number of zeroes determines\n\n            var n_zeroes = terms.length;\n\n            if (n_zeroes === 2) {\n              p = new Frac(powers[0] / (n_terms - 1));\n            }\n\n            if (n_zeroes === 3) {\n              p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\n            }\n            /*\r\n             //get the lowest possible power\r\n             //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n             symbol.each(function(x) {\r\n             if(x.group === CB)\r\n             x.each(function(y) {\r\n             if(!p || y.power.lessThan(p))\r\n             //p = Number(y.power);\r\n             p = y.power;\r\n             });\r\n             else if(!p || x.power.lessThan(p))\r\n             //p = Number(x.power);\r\n             p = x.power;\r\n             });\r\n             */\n\n          } else //p is just the gcd of the powers\n            p = core.Math2.QGCD.apply(null, powers); //if we don't have an integer then exit\n\n\n          if (!isInt(p)) exit(); //build the factor\n\n          for (var i = 0; i < terms.length; i++) {\n            var t = terms[i];\n            var n = t.power.clone().divide(p);\n            t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\n            t.power = p.clone();\n            sum = _.add(sum, t);\n          } //by now we have the factor of zeroes. We'll know if we got it right because \n          //we'll get a remainder of zero each time we divide by it\n\n\n          if (sum.group !== CP) return symbol; //nothing to do\n\n          while (true) {\n            var d = __.div(symbol.clone(), sum.clone());\n\n            if (d[1].equals(0)) {\n              symbol = d[0];\n              factors.add(sum.clone());\n              if (symbol.equals(1)) //we've reached 1 so done.\n                break;\n            } else break;\n          }\n        } catch (e) {}\n\n        ;\n        return symbol;\n      },\n      factor: function (symbol, factors) {\n        // Don't try to factor constants\n        if (symbol.isConstant()) {\n          return core.Math2.factor(symbol);\n        }\n\n        var _symbol = _.parse(symbol);\n\n        var retval = __.Factor._factor(_symbol, factors);\n\n        if (retval.equals(symbol)) {\n          return retval;\n        }\n\n        if (retval.group === CB) {\n          var t = new Symbol(1);\n\n          var p = _.parse(retval.power); //store the multiplier and strip it\n\n\n          var m = _.parse(retval.multiplier);\n\n          retval.toUnitMultiplier();\n          /* \r\n           * NOTE: for sign issues with factor START DEBUGGING HERE\r\n           */\n          //move the sign to t\n\n          if (retval.multiplier.lessThan(0)) {\n            t.negate();\n            retval.negate();\n          }\n\n          retval.each(function (x) {\n            // Related to #566. Since the symbol's group may not have been properly\n            // updated, it's easier to just parse the symbol and have the parser \n            // do the update for us.\n            var factored = _.parse(__.Factor._factor(x));\n\n            if (factored.group === CB) {\n              // Include the multiplier\n              m = _.multiply(m, Symbol.create(factored.multiplier));\n              factored.each(function (y) {\n                var _factored = _.parse(__.Factor._factor(y));\n\n                t = _.multiply(t, _factored);\n\n                if (_factored.group === CB) {\n                  m = _.multiply(m, Symbol.create(_factored.multiplier));\n                }\n              });\n            } else {\n              t = _.multiply(t, factored);\n            }\n          }); //put back the multiplier and power\n\n          retval = _.pow(_.multiply(m, t), p);\n        }\n\n        return retval;\n      },\n      quadFactor: function (symbol, factors) {\n        if (symbol.isPoly() && __.degree(symbol.equals(2))) {\n          //We've  already checked that we're dealing with a polynomial\n          var v = core.Utils.variables(symbol)[0]; //get the variable\n\n          var coeffs = __.coeffs(symbol, v); //factor the lead coefficient\n\n\n          var cf = __.Factor._factor(coeffs[2].clone()); //check if we have factors\n\n\n          if (cf.group === CB) {\n            var symbols = cf.collectSymbols(); //if the factors are greater than 2 we're done so exit\n\n            if (symbols.length > 2) return symbol; //if we have two factors then attempt to factor the polynomial\n            //let the factors be f1 and f1\n            //let the factors be (ax+b)(cx+d)\n            //let the coefficients be c1x^2+c2x+c3\n            //then a(x1)+c(x2)=c2 and x1*x2=c3\n            //we can solve for x1 and x2\n\n            var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\n\n            var b = _.parse(coeffs[1]).negate();\n\n            var a = _.parse(symbols[1]); //solve the system\n\n\n            var root = __.quad(a, b, c).filter(function (x) {\n              if (core.Utils.isInt(x)) return x;\n            }); //if we have one root then find the other one by dividing the constant\n\n\n            if (root.length === 1) {\n              var root1 = root[0];\n\n              var root2 = _.divide(coeffs[0], _.parse(root1));\n\n              if (core.Utils.isInt(root2)) {\n                //we found them both\n                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\n                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\n                symbol = new Symbol(1);\n              }\n            }\n          }\n        }\n\n        return symbol;\n      },\n      cubeFactor: function (symbol, factors) {\n        if (symbol.isComposite()) {\n          var symbols = symbol.collectSymbols(); // The symbol should be in the form of a^3+-b^3. The length\n          // should therefore only be two. If it's any different from this\n          // then we're done\n\n          if (symbols.length === 2) {\n            // Store the signs and then strip them from the symbols\n            var sign_a = symbols[0].sign();\n            var a = symbols[0].clone().abs();\n            var sign_b = symbols[1].sign();\n            var b = symbols[1].clone().abs(); // Check if they're cube\n\n            if (a.isCube() && b.isCube()) {\n              // Keep the negative sign on the right, meaning b is always negative.\n              if (sign_a < sign_b) {\n                // Swap the signs and then the values\n                [sign_a, sign_b] = [sign_b, sign_a];\n                [a, b] = [b, a];\n              } // Get teh roots\n\n\n              var m_root_a = _.parse(a.getNth(3));\n\n              var m_root_b = _.parse(b.getNth(3)); // Remove the cube for both\n\n\n              var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\n\n              var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\n\n              if (sign_a === 1 && sign_b === -1) {\n                // Apply difference of cubes rule\n                factors.add(_.parse(format('(({0})-({1}))', x, y)));\n                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\n                symbol = Symbol(1);\n              } else if (sign_a === 1 && sign_b === 1) {\n                // Apply sum of cubes rule\n                factors.add(_.parse(format('(({0})+({1}))', x, y)));\n                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\n                symbol = Symbol(1);\n              }\n            }\n          }\n        }\n\n        return symbol;\n      },\n      _factor: function (symbol, factors) {\n        //some items cannot be factored any further so return those right away\n        if (symbol.group === FN) {\n          var arg = symbol.args[0];\n\n          if (arg.group === S && arg.isSimple()) {\n            return symbol;\n          }\n        } else if (symbol.group === S && symbol.isSimple()) {\n          return symbol;\n        } // Expand the symbol to get it in a predictable form. If this step\n        // is skipped some factors are missed.\n        //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\n\n\n        if (symbol.group === CP) {\n          symbol.distributeMultiplier(true);\n          var t = new Symbol(0);\n          symbol.each(function (x) {\n            if (x.group === CP && x.power.greaterThan(1) || x.group === CB) x = _.expand(x);\n            t = _.add(t, x);\n          });\n          t.power = symbol.power;\n          symbol = t;\n        }\n\n        if (symbol.group === FN && symbol.fname !== 'sqrt') {\n          symbol = core.Utils.evaluate(symbol);\n        } //make a copy of the symbol to return if something goes wrong\n\n\n        var untouched = symbol.clone();\n\n        try {\n          if (symbol.group === CB) {\n            var p = _.parse(symbol.power);\n\n            var den_array, num_array, den, num, dfact, nfact; //grab the denominator and strip the multiplier and power. Store them in an array\n\n            den_array = __.Simplify.strip(symbol.getDenom());\n            num_array = __.Simplify.strip(symbol.getNum());\n            den = den_array.pop();\n            num = num_array.pop(); //if the numerator equals the symbol then we've hit the simplest form and then we're done\n\n            if (num.equals(symbol)) {\n              return symbol;\n            }\n\n            nfact = __.Factor.factor(num);\n            dfact = __.Factor.factor(den);\n\n            var n = __.Simplify.unstrip(num_array, nfact);\n\n            var d = __.Simplify.unstrip(den_array, dfact);\n\n            var retval = _.divide(n, d);\n\n            return retval;\n          }\n\n          if (symbol.group === S) {\n            return symbol; //absolutely nothing to do\n          }\n\n          if (symbol.isConstant()) {\n            if (symbol.equals(1)) return symbol.clone();\n            var ret = core.Math2.factor(symbol);\n            return ret;\n          }\n\n          var p = symbol.power.clone();\n\n          if (isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\n            var sign = p.sign();\n            symbol.toLinear();\n            factors = factors || new Factors();\n            var map = {};\n            symbol = _.parse(core.Utils.subFunctions(symbol, map));\n\n            if (keys(map).length > 0) {\n              //it might have functions\n              factors.preAdd = function (factor) {\n                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\n\n                return ret;\n              };\n            } //strip the power\n\n\n            if (!symbol.isLinear()) {\n              factors.pFactor = symbol.power.toString();\n              symbol.toLinear();\n            }\n\n            var vars = variables(symbol); //bypass for imaginary. TODO: find a better solution\n\n            if (symbol.isImaginary()) {\n              vars.push(core.Settings.IMAGINARY);\n            }\n\n            var multiVar = vars.length > 1; //minor optimization. Seems to cut factor time by half in some cases.\n\n            if (multiVar) {\n              var all_S = true,\n                  all_unit = true;\n              symbol.each(function (x) {\n                if (x.group !== S) all_S = false;\n                if (!x.multiplier.equals(1)) all_unit = false;\n              });\n\n              if (all_S && all_unit) {\n                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\n              }\n            } //factor the coefficients\n\n\n            var coeff_factors = new Factors();\n            symbol = __.Factor.coeffFactor(symbol, coeff_factors);\n            coeff_factors.each(function (x) {\n              // If the factor was negative but was within a square then it becomes positive\n              if (even(p) && x.lessThan(0)) {\n                x.negate();\n              }\n\n              if (sign < 0) x.invert();\n              factors.add(x);\n            }); //factor the power\n\n            var power_factors = new Factors();\n            symbol = __.Factor.powerFactor(symbol, power_factors);\n            power_factors.each(function (x) {\n              if (sign < 0) x.invert();\n              factors.add(x);\n            });\n\n            if (!multiVar) {\n              //pass in vars[0] for safety\n              var v = vars[0];\n              symbol = __.Factor.squareFree(symbol, factors, v);\n              var t_factors = new Factors();\n              symbol = __.Factor.trialAndError(symbol, t_factors, v); //generate a symbol based off the last factors\n\n              var tf_symbol = t_factors.toSymbol(); //if nothing was factored then return the factors\n\n              if (tf_symbol.equals(untouched)) {\n                return tf_symbol;\n              }\n\n              for (var x in t_factors.factors) {\n                //store the current factor in t_factor\n                var t_factor = t_factors.factors[x];\n                factors.add(_.pow(t_factor, _.parse(p)));\n              } //if we still don't have a factor and it's quadratic then let's just do a quad factor\n\n\n              if (symbol.equals(untouched)) {\n                symbol = __.Factor.quadFactor(symbol, factors);\n              }\n            } else {\n              // Try sum and difference of cubes\n              symbol = __.Factor.cubeFactor(symbol, factors);\n              symbol = __.Factor.mfactor(symbol, factors); //put back the sign of power\n\n              factors.each(function (x) {\n                if (sign < 0) x.power.negate();\n              });\n            } //last minute clean up\n\n\n            symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\n            factors.add(_.pow(symbol, _.parse(p)));\n            var retval = factors.toSymbol();\n            return retval;\n          }\n\n          return symbol;\n        } catch (e) {\n          //no need to stop the show because something went wrong :). Just return the unfactored.\n          return untouched;\n        }\n      },\n      reduce: function (symbol, factors) {\n        if (symbol.group === CP && symbol.length === 2) {\n          var symbols = symbol.collectSymbols().sort(function (a, b) {\n            return b.multiplier - a.multiplier;\n          });\n\n          if (symbols[0].power.equals(symbols[1].power)) {\n            //x^n-a^n\n            var n = _.parse(symbols[0].power),\n                a = symbols[0].clone().toLinear(),\n                b = symbols[1].clone().toLinear(); //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\n\n\n            factors.add(_.add(a.clone(), b.clone())); //flip the sign\n\n            b.negate(); //turn n into a number\n\n            var nn = Number(n); //the remainder\n\n            var result = new Symbol(0);\n\n            for (var i = 1; i <= nn; i++) {\n              var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\n                  bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\n\n              result = _.add(result, _.multiply(aa, bb));\n            }\n\n            return result;\n          }\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * Makes Symbol square free\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @@param {String} variable The variable which is being factored \r\n       * @returns {[Symbol, Factor]}\r\n       */\n      squareFree: function (symbol, factors, variable) {\n        if (symbol.isConstant() || symbol.group === S) return symbol;\n        var poly = new Polynomial(symbol, variable);\n        var sqfr = poly.squareFree();\n        var p = sqfr[2]; //if we found a square then the p entry in the array will be non-unit\n\n        if (p !== 1) {\n          //make sure the remainder doesn't have factors\n          var t = sqfr[1].toSymbol();\n          t.power = t.power.multiply(new Frac(p)); //send the factor to be fatored to be sure it's completely factored\n\n          factors.add(__.Factor.factor(t));\n\n          var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\n\n          return retval;\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * Factors the powers such that the lowest power is a constant\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @returns {[Symbol, Factor]}\r\n       */\n      powerFactor: function (symbol, factors) {\n        //only PL need apply\n        if (symbol.group !== PL || symbol.previousGroup === EX) return symbol;\n        var k = keys(symbol.symbols); //we expect only numeric powers so return all else\n\n        if (!core.Utils.allNumeric(k)) return symbol;\n        var d = core.Utils.arrayMin(k);\n        var retval = new Symbol(0);\n\n        var q = _.parse(symbol.value + '^' + d);\n\n        symbol.each(function (x) {\n          x = _.divide(x, q.clone());\n          retval = _.add(retval, x);\n        });\n        factors.add(q);\n        return retval;\n      },\n\n      /**\r\n       * Removes GCD from coefficients\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @returns {Symbol}\r\n       */\n      coeffFactor: function (symbol, factors) {\n        if (symbol.isComposite()) {\n          var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\n\n          if (!gcd.equals(1)) {\n            symbol.each(function (x) {\n              if (x.isComposite()) {\n                x.each(function (y) {\n                  y.multiplier = y.multiplier.divide(gcd);\n                });\n              } else x.multiplier = x.multiplier.divide(gcd);\n            });\n            symbol.updateHash();\n          } else {\n            // TODO: This should probably go to the prototype\n            var power = function (symbol) {\n              var p;\n\n              if (symbol.group === CB) {\n                p = 0;\n                symbol.each(function (x) {\n                  p += x.power;\n                });\n              } else {\n                p = Number(symbol.power);\n              }\n\n              return p;\n            }; // Factor out negatives from the lead term\n\n\n            var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\n              // Push constants to the back\n              if (a.isConstant(true)) return 1;\n              return b.power - a.power;\n            });\n            var LT = terms[0]; // Check if the LT is indeed the greatest\n\n            if (power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\n              if (LT.multiplier.lessThan(0)) {\n                // Although the symbol should always be linear at this point, remove the negative for squares\n                // to be safe.\n                factors.add(new Symbol(-1));\n                symbol.each(function (x) {\n                  x.negate();\n                }, true);\n              }\n            }\n          }\n\n          if (factors) {\n            factors.add(new Symbol(gcd));\n          }\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * The name says it all :)\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @@param {String} variable \r\n       * @returns {Symbol}\r\n       */\n      trialAndError: function (symbol, factors, variable) {\n        var untouched = symbol.clone();\n\n        try {\n          // At temp holder for the factors. If all goes well then\n          // they'll be moved to the actual factors.\n          var factor_array = [];\n          if (symbol.isConstant() || symbol.group === S) return symbol;\n\n          var poly = new Polynomial(symbol, variable),\n              cnst = poly.coeffs[0],\n              cfactors = core.Math2.ifactor(cnst),\n              roots = __.proots(symbol);\n\n          for (var i = 0; i < roots.length; i++) {\n            var r = roots[i],\n                p = 1;\n\n            if (!isNaN(r)) {\n              //if it's a number\n              for (var x in cfactors) {\n                //check it's raised to a power\n                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\n\n                if (isInt(n)) {\n                  r = x; //x must be the root since n gave us a whole\n\n                  p = n;\n                  break;\n                }\n              }\n\n              var root = new Frac(r),\n                  terms = [new Frac(root.num).negate()];\n              terms[p] = new Frac(root.den); //convert to Frac. The den is coeff of LT and the num is coeff of constant\n\n              var div = Polynomial.fromArray(terms, poly.variable).fill(),\n                  t = poly.divide(div);\n\n              if (t[1].equalsNumber(0)) {\n                //if it's zero we have a root and divide it out\n                poly = t[0]; // factors.add(div.toSymbol());\n\n                factor_array.push(div.toSymbol());\n              }\n            }\n          }\n\n          if (!poly.equalsNumber(1)) {\n            poly = __.Factor.search(poly, factors);\n          } // Move the factors over since all went well.\n\n\n          factor_array.forEach(function (x) {\n            factors.add(x);\n          });\n          return poly.toSymbol();\n        } catch (e) {\n          return untouched;\n        }\n      },\n      search: function (poly, factors, base) {\n        base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\n\n        var v = poly.variable; //the polynmial variable name\n\n        /**\r\n         * Attempt to remove a root by division given a number by first creating\r\n         * a polynomial fromt he given information\r\n         * @param {int} c1 - coeffient for the constant\r\n         * @param {int} c2 - coefficient for the LT\r\n         * @param {int} n - the number to be used to construct the polynomial\r\n         * @param {int} p - the power at which to create the polynomial\r\n         * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n         */\n\n        var check = function (c1, c2, n, p) {\n          var candidate = Polynomial.fit(c1, c2, n, base, p, v);\n\n          if (candidate && candidate.coeffs.length > 1) {\n            var t = poly.divide(candidate);\n\n            if (t[1].equalsNumber(0)) {\n              factors.add(candidate.toSymbol());\n              return [t[0], candidate];\n            }\n          }\n\n          return null;\n        };\n\n        var cnst = poly.coeffs[0];\n        var cfactors = core.Math2.ifactor(cnst);\n        var lc = poly.lc();\n        var ltfactors = core.Math2.ifactor(lc);\n        var subbed = poly.sub(base);\n        var isubbed = core.Math2.ifactor(subbed);\n\n        var nfactors = __.Factor.mix(isubbed, subbed < 0);\n\n        var cp = Math.ceil(poly.coeffs.length / 2);\n        var lc_is_neg = lc.lessThan(0);\n        var cnst_is_neg = cnst.lessThan(0);\n        ltfactors['1'] = 1;\n        cfactors['1'] = 1;\n\n        while (cp--) {\n          for (var x in ltfactors) {\n            for (var y in cfactors) {\n              for (var i = 0; i < nfactors.length; i++) {\n                var factor_found = check(x, y, nfactors[i], cp);\n\n                if (factor_found) {\n                  poly = factor_found[0];\n                  if (!core.Utils.isPrime(poly.sub(base))) poly = __.Factor.search(poly, factors);\n                  return poly;\n                } else if (!factor_found) {\n                  if (lc_is_neg && cnst_is_neg) factor_found = check(-x, -y, nfactors[i], cp);else if (lc_is_neg) factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\n                  else if (cnst_is_neg) factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\n                }\n              }\n            }\n          }\n        }\n\n        return poly;\n      },\n\n      /**\r\n       * Equivalent of square free factor for multivariate polynomials\r\n       * @param {type} symbol\r\n       * @param {type} factors\r\n       * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n       */\n      mSqfrFactor: function (symbol, factors) {\n        if (symbol.group !== FN) {\n          var vars = variables(symbol).reverse(); // Loop through all the variable and remove the partial derivatives\n\n          for (var i = 0; i < vars.length; i++) {\n            do {\n              if (vars[i] === symbol.value) {\n                //the derivative tells us nothing since this symbol is already the factor\n                factors.add(symbol);\n                symbol = new Symbol(1);\n                continue;\n              }\n\n              var diff = core.Calculus.diff(symbol, vars[i]);\n\n              var d = __.Factor.coeffFactor(diff);\n\n              if (d.equals(0)) break; //trial division to see if factors have whole numbers. \n              //This can be optimized by stopping as soon as can_divide is false\n              //this will also need utilize big number at some point\n\n              var can_divide = true;\n\n              if (d.isConstant() && symbol.isComposite()) {\n                //check the coefficients\n                symbol.each(function (x) {\n                  if (x.multiplier % d !== 0) can_divide = false;\n                }, true);\n              } //if we can divide then do so\n\n\n              if (can_divide) {\n                var div = __.div(symbol, d.clone()),\n                    is_factor = div[1].equals(0);\n\n                if (div[0].isConstant()) {\n                  factors.add(div[0]);\n                  break;\n                }\n              } else is_factor = false;\n\n              if (is_factor) {\n                factors.add(div[0]);\n                symbol = d;\n              }\n            } while (is_factor);\n          }\n        }\n\n        return symbol;\n      },\n      //difference of squares factorization\n      sqdiff: function (symbol, factors) {\n        if (symbol.isConstant('all')) {\n          // Nothing to do\n          return symbol;\n        }\n\n        try {\n          var remove_square = function (x) {\n            return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\n              return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\n            }, true);\n          };\n\n          var separated = core.Utils.separate(symbol.clone());\n          var obj_array = []; //get the unique variables\n\n          for (var x in separated) {\n            if (x !== 'constants') {\n              obj_array.push(separated[x]);\n            }\n          }\n\n          obj_array.sort(function (a, b) {\n            return b.power - a.power;\n          }); //if we have the same number of variables as unique variables then we can apply the difference of squares\n\n          if (obj_array.length === 2) {\n            var a, b;\n            a = obj_array.pop();\n            b = obj_array.pop();\n\n            if (even(a.power) && even(b.power) && a.sign() === b.sign() && a.group === S && b.group === S) {\n              throw new Error('Unable to factor');\n            }\n\n            ;\n\n            if (a.isComposite() && b.power.equals(2)) {\n              //remove the square from b\n              b = remove_square(b);\n\n              var f = __.Factor.factor(_.add(a, separated.constants));\n\n              if (f.power.equals(2)) {\n                f.toLinear();\n                factors.add(_.subtract(f.clone(), b.clone()));\n                factors.add(_.add(f, b));\n                symbol = new Symbol(1);\n              }\n            } else {\n              a = a.powSimp();\n              b = b.powSimp();\n\n              if ((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\n                if (a.multiplier.lessThan(0)) {\n                  var t = b;\n                  b = a;\n                  a = t;\n                }\n\n                if (a.multiplier.greaterThan(0)) {\n                  a = remove_square(a);\n                  b = remove_square(b);\n                }\n\n                factors.add(_.subtract(a.clone(), b.clone()));\n                factors.add(_.add(a, b));\n                symbol = new Symbol(1);\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n\n        return symbol;\n      },\n      //factoring for multivariate\n      mfactor: function (symbol, factors) {\n        if (symbol.group === FN) {\n          if (symbol.fname === 'sqrt') {\n            var factors2 = new Factors(),\n                arg = __.Factor.common(symbol.args[0].clone(), factors2);\n\n            arg = __.Factor.coeffFactor(arg, factors2);\n            symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\n            factors2.each(function (x) {\n              symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\n            });\n          } else factors.add(symbol);\n        } else {\n          //square free factorization\n          symbol = __.Factor.mSqfrFactor(symbol, factors); //try factor out common factors\n          //symbol = __.Factor.common(symbol, factors);\n\n          var vars = variables(symbol),\n              symbols = symbol.collectSymbols().map(function (x) {\n            return Symbol.unwrapSQRT(x);\n          }),\n              sorted = {},\n              maxes = {},\n              l = vars.length,\n              n = symbols.length; //take all the variables in the symbol and organize by variable name\n          //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\n\n          for (var i = 0; i < l; i++) {\n            var v = vars[i];\n            sorted[v] = new Symbol(0);\n\n            for (var j = 0; j < n; j++) {\n              var s = symbols[j];\n\n              if (s.contains(v)) {\n                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\n                if (!maxes[v] || p < maxes[v]) maxes[v] = p;\n                sorted[v] = _.add(sorted[v], s.clone());\n              }\n            }\n          }\n\n          for (var x in sorted) {\n            var r = _.parse(x + '^' + maxes[x]);\n\n            var div = _.divide(sorted[x], r);\n\n            var new_factor = _.expand(div);\n\n            if (new_factor.equals(1)) break; //why divide by one. Just move \n\n            var divided = __.div(symbol.clone(), new_factor);\n\n            if (divided[0].equals(0)) {\n              //cant factor anymore\n              break;\n            } // We potentially ended up with fractional coefficients when the\n            // trial division was performed. We need to remove \n            // This check will more then likely become superfluous with improvements\n            // to polynomial division\n\n\n            if (divided[1].equals(0)) {\n              var has_fractions = false;\n              divided[0].each(function (x) {\n                if (!isInt(x.multiplier)) {\n                  has_fractions = true;\n                }\n              }); // The factor isn't really a factor and needs to be put back\n\n              if (has_fractions) {\n                divided[1] = _.expand(_.multiply(divided[1], new_factor)); // Since the new factor is not just one, we exit.\n\n                break;\n              }\n            }\n\n            var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\n\n            if (divided[1].equals(0) && !neg_numeric_factor) {\n              //we found at least one factor\n              //factors.add(new_factor);\n              var d = __.div(symbol.clone(), divided[0].clone());\n\n              var r = d[0]; // Nothing left to do since we didn't get a reduction\n\n              if (r.equals(0)) {\n                return symbol;\n              }\n\n              symbol = d[1]; //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\n              //and we just return the symbol;\n              //If r equals zero then there's nothing left to do so we're done\n\n              if (r.equals(-1) && !symbol.equals(0)) return symbol;\n              var factor = divided[0];\n\n              if (symbol.equals(factor)) {\n                var rem = __.Factor.reduce(factor, factors);\n\n                if (!symbol.equals(rem)) return __.Factor.mfactor(rem, factors);\n                return rem;\n              } else {\n                factors.add(factor); //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\n\n                if (symbol.equals(0)) return r;\n              }\n\n              if (r.isConstant('all')) {\n                factors.add(r);\n                return r;\n              }\n\n              return __.Factor.mfactor(r, factors);\n            }\n          }\n        } //difference of squares factorization\n\n\n        symbol = __.Factor.sqdiff(symbol, factors); //factors by fishing for zeroes\n\n        symbol = __.Factor.zeroes(symbol, factors);\n        return symbol;\n      }\n    },\n\n    /**\r\n     * Checks to see if a set of \"equations\" is linear. \r\n     * @param {type} set\r\n     * @returns {Boolean}\r\n     */\n    allLinear: function (set) {\n      var l = set.length;\n\n      for (var i = 0; i < l; i++) {\n        if (!__.isLinear(set[i])) return false;\n      }\n\n      return true;\n    },\n\n    /*\r\n     * Checks to see if the \"equation\" is linear\r\n     * @param {Symbol} e\r\n     * @returns {boolean}\r\n     */\n    isLinear: function (e) {\n      var status = false,\n          g = e.group;\n\n      if (g === PL || g === CP) {\n        status = true;\n\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s],\n              sg = symbol.group;\n\n          if (sg === FN || sg === EX) {\n            status = false;\n          }\n\n          if (sg === CB) {\n            //needs further checking since it might be imaginary\n            status = variables(symbol).length === 1;\n          } else {\n            if (sg === PL || sg === CP) status = __.isLinear(symbol);else {\n              if (symbol.group !== N && symbol.power.toString() !== '1') {\n                status = false;\n                break;\n              }\n            }\n          }\n        }\n      } else if (g === S && e.power === 1) status = true;\n\n      return status;\n    },\n    gcd: function () {\n      var args;\n      if (arguments.length === 1 && arguments[0] instanceof core.Vector) args = arguments[0].elements;else args = core.Utils.arguments2Array(arguments); //short-circuit early\n\n      if (args.length === 0) return new Symbol(1);else if (args.length === 1) return args[0];\n      var appeared = [],\n          evaluate = false;\n\n      for (var i = 0; i < args.length; i++) {\n        if (args[i].group === FN && args[i].fname === 'gcd') {\n          //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\n          args = args.concat(arguments[i].args); //do not keep gcd in args\n\n          args.splice(i, 1);\n        } else {\n          //Look if there are any common variables such that\n          //gcd(a,b) => gcd(a,b); gcd(a,a) => a\n          var vars = variables(args[i]);\n\n          if (core.Utils.haveIntersection(vars, appeared)) {\n            //Ok, there are common variables\n            evaluate = true;\n            break;\n          } else appeared = appeared.concat(vars);\n        }\n      } //appeared.length is 0 when all arguments are group N\n\n\n      if (evaluate || appeared.length === 0) {\n        //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\n        if (args.every(function (symbol) {\n          return symbol.getDenom().equals(1);\n        })) {\n          var aggregate = args[0];\n\n          for (var i = 1; i < args.length; i++) {\n            aggregate = __.gcd_(args[i], aggregate);\n          }\n\n          return aggregate;\n        } else {\n          //gcd_ cannot handle denominators correctly\n          return _.divide(__.gcd.apply(null, args.map(function (symbol) {\n            return symbol.getNum();\n          })), __.lcm.apply(null, args.map(function (symbol) {\n            return symbol.getDenom();\n          })));\n        }\n      } else return _.symfunction('gcd', args);\n    },\n    gcd_: function (a, b) {\n      if (a.group === FN || a.group === P) a = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(a);\n      });\n      if (b.group === FN) b = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(b);\n      });\n\n      if (a.isConstant() && b.isConstant()) {\n        // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\n        return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\n      }\n\n      var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\n\n      a = _.multiply(a.clone(), den.clone());\n      b = _.multiply(b.clone(), den.clone()); //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\n\n      a = _.expand(a);\n      b = _.expand(b);\n\n      if (a.group === CB || b.group === CB) {\n        var q = _.divide(a.clone(), b.clone()); //get the quotient\n\n\n        var t = _.multiply(b.clone(), q.getDenom().invert()); //multiply by the denominator\n        //if they have a common factor then the result will not equal one \n\n\n        if (!t.equals(1)) return t;\n      } //just take the gcd of each component when either of them is in group EX\n\n\n      if (a.group === EX || b.group === EX) {\n        var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\n\n        var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\n\n        var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\n\n        return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\n      }\n\n      if (a.length < b.length) {\n        //swap'm\n        var t = a;\n        a = b;\n        b = t;\n      }\n\n      var vars_a = variables(a),\n          vars_b = variables(b);\n\n      if (vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0] || vars_a.length === 1 && vars_b.length === 0 || vars_a.length === 0 && vars_b.length === 1) {\n        a = new Polynomial(a);\n        b = new Polynomial(b);\n        return _.divide(a.gcd(b).toSymbol(), den);\n      } else {\n        //get the gcd of the multipiers\n        //get rid of gcd in coeffs\n        var multipliers = [];\n        a.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        b.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        var T;\n\n        while (!b.equals(0)) {\n          var t = b.clone();\n          a = a.clone();\n          T = __.div(a, t);\n          b = T[1];\n\n          if (T[0].equals(0)) {\n            //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\n            return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\n          }\n\n          a = t;\n        }\n\n        var gcd = core.Math2.QGCD.apply(undefined, multipliers);\n\n        if (!gcd.equals(1)) {\n          a.each(function (x) {\n            x.multiplier = x.multiplier.divide(gcd);\n          });\n        } //return symbolic function for gcd in indeterminate form\n\n\n        if (a.equals(1) && !a.isConstant() && !b.isConstant()) return _.divide(_.symfunction('gcd', arguments), den);\n        return _.divide(a, den);\n      }\n    },\n    lcm: function () {\n      //https://math.stackexchange.com/a/319310\n      //generalization of the 2-variable formula of lcm\n      var args;\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof core.Vector) args = arguments[0].elements;else _.error('lcm expects either 1 vector or 2 or more arguments');\n      } else args = core.Utils.arguments2Array(arguments); //product of all arguments\n      //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n\n      var numer = args.reduce(function (prev, curr) {\n        return _.multiply(prev, curr.clone());\n      }, new Symbol(1)); //gcd of complementary terms\n\n      var denom_args = //https://stackoverflow.com/a/18223072\n      //take all complementary terms, e.g.\n      //[a,b,c] => [a*b, b*c, a*c]\n      //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\n      function (input, size) {\n        size = Number(size);\n        var results = [],\n            result,\n            mask,\n            i,\n            total = Math.pow(2, input.length);\n\n        for (mask = size; mask < total; mask++) {\n          result = [];\n          i = input.length - 1;\n\n          do {\n            if ((mask & 1 << i) !== 0) {\n              result.push(input[i]);\n            }\n          } while (i--);\n\n          if (result.length === size) {\n            results.push(result);\n          }\n        }\n\n        return results; //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n      }(arguments, arguments.length - 1).map(function (x) {\n        return x.reduce(function (prev, curr) {\n          return _.multiply(prev, curr.clone());\n        }, new Symbol(1));\n      });\n\n      var denom; //don't eat the gcd term if all arguments are symbols\n\n      if (args.every(function (x) {\n        return core.Utils.isVariableSymbol(x);\n      })) denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));else denom = __.gcd.apply(null, denom_args); //divide product of all arguments by gcd of complementary terms\n\n      var div = _.divide(numer, denom);\n\n      return div;\n    },\n\n    /**\r\n     * Divides one expression by another\r\n     * @param {Symbol} symbol1\r\n     * @param {Symbol} symbol2\r\n     * @returns {Array}\r\n     */\n    divide: function (symbol1, symbol2) {\n      var result, remainder, factored, den;\n      factored = core.Algebra.Factor.factor(symbol1.clone());\n      den = factored.getDenom();\n\n      if (!den.isConstant('all')) {\n        symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\n      } else //reset the denominator since we're not dividing by it anymore\n        den = new Symbol(1);\n\n      result = __.div(symbol1, symbol2);\n      remainder = _.divide(result[1], symbol2);\n      return _.divide(_.add(result[0], remainder), den);\n    },\n    div: function (symbol1, symbol2) {\n      // If all else fails then assume that division failed with\n      // a remainder of zero and the original quotient\n      var fail = [new Symbol(0), symbol1.clone()];\n\n      try {\n        // Division by constants\n        if (symbol2.isConstant('all')) {\n          symbol1.each(function (x) {\n            x.multiplier = x.multiplier.divide(symbol2.multiplier);\n          });\n          return [symbol1, new Symbol(0)];\n        } // So that factorized symbols don't affect the result\n\n\n        symbol1 = _.expand(symbol1);\n        symbol2 = _.expand(symbol2); // Special case. May need revisiting\n\n        if (symbol1.group === S && symbol2.group === CP) {\n          var x = symbol1.value;\n          var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\n\n          if (symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\n            var k = Symbol.create(symbol1.multiplier);\n            return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\n          }\n        }\n\n        if (symbol1.group === S && symbol2.group === S) {\n          var r = _.divide(symbol1.clone(), symbol2.clone());\n\n          if (r.isConstant()) //we have a whole\n            return [r, new Symbol(0)];\n          return [new Symbol(0), symbol1.clone()];\n        }\n\n        var symbol1_has_func = symbol1.hasFunc(),\n            symbol2_has_func = symbol2.hasFunc(),\n            parse_funcs = false; //substitute out functions so we can treat them as regular variables\n\n        if (symbol1_has_func || symbol2_has_func) {\n          parse_funcs = true;\n\n          var map = {},\n              symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\n              symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\n              subs = core.Utils.getFunctionsSubs(map);\n        } //get a list of the variables\n\n\n        var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\n            quot,\n            rem; //treat imaginary numbers as variables\n\n        if (symbol1.isImaginary() || symbol2.isImaginary()) {\n          vars.push(core.Settings.IMAGINARY);\n        }\n\n        if (vars.length === 1) {\n          var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\n          quot = q[0].toSymbol();\n          rem = q[1].toSymbol();\n        } else {\n          vars.push(CONST_HASH); //this is for the numbers\n\n          var reconvert = function (arr) {\n            var symbol = new Symbol(0);\n\n            for (var i = 0; i < arr.length; i++) {\n              var x = arr[i].toSymbol();\n              symbol = _.add(symbol, x);\n            }\n\n            return symbol;\n          }; // Silly Martin. This is why you document. I don't remember now\n\n\n          var get_unique_max = function (term, any) {\n            var max = Math.max.apply(null, term.terms),\n                count = 0,\n                idx;\n\n            if (!any) {\n              for (var i = 0; i < term.terms.length; i++) {\n                if (term.terms[i].equals(max)) {\n                  idx = i;\n                  count++;\n                }\n\n                if (count > 1) return;\n              }\n            }\n\n            if (any) {\n              for (i = 0; i < term.terms.length; i++) if (term.terms[i].equals(max)) {\n                idx = i;\n                break;\n              }\n            }\n\n            return [max, idx, term];\n          }; // Tries to find an LT in the dividend that will satisfy division\n\n\n          var get_det = function (s, lookat) {\n            lookat = lookat || 0;\n            var det = s[lookat],\n                l = s.length;\n            if (!det) return; //eliminate the first term if it doesn't apply\n\n            var umax = get_unique_max(det);\n\n            for (var i = lookat + 1; i < l; i++) {\n              var term = s[i],\n                  is_equal = det.sum.equals(term.sum);\n\n              if (!is_equal && umax) {\n                break;\n              }\n\n              if (is_equal) {\n                // Check the differences of their maxes. The one with the biggest difference governs\n                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\n                var max1,\n                    max2,\n                    idx1,\n                    idx2,\n                    l2 = det.terms.length;\n\n                for (var j = 0; j < l2; j++) {\n                  var item1 = det.terms[j],\n                      item2 = term.terms[j];\n\n                  if (typeof max1 === 'undefined' || item1.greaterThan(max1)) {\n                    max1 = item1;\n                    idx1 = j;\n                  }\n\n                  if (typeof max2 === 'undefined' || item2.greaterThan(max2)) {\n                    max2 = item2;\n                    idx2 = j;\n                  }\n                } //check their differences\n\n\n                var d1 = max1.subtract(term.terms[idx1]),\n                    d2 = max2.subtract(det.terms[idx2]);\n\n                if (d2 > d1) {\n                  umax = [max2, idx2, term];\n                  break;\n                }\n\n                if (d1 > d2) {\n                  umax = [max1, idx1, det];\n                  break;\n                }\n              } else {\n                //check if it's a suitable pick to determine the order\n                umax = get_unique_max(term); //if(umax) return umax;\n\n                if (umax) break;\n              }\n\n              umax = get_unique_max(term); //calculate a new unique max\n            } //if still no umax then any will do since we have a tie\n\n\n            if (!umax) return get_unique_max(s[0], true);\n            var e, idx;\n\n            for (var i = 0; i < s2.length; i++) {\n              var cterm = s2[i].terms; //confirm that this is a good match for the denominator\n\n              idx = umax[1];\n              if (idx === cterm.length - 1) return;\n              e = cterm[idx];\n              if (!e.equals(0)) break;\n            }\n\n            if (e.equals(0)) return get_det(s, ++lookat); //look at the next term\n\n            return umax;\n          };\n\n          var t_map = core.Utils.toMapObj(vars);\n\n          var init_sort = function (a, b) {\n            return b.sum.subtract(a.sum);\n          };\n\n          var is_larger = function (a, b) {\n            if (!a || !b) return false; //it's empty so...\n\n            for (var i = 0; i < a.terms.length; i++) {\n              if (a.terms[i].lessThan(b.terms[i])) return false;\n            }\n\n            return true;\n          };\n\n          var s1 = symbol1.tBase(t_map).sort(init_sort),\n              s2 = symbol2.tBase(t_map).sort(init_sort);\n          var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\n\n          var det = get_det(target); //we'll begin by assuming that this will let us know which term \n\n          var quotient = [];\n\n          if (det) {\n            var lead_var = det[1];\n\n            var can_divide = function (a, b) {\n              if (a[0].sum.equals(b[0].sum)) return a.length >= b.length;\n              return true;\n            };\n\n            var try_better_lead_var = function (s1, s2, lead_var) {\n              var checked = [];\n\n              for (var i = 0; i < s1.length; i++) {\n                var t = s1[i];\n\n                for (var j = 0; j < t.terms.length; j++) {\n                  var cf = checked[j],\n                      tt = t.terms[j];\n                  if (i === 0) checked[j] = tt; //add the terms for the first one\n                  else if (cf && !cf.equals(tt)) checked[j] = undefined;\n                }\n              }\n\n              for (var i = 0; i < checked.length; i++) {\n                var t = checked[i];\n                if (t && !t.equals(0)) return i;\n              }\n\n              return lead_var;\n            };\n\n            var sf = function (a, b) {\n              var l1 = a.len(),\n                  l2 = b.len();\n              var blv = b.terms[lead_var],\n                  alv = a.terms[lead_var];\n              if (l2 > l1 && blv.greaterThan(alv)) return l2 - l1;\n              return blv.subtract(alv);\n            }; //check to see if there's a better lead_var\n\n\n            lead_var = try_better_lead_var(s1, s2, lead_var); //reorder both according to the max power\n\n            s1.sort(sf); //sort them both according to the leading variable power\n\n            s2.sort(sf); //try to adjust if den is larger\n\n            var fdt = s2[0],\n                fnt = s1[0];\n            var den = new MVTerm(new Frac(1), [], fnt.map);\n\n            if (fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\n              for (var i = 0; i < fnt.terms.length; i++) {\n                var d = fdt.terms[i].subtract(fnt.terms[i]);\n\n                if (!d.equals(0)) {\n                  var nd = d.add(new Frac(1));\n                  den.terms[i] = d;\n\n                  for (var j = 0; j < s1.length; j++) {\n                    s1[j].terms[i] = s1[j].terms[i].add(nd);\n                  }\n                } else den.terms[i] = new Frac(0);\n              }\n            }\n\n            var dividend_larger = is_larger(s1[0], s2[0]);\n            var safety = 0;\n            var max = 200;\n\n            while (dividend_larger && can_divide(s1, s2)) {\n              if (safety++ > max) {\n                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\n              }\n\n              var q = s1[0].divide(s2[0]);\n              quotient.push(q); //add what's divided to the quotient\n\n              s1.shift(); //the first one is guaranteed to be gone so remove from dividend\n\n              for (var i = 1; i < s2.length; i++) {\n                //loop through the denominator\n                var t = s2[i].multiply(q).generateImage(),\n                    l2 = s1.length; //if we're subtracting from 0\n\n                if (l2 === 0) {\n                  t.coeff = t.coeff.neg();\n                  s1.push(t);\n                  s1.sort(sf);\n                }\n\n                for (var j = 0; j < l2; j++) {\n                  var cur = s1[j];\n\n                  if (cur.getImg() === t.getImg()) {\n                    cur.coeff = cur.coeff.subtract(t.coeff);\n\n                    if (cur.coeff.equals(0)) {\n                      core.Utils.remove(s1, j);\n                      j--; //adjust the iterator\n                    }\n\n                    break;\n                  }\n\n                  if (j === l2 - 1) {\n                    t.coeff = t.coeff.neg();\n                    s1.push(t);\n                    s1.sort(sf);\n                  }\n                }\n              }\n\n              dividend_larger = is_larger(s1[0], s2[0]);\n\n              if (!dividend_larger && s1.length >= s2.length) {\n                //One more try since there might be a terms that is larger than the LT of the divisor\n                for (var i = 1; i < s1.length; i++) {\n                  dividend_larger = is_larger(s1[i], s2[0]);\n\n                  if (dividend_larger) {\n                    //take it from its current position and move it to the front\n                    s1.unshift(core.Utils.remove(s1, i));\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          quot = reconvert(quotient);\n          rem = reconvert(s1);\n\n          if (typeof den !== 'undefined') {\n            den = den.toSymbol();\n            quot = _.divide(quot, den.clone());\n            rem = _.divide(rem, den);\n          }\n        } //put back the functions\n\n\n        if (parse_funcs) {\n          quot = _.parse(quot.text(), subs);\n          rem = _.parse(rem.text(), subs);\n        }\n\n        return [quot, rem];\n      } catch (e) {\n        return fail;\n      }\n    },\n    line: function (v1, v2, x) {\n      if (core.Utils.isArray(v1)) v1 = core.Utils.convertToVector(v1);\n      if (core.Utils.isArray(v2)) v2 = core.Utils.convertToVector(v2);\n      x = _.parse(x || 'x');\n      if (!core.Utils.isVector(v1) || !core.Utils.isVector(v2)) _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\n\n      var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\n          dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\n          m = _.divide(dy, dx),\n          a = _.multiply(x, m.clone()),\n          b = _.multiply(v1.e(1).clone(), m);\n\n      return _.add(_.subtract(a, b), v1.e(2).clone());\n    },\n    PartFrac: {\n      createTemplate: function (den, denom_factors, f_array, v) {\n        //clean up the denominator function by factors so it reduces nicely\n        den = __.Factor.factor(den); //clean up factors. This is so inefficient but factors are wrapped in parens for safety\n\n        den.each(function (x, key) {\n          if (x.group === FN && x.fname === '' && x.args[0].group === S) {\n            var y = x.args[0];\n\n            if (this.symbols) {\n              delete this.symbols[key];\n              this.symbols[y.value] = y;\n            } else {\n              den = x.args[0];\n            }\n          }\n        });\n        var factors, factors_vec, f, p, deg, degrees, m;\n        factors = denom_factors.collectFactors();\n        factors_vec = []; //a vector for the template\n\n        degrees = [];\n        m = new Symbol(1);\n\n        for (var i = 0; i < factors.length; i++) {\n          //loop through the factors\n          var factor = Symbol.unwrapPARENS(factors[i]); //if in he for P^n where P is polynomial and n = integer\n\n          if (factor.power.greaterThan(1)) {\n            p = Number(factor.power);\n            f = factor.clone().toLinear(); //remove the power so we have only the function\n\n            deg = Number(__.degree(f, v)); //get the degree of f\n            //expand the factor\n\n            for (var j = 0; j < p; j++) {\n              var efactor = _.pow(f.clone(), new Symbol(j + 1));\n\n              f_array.push(efactor.clone());\n\n              var d = _.divide(den.clone(), efactor.clone());\n\n              degrees.push(deg);\n              factors_vec.push(d);\n            }\n          }\n          /*\r\n           Possible bug.\r\n           Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n           else if(factor.isConstant('all')) {\r\n           m = _.multiply(m, factor);\r\n           }\r\n           */\n          else {\n              //get the degree of the factor so we tack it on tot he factor. This should probably be an array\n              //but for now we note it on the symbol\n              deg = Number(__.degree(factor, v));\n              f_array.push(factor);\n\n              var d = _.divide(den.clone(), factor.clone());\n\n              d = _.expand(Symbol.unwrapPARENS(d));\n              degrees.push(deg);\n              factors_vec.push(d);\n            }\n        } //put back the constant\n\n\n        f_array = f_array.map(function (x) {\n          return _.multiply(x, m.clone());\n        });\n        return [f_array, factors_vec, degrees];\n      },\n      partfrac: function (symbol, v, as_array) {\n        var vars = variables(symbol);\n        v = v || _.parse(vars[0]); //make wrt optional and assume first variable\n\n        try {\n          var num, den, factors, tfactors, ofactors, nterms, degrees, dterms, max, M, c, powers, div, r, factors_vec, ks, template, tfactors;\n          num = _.expand(symbol.getNum());\n          den = _.expand(symbol.getDenom().toUnitMultiplier()); //move the entire multipier to the numerator\n\n          num.multiplier = symbol.multiplier; //we only have a meaningful change if n factors > 1. This means that\n          //the returned group will be a CB\n          //collect the terms wrt the x\n\n          nterms = num.groupTerms(v); //divide out wholes if top is larger\n\n          if (Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\n            div = __.div(num.clone(), _.expand(den.clone()));\n            r = div[0]; //remove the wholes\n\n            num = div[1]; //work with the remainder\n\n            nterms = num.groupTerms(v); //recalculate the nterms\n          } else r = new Symbol(0);\n\n          if (Number(__.degree(den, v)) === 1) {\n            var q = _.divide(num, den);\n\n            if (as_array) return [r, q];\n            return _.add(r, q);\n          } //first factor the denominator. This means that the strength of this\n          //algorithm depends on how well we can factor the denominator. \n\n\n          ofactors = __.Factor.factor(den); //create the template. This method will create the template for solving \n          //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\n\n          template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\n          tfactors = template[0]; //grab the factors\n\n          factors_vec = template[1]; //grab the factor vectors\n\n          degrees = template[2]; //grab the degrees\n          //make note of the powers of each term\n\n          powers = [nterms.length]; //create the dterms vector\n\n          dterms = [];\n          factors = [];\n          ks = [];\n          var factor, deg;\n          factors_vec.map(function (x, idx) {\n            factor = tfactors[idx];\n            deg = degrees[idx];\n\n            for (var i = 0; i < deg; i++) {\n              factors.push(factor.clone());\n              var k = Symbol.create(v, i);\n\n              var t = _.expand(_.multiply(x, k.clone())).groupTerms(v); //make a note of the power which corresponds to the length of the array\n\n\n              var p = t.length;\n              powers.push(p);\n              dterms.push(t);\n              ks.push(k.clone());\n            }\n          }); //get the max power\n\n          max = core.Utils.arrayMax(powers); //fill the holes and create a matrix\n\n          c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose(); //for each of the factors we do the same\n\n          M = new core.Matrix();\n\n          for (var i = 0; i < dterms.length; i++) {\n            M.elements.push(core.Utils.fillHoles(dterms[i], max));\n          } //solve the system of equations\n\n\n          var partials = _.multiply(M.transpose().invert(), c); //the results are backwards to reverse it\n          //partials.elements.reverse();\n          //convert it all back\n\n\n          var retval = as_array ? [r] : r;\n          partials.each(function (e, i) {\n            var term = _.multiply(ks[i], _.divide(e, factors[i]));\n\n            if (as_array) retval.push(term);else retval = _.add(retval, term);\n          }); //done\n\n          return retval;\n        } catch (e) {\n          //try to group symbols\n          try {\n            if (symbol.isComposite()) {\n              //group denominators\n              var denominators = {};\n              symbol.each(function (x) {\n                var d = x.getDenom();\n                var n = x.getNum();\n                var e = denominators[d];\n                denominators[d] = e ? _.add(e, n) : n;\n              });\n              var t = new Symbol(0);\n\n              for (var x in denominators) {\n                t = _.add(t, _.divide(denominators[x], _.parse(x)));\n              }\n\n              symbol = t;\n            }\n          } catch (e2) {}\n\n          ;\n        }\n\n        ;\n        return symbol;\n      }\n    },\n    degree: function (symbol, v, o) {\n      o = o || {\n        nd: [],\n        //numeric\n        sd: [],\n        //symbolic\n        depth: 0 //call depth\n\n      };\n\n      if (!v) {\n        var vars = variables(symbol); //The user must specify the variable for multivariate\n\n        if (vars.length > 1) throw new Error('You must specify the variable for multivariate polynomials!'); //if it's empty then we're dealing with a constant\n\n        if (vars.length === 0) return new Symbol(0); //assume the variable for univariate\n\n        v = _.parse(vars[0]);\n      } //store the group\n\n\n      var g = symbol.group; //we're going to trust the user and assume no EX. Calling isPoly \n      //would eliminate this but no sense in checking twice. \n\n      if (symbol.isComposite()) {\n        symbol = symbol.clone();\n        symbol.distributeExponent();\n        symbol.each(function (x) {\n          o.depth++; //mark a depth increase\n\n          __.degree(x, v, o);\n\n          o.depth--; //we're back\n        });\n      } else if (symbol.group === CB) {\n        symbol.each(function (x) {\n          o.depth++;\n\n          __.degree(x, v, o);\n\n          o.depth++;\n        });\n      } else if (g === EX && symbol.value === v.value) {\n        o.sd.push(symbol.power.clone());\n      } else if (g === S && symbol.value === v.value) {\n        o.nd.push(_.parse(symbol.power));\n      } else o.nd.push(new Symbol(0)); //get the max out of the array\n\n\n      var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\n\n      if (o.depth === 0 && o.sd.length > 0) {\n        if (deg !== undefined) o.sd.unshift(deg);\n        return _.symfunction('max', o.sd);\n      }\n\n      if (!core.Utils.isSymbol(deg)) deg = _.parse(deg); //return the degree\n\n      return deg;\n    },\n\n    /**\r\n     * Attempts to complete the square of a polynomial\r\n     * @param {type} symbol\r\n     * @param {type} v\r\n     * @param {type} raw\r\n     * @throws {Error} \r\n     * @returns {Object|Symbol[]}\r\n     */\n    sqComplete: function (symbol, v, raw) {\n      if (!core.Utils.isSymbol(v)) v = _.parse(v);\n\n      var stop = function (msg) {\n        msg = msg || 'Stopping';\n        throw new core.exceptions.ValueLimitExceededError(msg);\n      }; //if not CP then nothing to do\n\n\n      if (!symbol.isPoly(true)) stop('Must be a polynomial!'); //declare vars\n\n      var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\n      br = core.Utils.inBrackets; //make a copy\n\n      symbol = symbol.clone();\n      deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\n      //must be in form ax^2 +/- bx +/- c\n\n      if (!deg.equals(2)) stop('Cannot complete square for degree ' + deg); //get the coeffs\n\n      coeffs = core.Algebra.coeffs(symbol, v);\n      a = coeffs[2]; //store the sign\n\n      sign = coeffs[1].sign(); //divide the linear term by two and square it\n\n      b = _.divide(coeffs[1], new Symbol(2)); //add the difference to the constant\n\n      c = _.pow(b.clone(), new Symbol(2));\n      if (raw) return [a, b, d];\n      sqrt_a = math.sqrt(a);\n      e = _.divide(math.sqrt(c), sqrt_a.clone()); //calculate d which is the constant\n\n      d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2))); //compute the square part\n\n      sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\n      return {\n        a: sym,\n        c: d,\n        f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\n      };\n    },\n    Simplify: {\n      strip: function (symbol) {\n        var c = _.parse(symbol.multiplier);\n\n        symbol.toUnitMultiplier();\n\n        var p = _.parse(symbol.power);\n\n        symbol.toLinear();\n        return [c, p, symbol];\n      },\n      unstrip: function (cp, symbol) {\n        var c = cp[0];\n        var p = cp[1];\n        return _.multiply(c, _.pow(symbol, p));\n      },\n      complexSimp: function (num, den) {\n        var ac, bd, bc, ad, cd, r1, r2, i1, i2;\n        r1 = num.realpart();\n        i1 = num.imagpart();\n        r2 = den.realpart();\n        i2 = den.imagpart(); //apply complex arithmatic rule\n\n        ac = _.multiply(r1.clone(), r2.clone());\n        bd = _.multiply(i1.clone(), i2.clone());\n        bc = _.multiply(r2.clone(), i1);\n        ad = _.multiply(r1, i2.clone());\n        cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\n        return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\n      },\n      trigSimp: function (symbol) {\n        if (symbol.containsFunction(['cos', 'sin', 'tan'])) {\n          symbol = symbol.clone(); //remove power and multiplier\n\n          var sym_array = __.Simplify.strip(symbol);\n\n          symbol = sym_array.pop(); //the default return value is the symbol\n\n          var retval = symbol.clone(); //rewrite the symbol\n\n          if (symbol.group === CP) {\n            var sym = new Symbol(0);\n            symbol.each(function (x) {\n              //rewrite the function\n              var tr = __.Simplify.trigSimp(x.fnTransform());\n\n              sym = _.add(sym, tr);\n            }, true); //put back the power and multiplier and return\n\n            retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\n          } else if (symbol.group === CB) {\n            var n = symbol.getNum();\n            var d = symbol.getDenom(); //try for tangent\n\n            if (n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\n              retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\n            }\n\n            if (retval.group === CB) {\n              var t = new Symbol(1);\n              retval.each(function (x) {\n                if (x.fname === 'tan') {\n                  x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\n                }\n\n                t = _.multiply(t, x);\n              });\n              retval = t;\n            }\n          }\n\n          retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\n          symbol = retval;\n        }\n\n        return symbol;\n      },\n      fracSimp: function (symbol) {\n        //try a quick simplify of imaginary numbers\n        var den = symbol.getDenom();\n        var num = symbol.getNum();\n        if (num.isImaginary() && den.isImaginary()) symbol = __.Simplify.complexSimp(num, den);\n\n        if (symbol.isComposite()) {\n          if (symbol.power > 1) {\n            symbol = _.expand(symbol);\n          }\n\n          var symbols = symbol.collectSymbols(); //assumption 1.\n          //since it's a composite, it has a length of at least 1\n\n          var retval, a, b, d1, d2, n1, n2, x, y, c, den, num;\n          a = symbols.pop(); //grab the first symbol\n          //loop through each term and make denominator common\n\n          while (symbols.length) {\n            b = symbols.pop(); //grab the second symbol\n\n            d1 = _.parse(a.getDenom());\n            d2 = _.parse(b.getDenom());\n            n1 = a.getNum();\n            n2 = b.getNum();\n            c = _.multiply(d1.clone(), d2.clone());\n            x = _.multiply(n1, d2);\n            y = _.multiply(n2, d1);\n            a = _.divide(_.add(x, y), c);\n          }\n\n          den = _.expand(a.getDenom());\n          num = _.expand(a.getNum()); //simplify imaginary\n\n          if (num.isImaginary() && den.isImaginary()) {\n            retval = __.Simplify.complexSimp(num, den);\n          } else {\n            retval = _.divide(num, den);\n          } //we've already hit the simplest form so return that\n\n\n          if (retval.equals(symbol)) {\n            return symbol;\n          } //otherwise simplify it some more\n\n\n          return __.Simplify.simplify(retval);\n        }\n\n        return symbol;\n      },\n      ratSimp: function (symbol) {\n        if (symbol.group === CB) {\n          var den = symbol.getDenom();\n          var num = symbol.getNum().distributeMultiplier();\n\n          var d = __.Simplify.fracSimp(den);\n\n          var n = __.Simplify.fracSimp(num);\n\n          symbol = _.divide(n, d);\n        }\n\n        return symbol;\n      },\n      sqrtSimp: function (symbol, sym_array) {\n        var retval;\n\n        if (symbol.isSQRT()) {\n          var factored = __.Factor.factor(symbol.args[0].clone());\n\n          var m = _.parse(factored.multiplier);\n\n          var sign = m.sign();\n\n          var retval = _.sqrt(m.abs());\n\n          var arg;\n\n          if (isInt(retval)) {\n            if (factored.group === CB) {\n              var rem = new Symbol(1);\n              factored.each(function (x) {\n                if (x.group === N) {\n                  var trial = _.sqrt(x.clone()); // Multiply back sqrt if it's an integer otherwise just put back the number\n\n\n                  if (isInt(trial)) {\n                    retval = _.multiply(retval, trial);\n                  } else {\n                    rem = _.multiply(rem, x);\n                  }\n                } else {\n                  rem = _.multiply(rem, x);\n                }\n              });\n\n              var t = _.multiply(rem, _.parse(sign));\n\n              arg = _.sqrt(t.clone()); // Expand if it's imaginary\n\n              if (arg.isImaginary) {\n                arg = _.sqrt(_.expand(t.clone()));\n              }\n            } else {\n              // Strip the multiplier\n              arg = _.sqrt(factored.clone().toUnitMultiplier());\n            }\n\n            return _.multiply(retval, arg);\n          }\n        } else if (symbol.isComposite() && symbol.isLinear()) {\n          retval = new Symbol(0);\n          symbol.each(function (x) {\n            retval = _.add(retval, __.Simplify.sqrtSimp(x));\n          }, true); // Put back the multiplier\n\n          retval = _.multiply(retval, _.parse(symbol.multiplier));\n        } else if (symbol.group === CB) {\n          retval = _.parse(symbol.multiplier);\n          symbol.each(function (x) {\n            var simp = __.Simplify.sqrtSimp(x);\n\n            retval = _.multiply(retval, simp);\n          }, true); // Put back the power\n\n          retval = _.pow(retval, _.parse(symbol.power));\n        }\n\n        return retval ? retval : _.parse(symbol);\n      },\n\n      /**\r\n       * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n       * @param {Symbol} symbol\r\n       * @return {Array} The symbol and the matched patterns\r\n       */\n      patternSub: function (symbol) {\n        var patterns = {};\n\n        var has_CP = function (symbol) {\n          var found = false;\n          symbol.each(function (x) {\n            if (x.group === CP) {\n              found = true;\n            } else if (x.symbols) {\n              found = has_CP(x);\n            }\n          });\n          return found;\n        };\n\n        var collect = function (sym) {\n          // We loop through each symbol looking for anything in the simplest\n          // form of ax+byz+...\n          sym.each(function (x) {\n            // Items of group N,P,S, need to apply\n            if (!x.symbols && x.group !== FN) {\n              return;\n            } // Check to see if it has any symbols of group CP\n            // Get the patterns in that symbol instead if it has anything of group CP\n\n\n            if (has_CP(x)) {\n              collect(x);\n            } else {\n              if (!patterns[x.value]) {\n                var u = core.Utils.getU(symbol); // Get a u value and mark it for subsitution\n\n                patterns[x.value] = u;\n                symbol = symbol.sub(x.value, u);\n              }\n            }\n          }, true);\n        }; // Collect a list of patterns\n\n\n        collect(symbol);\n        return [symbol, patterns];\n      },\n      simplify: function (symbol) {\n        //remove the multiplier to make calculation easier;\n        var sym_array = __.Simplify.strip(symbol);\n\n        symbol = sym_array.pop(); //remove gcd from denominator\n\n        symbol = __.Simplify.fracSimp(symbol); //nothing more to do\n\n        if (symbol.isConstant() || symbol.group === core.groups.S) {\n          sym_array.push(symbol);\n\n          var ret = __.Simplify.unstrip(sym_array, symbol);\n\n          return ret;\n        } //var patterns;\n\n\n        var simplified = symbol.clone(); //make a copy\n        //[simplified, patterns] = __.Simplify.patternSub(symbol);\n        // Simplify sqrt within the symbol\n        //                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\n        // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\n\n        simplified = __.Simplify.trigSimp(simplified); // Simplify common denominators\n\n        simplified = __.Simplify.ratSimp(simplified); // First go for the \"cheapest\" simplification which may eliminate \n        // your problems right away. factor -> evaluate. Remember\n        // that there's no need to expand since factor already does that\n\n        simplified = __.Factor.factor(simplified); //If the simplfied is a sum then we can make a few more simplifications\n        //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\n\n        if (simplified.group === core.groups.CP && simplified.isLinear()) {\n          var m = simplified.multiplier.clone();\n          simplified.toUnitMultiplier(); //strip the multiplier\n\n          var r = new Symbol(0); //return the sum of simplifications\n\n          simplified.each(function (x) {\n            var s = __.Simplify.simplify(x);\n\n            r = _.add(r, s);\n          });\n          simplified = r; //put back the multiplier\n\n          r.multiplier = r.multiplier.multiply(m);\n        } //place back multiplier and return\n\n\n        var retval = __.Simplify.unstrip(sym_array, simplified); // Back substitute\n\n        /*\r\n         for(var x in patterns) {\r\n         retval = retval.sub(patterns[x], x);\r\n         }\r\n         */\n\n\n        return retval;\n      }\n    },\n    Classes: {\n      Polynomial: Polynomial,\n      Factors: Factors,\n      MVTerm: MVTerm\n    }\n  }; // Add a link to simplify\n\n\n  core.Expression.prototype.simplify = function () {\n    return __.Simplify.simplify(this.symbol);\n  };\n\n  nerdamer.useAlgebraDiv = function () {\n    var divide = __.divideFn = _.divide;\n    var calls = 0; //keep track of how many calls were made\n\n    _.divide = function (a, b) {\n      calls++;\n      var ans;\n      if (calls === 1) //check if this is the first call. If it is use algebra divide\n        ans = core.Algebra.divide(a, b);else //otherwise use parser divide\n        ans = divide(a, b);\n      calls = 0; //reset the number of calls back to none\n\n      return ans;\n    };\n  };\n\n  nerdamer.useParserDiv = function () {\n    if (__.divideFn) _.divide = __.divideFn;\n    delete __.divideFn;\n  };\n\n  nerdamer.register([{\n    name: 'factor',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Factor.factor;\n    }\n  }, {\n    name: 'simplify',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Simplify.simplify;\n    }\n  }, {\n    name: 'gcd',\n    visible: true,\n    numargs: [1],\n    build: function () {\n      return __.gcd;\n    }\n  }, {\n    name: 'lcm',\n    visible: true,\n    numargs: [1],\n    build: function () {\n      return __.lcm;\n    }\n  }, {\n    name: 'roots',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.roots;\n    }\n  }, {\n    name: 'divide',\n    visible: true,\n    numargs: 2,\n    build: function () {\n      return __.divide;\n    }\n  }, {\n    name: 'div',\n    visible: true,\n    numargs: 2,\n    build: function () {\n      return __.div;\n    }\n  }, {\n    name: 'partfrac',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      return __.PartFrac.partfrac;\n    }\n  }, {\n    name: 'deg',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      return __.degree;\n    }\n  }, {\n    name: 'coeffs',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      var f = function () {\n        var coeffs = __.coeffs.apply(__, arguments);\n\n        return new core.Vector(coeffs);\n      };\n\n      return f;\n    }\n  }, {\n    name: 'line',\n    visible: true,\n    numargs: [2, 3],\n    build: function () {\n      return __.line;\n    }\n  }, {\n    name: 'sqcomp',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      var f = function (x, v) {\n        try {\n          v = v || variables(x)[0];\n\n          var sq = __.sqComplete(x.clone(), v);\n\n          return sq.f;\n        } catch (e) {\n          return x;\n        }\n      };\n\n      return f;\n    }\n  }]);\n  nerdamer.api();\n})();","map":{"version":3,"sources":["C:/Users/brisk/OneDrive/Documents/GitHub/seeciv/my-app/node_modules/nerdamer/Algebra.js"],"names":["module","nerdamer","require","core","getCore","_","PARSER","N","groups","P","S","EX","FN","PL","CP","CB","keys","Utils","even","variables","format","round","Frac","isInt","Symbol","CONST_HASH","Settings","math","importFunctions","evaluate","Polynomial","symbol","variable","order","isSymbol","parse","isNaN","undefined","exceptions","InvalidVariableNameError","coeffs","fill","fromArray","arr","p","fit","c1","c2","n","base","terms","Array","t","Math","pow","i","b","q","sign","c","floor","abs","length","prototype","isPoly","NerdamerTypeError","text","power","absEquals","expand","group","multiplier","toDecimal","x","symbols","sub","Number","l","trim","equalsZero","equals","pop","modP","j","subtract","add","d","mod","w","divide","up_one","next","poly","max","a","dividend","arrayClone","divisor","mp","quotient","multiply","p1","p2","l1","l2","x1","k","x2","e","isZero","sum","clone","deg","lc","monic","gcd","mp1","mp2","T","Math2","QGCD","apply","diff","new_array","push","integrate","gcf","toPolynomial","fnz","ca","indexOf","parr","quad","incl_img","roots","Error","dsc","sqrt","squareFree","output","equalsNumber","y","z","toSymbol","end","str","plus","String","toString","with_order","error","s","distributeMultiplier","isComposite","isConstant","isImaginary","m","each","imaginary","tBase","map","collectSymbols","g","nterm","MVTerm","sym","value","updateCount","altVar","sameVars","groupTerms","f","egrouped","grouped","el","decompose_fn","collectFactors","factors","Factors","getNumberSymbolics","fo","firstObject","symfunction","PARENTHESIS","obj","negate","key","preAdd","pFactor","is_constant","v","factored","Object","values","sort","factor","fname","unwrapPARENS","merge","o","isLinear","args","call","count","clean","h","lessThan","coeff","image","getVars","vars","term","rev_map","getRevMap","join","len","mapped","generateImage","getImg","mvterm","new_mvterm","toMapObj","filledArray","clss","arrSum","haveIntersection","some","subFunctions","subbed","previousGroup","val","tvar","inBrackets","getFunctionsSubs","subs","__","Algebra","version","proots","decp","zeros","known_roots","get_roots","rarr","powers","calcroots","concat","unshift","lowest_pow","arrayMin","lowest_symbol","toUnitMultiplier","minpower","arrayMax","isArray","last_power","MAXDEGREE","slice","ValueLimitExceededError","zeroi","degreePar","Degree","zeror","QuadSD_ak1","NN","u","iPar","calcSC_ak1","DBL_EPSILON","K","qk","sdPar","dumFlag","a3","a1","a7","nextK_ak1","tFlag","qp","temp","newest_ak1","a4","a5","b1","b2","c3","c4","Quad_ak1","sr","si","lr","li","QuadIT_ak1","uu","vv","calcPar","qPar","ee","omp","relstp","ui","vi","zm","triedFlag","NZ","szr","szi","lzr","lzi","RealIT_ak1","kv","ms","pv","nm1","Fxshfr_ak1","MDP1","L2","svk","betas","betav","oss","ots","otv","ovv","ss","ts","tss","tv","tvv","fflag","iFlag","spass","stry","vpass","vtry","rpSolve","degPar","RADFAC","LB2","LN2","pt","Fxshfr_Par","bnd","df","dx","ff","moduli_max","moduli_min","sc","xm","aa","bb","cc","xxx","jj","NM1","zerok","LO","MIN_VALUE","cosr","cos","sinr","sin","xx","yy","MAX_VALUE","log","exp","img","real","num","replace","nroots","Vector","froot","guess","newtonraph","xn","mesh","build","Calculus","fn","Function","done","safety","r","delta","sumProd","invert","wrt","contains","polyPowers","for_variable","arrayUnique","Factor","split","mix","include_negatives","ll","common","zeroes","exit","tp","allSame","n_terms","n_zeroes","div","_symbol","retval","_factor","create","_factored","quadFactor","degree","cf","root","filter","root1","root2","cubeFactor","sign_a","sign_b","isCube","m_root_a","getNth","m_root_b","arg","isSimple","greaterThan","untouched","den_array","num_array","den","dfact","nfact","Simplify","strip","getDenom","getNum","unstrip","ret","toLinear","IMAGINARY","multiVar","all_S","all_unit","coeff_factors","coeffFactor","power_factors","powerFactor","t_factors","trialAndError","tf_symbol","t_factor","mfactor","reduce","nn","result","sqfr","allNumeric","updateHash","LT","factor_array","cnst","cfactors","ifactor","search","forEach","check","candidate","ltfactors","isubbed","nfactors","cp","ceil","lc_is_neg","cnst_is_neg","factor_found","isPrime","mSqfrFactor","reverse","can_divide","is_factor","sqdiff","remove_square","block","separated","separate","obj_array","constants","powSimp","factors2","unwrapSQRT","sorted","maxes","new_factor","divided","has_fractions","neg_numeric_factor","rem","allLinear","set","status","sg","arguments","elements","arguments2Array","appeared","splice","every","aggregate","gcd_","lcm","gcd_m","GCD","gcd_v","gcd_p","vars_a","vars_b","multipliers","numer","prev","curr","denom_args","input","size","results","mask","total","denom","isVariableSymbol","symbol1","symbol2","remainder","fail","symbol1_has_func","hasFunc","symbol2_has_func","parse_funcs","quot","reconvert","get_unique_max","any","idx","get_det","lookat","det","umax","is_equal","max1","max2","idx1","idx2","item1","item2","d1","d2","s2","cterm","t_map","init_sort","is_larger","s1","target","lead_var","try_better_lead_var","checked","tt","sf","blv","alv","fdt","fnt","nd","dividend_larger","InfiniteLoopError","shift","neg","cur","remove","line","v1","v2","convertToVector","isVector","dy","PartFrac","createTemplate","denom_factors","f_array","factors_vec","degrees","efactor","partfrac","as_array","tfactors","ofactors","nterms","dterms","M","ks","template","Matrix","fillHoles","transpose","partials","denominators","e2","sd","depth","distributeExponent","sqComplete","raw","stop","msg","br","sqrt_a","complexSimp","ac","bd","bc","ad","cd","r1","r2","i1","i2","realpart","imagpart","trigSimp","containsFunction","sym_array","tr","fnTransform","simplify","fracSimp","n1","n2","ratSimp","sqrtSimp","isSQRT","trial","simp","patternSub","patterns","has_CP","found","collect","getU","simplified","Classes","Expression","useAlgebraDiv","divideFn","calls","ans","useParserDiv","register","name","visible","numargs","sq","api"],"mappings":"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","sourcesContent":["/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global module, Function */\r\n\r\nif((typeof module) !== 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Calculus.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    /*shortcuts*/\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            N = core.groups.N,\r\n            P = core.groups.P,\r\n            S = core.groups.S,\r\n            EX = core.groups.EX,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            keys = core.Utils.keys,\r\n            even = core.Utils.even,\r\n            variables = core.Utils.variables,\r\n            format = core.Utils.format,\r\n            round = core.Utils.round,\r\n            Frac = core.Frac,\r\n            isInt = core.Utils.isInt,\r\n            Symbol = core.Symbol,\r\n            CONST_HASH = core.Settings.CONST_HASH,\r\n            math = core.Utils.importFunctions(),\r\n            evaluate = core.Utils.evaluate;\r\n    //*************** CLASSES ***************//\r\n    /**\r\n     * Converts a symbol into an equivalent polynomial arrays of \r\n     * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n     * Univariate polymials only. \r\n     * @param {Symbol|Number} symbol\r\n     * @param {String} variable The variable name of the polynomial\r\n     * @param {int} order\r\n     */\r\n    function Polynomial(symbol, variable, order) {\r\n        if(core.Utils.isSymbol(symbol)) {\r\n            this.parse(symbol);\r\n            this.variable = this.variable || variable;\r\n        }\r\n        else if(!isNaN(symbol)) {\r\n            order = order || 0;\r\n            if(variable === undefined)\r\n                throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\r\n            this.coeffs = [];\r\n            this.coeffs[order] = symbol;\r\n            this.fill(symbol);\r\n        }\r\n        else if(typeof symbol === 'string') {\r\n            this.parse(_.parse(symbol));\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Polynomial given an array of coefficients\r\n     * @param {int[]} arr\r\n     * @param {String} variable\r\n     * @returns {Polynomial}\r\n     */\r\n    Polynomial.fromArray = function (arr, variable) {\r\n        if(typeof variable === 'undefined')\r\n            throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\r\n        var p = new Polynomial();\r\n        p.coeffs = arr;\r\n        p.variable = variable;\r\n        return p;\r\n    };\r\n\r\n    Polynomial.fit = function (c1, c2, n, base, p, variable) {\r\n        //after having looped through and mod 10 the number to get the matching factor\r\n        var terms = new Array(p + 1),\r\n                t = n - c2;\r\n        terms[0] = c2; //the constants is assumed to be correct\r\n        //constant for x^p is also assumed know so add\r\n        terms[p] = c1;\r\n        t -= c1 * Math.pow(base, p);\r\n        //start fitting\r\n        for(var i = p - 1; i > 0; i--) {\r\n            var b = Math.pow(base, i), //we want as many wholes as possible\r\n                    q = t / b,\r\n                    sign = Math.sign(q);\r\n            var c = sign * Math.floor(Math.abs(q));\r\n            t -= c * b;\r\n            terms[i] = c;\r\n        }\r\n        if(t !== 0)\r\n            return null;\r\n        for(var i = 0; i < terms.length; i++)\r\n            terms[i] = new Frac(terms[i]);\r\n\r\n        return Polynomial.fromArray(terms, variable);\r\n    };\r\n\r\n    Polynomial.prototype = {\r\n        /**\r\n         * Converts Symbol to Polynomial\r\n         * @param {Symbol} symbol\r\n         * @param {Array} c - a collector array\r\n         * @returns {Polynomial}\r\n         */\r\n        parse: function (symbol, c) {\r\n            this.variable = variables(symbol)[0];\r\n            if(!symbol.isPoly())\r\n                throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\r\n            c = c || [];\r\n            if(!symbol.power.absEquals(1))\r\n                symbol = _.expand(symbol);\r\n\r\n            if(symbol.group === core.groups.N) {\r\n                c[0] = symbol.multiplier;\r\n            }\r\n            else if(symbol.group === core.groups.S) {\r\n                c[symbol.power.toDecimal()] = symbol.multiplier;\r\n            }\r\n            else {\r\n                for(var x in symbol.symbols) {\r\n                    var sub = symbol.symbols[x],\r\n                            p = sub.power;\r\n                    if(core.Utils.isSymbol(p))\r\n                        throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\r\n\r\n                    p = sub.group === N ? 0 : p.toDecimal();\r\n                    if(sub.symbols) {\r\n                        this.parse(sub, c);\r\n                    }\r\n                    else {\r\n                        c[p] = sub.multiplier;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.coeffs = c;\r\n\r\n            this.fill();\r\n        },\r\n        /**\r\n         * Fills in the holes in a polynomial with zeroes\r\n         * @param {Number} x - The number to fill the holes with\r\n         */\r\n        fill: function (x) {\r\n            x = Number(x) || 0;\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(this.coeffs[i] === undefined) {\r\n                    this.coeffs[i] = new Frac(x);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Removes higher order zeros or a specific coefficient\r\n         * @returns {Array}\r\n         */\r\n        trim: function () {\r\n            var l = this.coeffs.length;\r\n            while(l--) {\r\n                var c = this.coeffs[l];\r\n                var equalsZero = c.equals(0);\r\n                if(c && equalsZero) {\r\n                    if(l === 0)\r\n                        break;\r\n                    this.coeffs.pop();\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /*\r\n         * Returns polynomial mod p **currently fails**\r\n         * @param {Number} p\r\n         * @returns {Polynomial}\r\n         */\r\n        modP: function (p) {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = this.coeffs[i];\r\n                if(c < 0) { //go borrow\r\n                    var b; //a coefficient > 0\r\n                    for(var j = i; j < l; j++) {//starting from where we left off\r\n                        if(this.coeffs[j] > 0) {\r\n                            b = this.coeffs[j];\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(b) { //if such a coefficient exists\r\n                        for(j; j > i; j--) { //go down the line and adjust using p\r\n                            this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\r\n                            this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\r\n                        }\r\n                        c = this.coeffs[i]; //reset c\r\n                    }\r\n                }\r\n\r\n                var d = c.mod(p);\r\n                var w = c.subtract(d).divide(p);\r\n                if(!w.equals(0)) {\r\n                    var up_one = i + 1;\r\n                    var next = this.coeffs[up_one] || new Frac(0);\r\n                    next = next.add(w);\r\n                    this.coeffs[up_one] = new Frac(next);\r\n                    this.coeffs[i] = new Frac(d);\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        add: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.add(b);\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        subtract: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.subtract(b);\r\n            }\r\n            return this;\r\n        },\r\n        divide: function (poly) {\r\n            var variable = this.variable,\r\n                    dividend = core.Utils.arrayClone(this.coeffs),\r\n                    divisor = core.Utils.arrayClone(poly.coeffs),\r\n                    n = dividend.length,\r\n                    mp = divisor.length - 1,\r\n                    quotient = [];\r\n\r\n            //loop through the dividend\r\n            for(var i = 0; i < n; i++) {\r\n                var p = n - (i + 1);\r\n                //get the difference of the powers\r\n                var d = p - mp;\r\n                //get the quotient of the coefficients\r\n                var q = dividend[p].divide(divisor[mp]);\r\n\r\n                if(d < 0)\r\n                    break;//the divisor is not greater than the dividend\r\n                //place it in the quotient\r\n                quotient[d] = q;\r\n\r\n                for(var j = 0; j <= mp; j++) {\r\n                    //reduce the dividend\r\n                    dividend[j + d] = dividend[j + d].subtract((divisor[j].multiply(q)));\r\n                }\r\n            }\r\n\r\n            //clean up\r\n            var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(), //pass in x for safety\r\n                    p2 = Polynomial.fromArray(quotient, variable || 'x');\r\n            return [p2, p1];\r\n        },\r\n        multiply: function (poly) {\r\n            var l1 = this.coeffs.length, l2 = poly.coeffs.length,\r\n                    c = []; //array to be returned\r\n            for(var i = 0; i < l1; i++) {\r\n                var x1 = this.coeffs[i];\r\n                for(var j = 0; j < l2; j++) {\r\n                    var k = i + j, //add the powers together\r\n                            x2 = poly.coeffs[j],\r\n                            e = c[k] || new Frac(0); //get the existing term from the new array\r\n                    c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\r\n                }\r\n            }\r\n            this.coeffs = c;\r\n            return this;\r\n        },\r\n        /**\r\n         * Checks if a polynomial is zero\r\n         * @returns {Boolean}\r\n         */\r\n        isZero: function () {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /** \r\n         * Substitutes in a number n into the polynomial p(n)\r\n         * @param {Number} n\r\n         * @returns {Frac}\r\n         */\r\n        sub: function (n) {\r\n            var sum = new Frac(0), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var t = this.coeffs[i];\r\n                if(!t.equals(0))\r\n                    sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\r\n            }\r\n            return sum;\r\n        },\r\n        /**\r\n         * Returns a clone of the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        clone: function () {\r\n            var p = new Polynomial();\r\n            p.coeffs = this.coeffs;\r\n            p.variable = this.variable;\r\n            return p;\r\n        },\r\n        /**\r\n         * Gets the degree of the polynomial\r\n         * @returns {Number}\r\n         */\r\n        deg: function () {\r\n            this.trim();\r\n            return this.coeffs.length - 1;\r\n        },\r\n        /**\r\n         * Returns a lead coefficient\r\n         * @returns {Frac}\r\n         */\r\n        lc: function () {\r\n            return this.coeffs[this.deg()].clone();\r\n        },\r\n        /**\r\n         * Converts polynomial into a monic polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        monic: function () {\r\n            var lc = this.lc(), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++)\r\n                this.coeffs[i] = this.coeffs[i].divide(lc);\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the GCD of two polynomials\r\n         * @param {Polynomial} poly\r\n         * @returns {Polynomial}\r\n         */\r\n        gcd: function (poly) {\r\n            //get the maximum power of each\r\n            var mp1 = this.coeffs.length - 1,\r\n                    mp2 = poly.coeffs.length - 1,\r\n                    T;\r\n            //swap so we always have the greater power first\r\n            if(mp1 < mp2) {\r\n                return poly.gcd(this);\r\n            }\r\n            var a = this;\r\n\r\n            while(!poly.isZero()) {\r\n                var t = poly.clone();\r\n                a = a.clone();\r\n                T = a.divide(t);\r\n                poly = T[1];\r\n                a = t;\r\n            }\r\n\r\n            var gcd = core.Math2.QGCD.apply(null, a.coeffs);\r\n            if(!gcd.equals(1)) {\r\n                var l = a.coeffs.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    a.coeffs[i] = a.coeffs[i].divide(gcd);\r\n                }\r\n            }\r\n            return a;\r\n        },\r\n        /**\r\n         * Differentiates the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        diff: function () {\r\n            var new_array = [], l = this.coeffs.length;\r\n            for(var i = 1; i < l; i++)\r\n                new_array.push(this.coeffs[i].multiply(new Frac(i)));\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Integrates the polynomial\r\n         * @returns {Polynomial} \r\n         */\r\n        integrate: function () {\r\n            var new_array = [0], l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = new Frac(i + 1);\r\n                new_array[c] = this.coeffs[i].divide(c);\r\n            }\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the Greatest common factor of the polynomial\r\n         * @param {bool} toPolynomial - true if a polynomial is wanted\r\n         * @returns {Frac|Polynomial}\r\n         */\r\n        gcf: function (toPolynomial) {\r\n            //get the first nozero coefficient and returns its power\r\n            var fnz = function (a) {\r\n                for(var i = 0; i < a.length; i++)\r\n                    if(!a[i].equals(0))\r\n                        return i;\r\n            },\r\n                    ca = [];\r\n            for(var i = 0; i < this.coeffs.length; i++) {\r\n                var c = this.coeffs[i];\r\n                if(!c.equals(0) && ca.indexOf(c) === -1)\r\n                    ca.push(c);\r\n            }\r\n            var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\r\n\r\n            if(toPolynomial) {\r\n                var parr = [];\r\n                parr[p[1] - 1] = p[0];\r\n                p = Polynomial.fromArray(parr, this.variable).fill();\r\n            }\r\n\r\n            return p;\r\n        },\r\n        /**\r\n         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n         * @param {bool} incl_img - Include imaginary numbers \r\n         */\r\n        quad: function (incl_img) {\r\n            var roots = [];\r\n            if(this.coeffs.length > 3)\r\n                throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\r\n            if(this.coeffs.length === 0)\r\n                throw new Error('Polynomial array has no terms');\r\n            var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];\r\n            var dsc = b * b - 4 * a * c;\r\n            if(dsc < 0 && !incl_img)\r\n                return roots;\r\n            else {\r\n                roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\r\n                roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\r\n            }\r\n            return roots;\r\n        },\r\n        /**\r\n         * Makes polynomial square free\r\n         * @returns {Array}\r\n         */\r\n        squareFree: function () {\r\n\r\n            var a = this.clone(),\r\n                    i = 1,\r\n                    b = a.clone().diff(),\r\n                    c = a.clone().gcd(b),\r\n                    w = a.divide(c)[0];\r\n            var output = Polynomial.fromArray([new Frac(1)], a.variable);\r\n            while(!c.equalsNumber(1)) {\r\n                var y = w.gcd(c);\r\n                var z = w.divide(y)[0];\r\n                //one of the factors may have shown up since it's square but smaller than the \r\n                //one where finding\r\n                if(!z.equalsNumber(1) && i > 1) {\r\n                    var t = z.clone();\r\n                    for(var j = 1; j < i; j++)\r\n                        t.multiply(z.clone());\r\n                    z = t;\r\n                }\r\n                output = output.multiply(z);\r\n                i++;\r\n                w = y;\r\n                c = c.divide(y)[0];\r\n            }\r\n\r\n            return [output, w, i];\r\n        },\r\n        /**\r\n         * Converts polynomial to Symbol\r\n         * @returns {Symbol}\r\n         */\r\n        toSymbol: function () {\r\n            var l = this.coeffs.length,\r\n                    variable = this.variable;\r\n            if(l === 0)\r\n                return new core.Symbol(0);\r\n            var end = l - 1, str = '';\r\n\r\n            for(var i = 0; i < l; i++) {\r\n                //place the plus sign for all but the last one\r\n                var plus = i === end ? '' : '+',\r\n                        e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    str += (e + '*' + variable + '^' + i + plus);\r\n            }\r\n            return _.parse(str);\r\n        },\r\n        /**\r\n         * Checks if polynomial is equal to a number\r\n         * @param {Number} x\r\n         * @returns {Boolean}\r\n         */\r\n        equalsNumber: function (x) {\r\n            this.trim();\r\n            return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\r\n        },\r\n        toString: function () {\r\n            return this.toSymbol().toString();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * TODO\r\n     * ===================================================================================\r\n     * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n     * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n     * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n     * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n     * ===================================================================================\r\n     * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n     * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n     * so the symbol multiplier carries the coefficients for all contained symbols.\r\n     * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n     * @param {Array} c The coefficient array\r\n     * @param {boolean} with_order \r\n     * @return {Array}\r\n     */\r\n    Symbol.prototype.coeffs = function (c, with_order) {\r\n        if(with_order && !this.isPoly(true))\r\n            _.error('Polynomial expected when requesting coefficients with order');\r\n        c = c || [];\r\n        var s = this.clone().distributeMultiplier();\r\n        if(s.isComposite()) {\r\n            for(var x in s.symbols) {\r\n                var sub = s.symbols[x];\r\n                if(sub.isComposite()) {\r\n                    sub.clone().distributeMultiplier().coeffs(c, with_order);\r\n                }\r\n                else {\r\n                    if(with_order)\r\n                        c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;\r\n                    else {\r\n                        c.push(sub.multiplier);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if(with_order)\r\n                c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;\r\n            else {\r\n                if(s.group === CB && s.isImaginary()) {\r\n                    var m = new Symbol(s.multiplier);\r\n                    s.each(function (x) {\r\n                        //add the imaginary part\r\n                        if(x.isConstant(true) || x.imaginary)\r\n                            m = _.multiply(m, x);\r\n                    });\r\n                    c.push(m);\r\n                }\r\n                else\r\n                    c.push(s.multiplier);\r\n            }\r\n        }\r\n        //fill the holes\r\n        if(with_order) {\r\n            for(var i = 0; i < c.length; i++)\r\n                if(c[i] === undefined)\r\n                    c[i] = new Symbol(0);\r\n        }\r\n        return c;\r\n    };\r\n    Symbol.prototype.tBase = function (map) {\r\n        if(typeof map === 'undefined')\r\n            throw new Error('Symbol.tBase requires a map object!');\r\n        var terms = [];\r\n        var symbols = this.collectSymbols(null, null, null, true),\r\n                l = symbols.length;\r\n        for(var i = 0; i < l; i++) {\r\n            var symbol = symbols[i],\r\n                    g = symbol.group,\r\n                    nterm = new MVTerm(symbol.multiplier, [], map);\r\n            if(g === CB) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n                    nterm.terms[map[x]] = sym.power;\r\n                }\r\n            }\r\n            else {\r\n                nterm.terms[map[symbol.value]] = symbol.power;\r\n            }\r\n\r\n            terms.push(nterm.fill());\r\n            nterm.updateCount();\r\n        }\r\n        return terms;\r\n    };\r\n    Symbol.prototype.altVar = function (x) {\r\n        var m = this.multiplier.toString(), p = this.power.toString();\r\n        return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\r\n    };\r\n    /**\r\n     * Checks to see if the symbols contain the same variables\r\n     * @param {Symbol} symbol\r\n     * @returns {Boolean}\r\n     */\r\n    Symbol.prototype.sameVars = function (symbol) {\r\n        if(!(this.symbols || this.group === symbol.group))\r\n            return false;\r\n        for(var x in this.symbols) {\r\n            var a = this.symbols[x], b = symbol.symbols[x];\r\n            if(!b)\r\n                return false;\r\n            if(a.value !== b.value)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Groups the terms in a symbol with respect to a variable\r\n     * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n     * @returns {Factors}\r\n     */\r\n    Symbol.prototype.groupTerms = function (x) {\r\n        x = String(x);\r\n        var f, p, egrouped;\r\n        var grouped = [];\r\n        this.each(function (e) {\r\n            if(e.group === PL) {\r\n                egrouped = e.groupTerms(x);\r\n                for(var i = 0; i < egrouped.length; i++) {\r\n                    var el = egrouped[i];\r\n                    if(el)\r\n                        grouped[i] = el;\r\n                }\r\n            }\r\n            else {\r\n                f = core.Utils.decompose_fn(e, x, true);\r\n                p = f.x.value === x ? Number(f.x.power) : 0;\r\n                //check if there's an existing value\r\n                grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\r\n            }\r\n        });\r\n        return grouped;\r\n    };\r\n    /**\r\n     * Use this to collect Factors\r\n     * @returns {Symbol[]}\r\n     */\r\n    Symbol.prototype.collectFactors = function () {\r\n        var factors = [];\r\n        if(this.group === CB)\r\n            this.each(function (x) {\r\n                factors.push(x.clone());\r\n            });\r\n        else\r\n            factors.push(this.clone());\r\n        return factors;\r\n    };\r\n    /**\r\n     * A container class for factors\r\n     * @returns {Factors}\r\n     */\r\n    function Factors() {\r\n        this.factors = {};\r\n        this.length = 0;\r\n    }\r\n    ;\r\n    Factors.prototype.getNumberSymbolics = function () {\r\n        var n = 0;\r\n        this.each(function (x) {\r\n            if(!x.isConstant(true))\r\n                n++;\r\n        });\r\n        return n;\r\n    };\r\n    /**\r\n     * Adds the factors to the factor object\r\n     * @param {Symbo} s\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.add = function (s) {\r\n        if(s.equals(0))\r\n            return this; //nothing to add\r\n\r\n        //we don't want to carry -1 as a factor. If a factor already exists,\r\n        //then add the minus one to that factor and return.\r\n        if(s.equals(-1) && this.length > 0) {\r\n            var fo = core.Utils.firstObject(this.factors, null, true);\r\n            this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\r\n            delete this.factors[fo.key];\r\n            this.length--;\r\n            return this;\r\n        }\r\n\r\n        if(s.group === CB) {\r\n            var factors = this;\r\n            if(!s.multiplier.equals(1))\r\n                factors.add(new Symbol(s.multiplier));\r\n            s.each(function (x) {\r\n                factors.add(x);\r\n            });\r\n        }\r\n        else {\r\n            if(this.preAdd) //if a preAdd function was defined call it to do prep\r\n                s = this.preAdd(s);\r\n            if(this.pFactor) //if the symbol isn't linear add back the power\r\n                s = _.pow(s, new Symbol(this.pFactor));\r\n\r\n            var is_constant = s.isConstant();\r\n            if(is_constant && s.equals(1))\r\n                return this; //don't add 1\r\n            var v = is_constant ? s.value : s.text();\r\n            if(v in this.factors) {\r\n                this.factors[v] = _.multiply(this.factors[v], s);\r\n                //did the addition cancel out the existing factor? If so remove it and decrement the length\r\n                if(this.factors[v].equals(1)) {\r\n                    delete this.factors[v];\r\n                    this.length--;\r\n                }\r\n            }\r\n            else {\r\n                this.factors[v] = s;\r\n                this.length++;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Converts the factor object to a Symbol\r\n     * @returns {Symbol}\r\n     */\r\n    Factors.prototype.toSymbol = function () {\r\n        var factored = new Symbol(1);\r\n        var factors = Object.values(this.factors).sort(function (a, b) {\r\n            return a.group > b.group;\r\n        });\r\n\r\n        for(var i = 0, l = factors.length; i < l; i++) {\r\n            var f = factors[i];\r\n\r\n            //don't wrap group S or FN\r\n            var factor = f.power.equals(1) && f.fname !== '' /* don't wrap it twice */ ?\r\n                    _.symfunction(core.PARENTHESIS, [f]) : f;\r\n\r\n            factored = _.multiply(factored, factor);\r\n        }\r\n        if(factored.fname === '')\r\n            factored = Symbol.unwrapPARENS(factored);\r\n        return factored;\r\n    };\r\n    /**\r\n     * Merges 2 factor objects into one\r\n     * @param {Factor} o\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.merge = function (o) {\r\n        for(var x in o) {\r\n            if(x in this.factors)\r\n                this.factors[x] = _.multiply(this.factors[x], o[x]);\r\n            else\r\n                this.factors[x] = o[x];\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * The iterator for the factor object\r\n     * @param {Function} f - callback\r\n     * @returns {Factor}\r\n     */\r\n    Factors.prototype.each = function (f) {\r\n        for(var x in this.factors) {\r\n            var factor = this.factors[x];\r\n            if(factor.fname === core.PARENTHESIS && factor.isLinear())\r\n                factor = factor.args[0];\r\n            f.call(this, factor, x);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Return the number of factors contained in the factor object\r\n     * @returns {int}\r\n     */\r\n    Factors.prototype.count = function () {\r\n        return keys(this.factors).length;\r\n    };\r\n    /**\r\n     * Cleans up factors from -1\r\n     * @returns {undefined}\r\n     */\r\n    Factors.prototype.clean = function () {\r\n        try {\r\n            var h = core.Settings.CONST_HASH;\r\n            if(this.factors[h].lessThan(0)) {\r\n                if(this.factors[h].equals(-1))\r\n                    delete this.factors[h];\r\n                else\r\n                    this.factors[h].negate();\r\n                this.each(function (x) {\r\n                    x.negate();\r\n                });\r\n            }\r\n        }\r\n        catch(e) {\r\n        }\r\n        ;\r\n    };\r\n    Factors.prototype.toString = function () {\r\n        return this.toSymbol().toString();\r\n    };\r\n\r\n    //a wrapper for performing multivariate division\r\n    function MVTerm(coeff, terms, map) {\r\n        this.terms = terms || [];\r\n        this.coeff = coeff;\r\n        this.map = map; //careful! all maps are the same object\r\n        this.sum = new core.Frac(0);\r\n        this.image = undefined;\r\n    }\r\n    ;\r\n    MVTerm.prototype.updateCount = function () {\r\n        this.count = this.count || 0;\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            if(!this.terms[i].equals(0))\r\n                this.count++;\r\n        }\r\n        return this;\r\n    };\r\n    MVTerm.prototype.getVars = function () {\r\n        var vars = [];\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var term = this.terms[i],\r\n                    rev_map = this.getRevMap();\r\n            if(!term.equals(0))\r\n                vars.push(this.rev_map[i]);\r\n        }\r\n        return vars.join(' ');\r\n    };\r\n    MVTerm.prototype.len = function () {\r\n        if(typeof this.count === 'undefined') {\r\n            this.updateCount();\r\n        }\r\n        return this.count;\r\n    };\r\n    MVTerm.prototype.toSymbol = function (rev_map) {\r\n        rev_map = rev_map || this.getRevMap();\r\n        var symbol = new Symbol(this.coeff);\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var v = rev_map[i],\r\n                    t = this.terms[i];\r\n            if(t.equals(0) || v === CONST_HASH)\r\n                continue;\r\n            var mapped = new Symbol(v);\r\n            mapped.power = t;\r\n            symbol = _.multiply(symbol, mapped);\r\n        }\r\n        return symbol;\r\n    };\r\n    MVTerm.prototype.getRevMap = function () {\r\n        if(this.rev_map)\r\n            return this.rev_map;\r\n        var o = {};\r\n        for(var x in this.map)\r\n            o[this.map[x]] = x;\r\n        this.rev_map = o;\r\n        return o;\r\n    };\r\n    MVTerm.prototype.generateImage = function () {\r\n        this.image = this.terms.join(' ');\r\n        return this;\r\n    },\r\n            MVTerm.prototype.getImg = function () {\r\n                if(!this.image)\r\n                    this.generateImage();\r\n                return this.image;\r\n            },\r\n            MVTerm.prototype.fill = function () {\r\n                var l = this.map.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    if(typeof this.terms[i] === 'undefined')\r\n                        this.terms[i] = new core.Frac(0);\r\n                    else {\r\n                        this.sum = this.sum.add(this.terms[i]);\r\n                    }\r\n                }\r\n                return this;\r\n            };\r\n    MVTerm.prototype.divide = function (mvterm) {\r\n        var c = this.coeff.divide(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.multiply = function (mvterm) {\r\n        var c = this.coeff.multiply(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.isZero = function () {\r\n        return this.coeff.equals(0);\r\n    };\r\n    MVTerm.prototype.toString = function () {\r\n        return '{ coeff: ' + this.coeff.toString() + ', terms: [' +\r\n                this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\r\n    };\r\n\r\n    core.Utils.toMapObj = function (arr) {\r\n        var c = 0, o = {};\r\n        for(var i = 0; i < arr.length; i++) {\r\n            var v = arr[i];\r\n            if(typeof o[v] === 'undefined') {\r\n                o[v] = c;\r\n                c++;\r\n            }\r\n        }\r\n        o.length = c;\r\n        return o;\r\n    };\r\n    core.Utils.filledArray = function (v, n, clss) {\r\n        var a = [];\r\n        while(n--) {\r\n            a[n] = clss ? new clss(v) : v;\r\n        }\r\n        return a;\r\n    };\r\n    core.Utils.arrSum = function (arr) {\r\n        var sum = 0, l = arr.length;\r\n        for(var i = 0; i < l; i++)\r\n            sum += arr[i];\r\n        return sum;\r\n    };\r\n    /**\r\n     * Determines if 2 arrays have intersecting elements.\r\n     * @param {Array} a\r\n     * @param {Array} b\r\n     * @returns {Boolean} True if a and b have intersecting elements.\r\n     */\r\n    core.Utils.haveIntersection = function (a, b) {\r\n        var t;\r\n        if(b.length > a.length)\r\n            t = b, b = a, a = t; // indexOf to loop over shorter\r\n        return a.some(function (e) {\r\n            return b.indexOf(e) > -1;\r\n        });\r\n    };\r\n    /**\r\n     * Substitutes out functions as variables so they can be used in regular algorithms\r\n     * @param {Symbol} symbol\r\n     * @param {Object} map\r\n     * @returns {String} The expression string\r\n     */\r\n    core.Utils.subFunctions = function (symbol, map) {\r\n        map = map || {};\r\n        var subbed = [];\r\n        symbol.each(function (x) {\r\n            if(x.group === FN || x.previousGroup === FN) {\r\n                //we need a new variable name so why not use one of the existing\r\n                var val = core.Utils.text(x, 'hash'), tvar = map[val];\r\n                if(!tvar) {\r\n                    //generate a unique enough name\r\n                    var t = x.fname + keys(map).length;\r\n                    map[val] = t;\r\n                    subbed.push(x.altVar(t));\r\n                }\r\n                else\r\n                    subbed.push(x.altVar(tvar));\r\n            }\r\n            else if(x.group === CB || x.group === PL || x.group === CP) {\r\n                subbed.push(core.Utils.subFunctions(x, map));\r\n            }\r\n            else\r\n                subbed.push(x.text());\r\n        });\r\n        if(symbol.group === CP || symbol.group === PL)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\r\n        ;\r\n        if(symbol.group === CB)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\r\n        return symbol.text();\r\n    };\r\n    core.Utils.getFunctionsSubs = function (map) {\r\n        var subs = {};\r\n        //prepare substitutions\r\n        for(var x in map)\r\n            subs[map[x]] = _.parse(x);\r\n        return subs;\r\n    };\r\n\r\n    var __ = core.Algebra = {\r\n        version: '1.4.6',\r\n        proots: function (symbol, decp) {\r\n            //the roots will be rounded up to 7 decimal places.\r\n            //if this causes trouble you can explicitly pass in a different number of places\r\n            //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\r\n            decp = decp || 7;\r\n            var zeros = 0;\r\n            var known_roots = [];\r\n            var get_roots = function (rarr, powers, max) {\r\n                var roots = calcroots(rarr, powers, max).concat(known_roots);\r\n                for(var i = 0; i < zeros; i++)\r\n                    roots.unshift(0);\r\n                return roots;\r\n            };\r\n\r\n            if(symbol instanceof Symbol && symbol.isPoly()) {\r\n                symbol.distributeMultiplier();\r\n                //make it so the symbol has a constants as the lowest term\r\n                if(symbol.group === PL) {\r\n                    var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\r\n                    var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\r\n                    symbol = _.expand(_.divide(symbol, lowest_symbol));\r\n                    known_roots.push(0); //add zero since this is a known root\r\n                }\r\n                if(symbol.group === core.groups.S) {\r\n                    return [0];\r\n                }\r\n                else if(symbol.group === core.groups.PL) {\r\n                    var powers = keys(symbol.symbols),\r\n                            minpower = core.Utils.arrayMin(powers),\r\n                            symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\r\n                }\r\n\r\n                var variable = keys(symbol.symbols).sort().pop(),\r\n                        sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\r\n                        g = sym.group,\r\n                        powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\r\n                        rarr = [],\r\n                        max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\r\n\r\n                // Prepare the data\r\n                for(var i = 1; i <= max; i++) {\r\n                    var c = 0; //if there is no power then the hole must be filled with a zero\r\n                    if(powers.indexOf(i + '') !== -1) {\r\n                        if(g === S) {\r\n                            c = sym.multiplier;\r\n                        }\r\n                        else {\r\n                            c = sym.symbols[i].multiplier;\r\n                        }\r\n                    }\r\n                    // Insert the coeffient but from the front\r\n                    rarr.unshift(c);\r\n                }\r\n\r\n                rarr.push(symbol.symbols[CONST_HASH].multiplier);\r\n\r\n                if(sym.group === S)\r\n                    rarr[0] = sym.multiplier;//the symbol maybe of group CP with one variable\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else if(core.Utils.isArray(symbol)) {\r\n                var parr = symbol;\r\n                var rarr = [],\r\n                        powers = [],\r\n                        last_power = 0;\r\n                for(var i = 0; i < parr.length; i++) {\r\n\r\n                    var coeff = parr[i][0],\r\n                            pow = parr[i][1],\r\n                            d = pow - last_power - 1;\r\n                    //insert the zeros\r\n                    for(var j = 0; j < d; j++)\r\n                        rarr.unshift(0);\r\n\r\n                    rarr.unshift(coeff);\r\n                    if(pow !== 0)\r\n                        powers.push(pow);\r\n                    last_power = pow;\r\n                }\r\n                var max = Math.max.apply(undefined, powers);\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else {\r\n                throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\r\n            }\r\n\r\n            function calcroots(rarr, powers, max) {\r\n                var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\r\n\r\n                // Make a clone of the coefficients before appending the max power\r\n                var p = rarr.slice(0);\r\n\r\n                // Divide the string up into its individual entries, which--presumably--are separated by whitespace\r\n                rarr.unshift(max);\r\n\r\n                if(max > MAXDEGREE) {\r\n                    throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\r\n                }\r\n\r\n                var zeroi = [], // Vector of imaginary components of roots\r\n                        degreePar = {};    // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\r\n                degreePar.Degree = max;\r\n\r\n                for(i = 0; i < max; i++) {\r\n                    zeroi.push(0);\r\n                }\r\n                var zeror = zeroi.slice(0); // Vector of real components of roots\r\n\r\n                // Find the roots\r\n                //--> Begin Jenkins-Traub\r\n\r\n                /*\r\n                 * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n                 */\r\n                function QuadSD_ak1(NN, u, v, p, q, iPar) {\r\n                    // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\r\n                    // iPar is a dummy variable for passing in the two parameters--a and b--by reference\r\n                    q[0] = iPar.b = p[0];\r\n                    q[1] = iPar.a = -(u * iPar.b) + p[1];\r\n\r\n                    for(var i = 2; i < NN; i++) {\r\n                        q[i] = -(u * iPar.a + v * iPar.b) + p[i];\r\n                        iPar.b = iPar.a;\r\n                        iPar.a = q[i];\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\r\n                    // This routine calculates scalar quantities used to compute the next K polynomial and\r\n                    // new estimates of the quadratic coefficients.\r\n                    // calcSC -\tinteger variable set here indicating how the calculations are normalized\r\n                    // to avoid overflow.\r\n                    // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\r\n\r\n                    // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\r\n                    var sdPar = new Object(),\r\n                            // TYPE = 3 indicates the quadratic is almost a factor of K\r\n                            dumFlag = 3;\r\n\r\n                    // Synthetic division of K by the quadratic 1, u, v\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(N, u, v, K, qk, sdPar);\r\n                    iPar.c = sdPar.a;\r\n                    iPar.d = sdPar.b;\r\n\r\n                    if(Math.abs(iPar.c) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 1]))) {\r\n                        if(Math.abs(iPar.d) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 2])))\r\n                            return dumFlag;\r\n                    }\r\n\r\n                    iPar.h = v * b;\r\n                    if(Math.abs(iPar.d) >= Math.abs(iPar.c)) {\r\n                        // TYPE = 2 indicates that all formulas are divided by d\r\n                        dumFlag = 2;\r\n                        iPar.e = a / (iPar.d);\r\n                        iPar.f = (iPar.c) / (iPar.d);\r\n                        iPar.g = u * b;\r\n                        iPar.a3 = (iPar.e) * ((iPar.g) + a) + (iPar.h) * (b / (iPar.d));\r\n                        iPar.a1 = -a + (iPar.f) * b;\r\n                        iPar.a7 = (iPar.h) + ((iPar.f) + u) * a;\r\n                    }\r\n                    else {\r\n                        // TYPE = 1 indicates that all formulas are divided by c;\r\n                        dumFlag = 1;\r\n                        iPar.e = a / (iPar.c);\r\n                        iPar.f = (iPar.d) / (iPar.c);\r\n                        iPar.g = (iPar.e) * u;\r\n                        iPar.a3 = (iPar.e) * a + ((iPar.g) + (iPar.h) / (iPar.c)) * b;\r\n                        iPar.a1 = -(a * ((iPar.d) / (iPar.c))) + b;\r\n                        iPar.a7 = (iPar.g) * (iPar.d) + (iPar.h) * (iPar.f) + a;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\r\n                    // Computes the next K polynomials using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\r\n                    var temp;\r\n                    if(tFlag == 3) {\t// Use unscaled form of the recurrence\r\n                        K[1] = K[0] = 0.0;\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = qk[i - 2];\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    temp = ((tFlag == 1) ? b : a);\r\n                    if(Math.abs(iPar.a1) > (10.0 * DBL_EPSILON * Math.abs(temp))) {\r\n                        // Use scaled form of the recurrence\r\n                        iPar.a7 /= iPar.a1;\r\n                        iPar.a3 /= iPar.a1;\r\n                        K[0] = qp[0];\r\n                        K[1] = -(qp[0] * iPar.a7) + qp[1];\r\n                        for(var i = 2; i < N; i++)\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\r\n                    }\r\n                    else {\r\n                        // If a1 is nearly zero, then use a special form of the recurrence\r\n                        K[0] = 0.0;\r\n                        K[1] = -(qp[0] * iPar.a7);\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\r\n                    // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\r\n                    // iPar.a = uu, iPar.b = vv\r\n\r\n                    var a4, a5, b1, b2, c1, c2, c3, c4, temp;\r\n                    iPar.b = iPar.a = 0.0;// The quadratic is zeroed\r\n\r\n                    if(tFlag != 3) {\r\n                        if(tFlag != 2) {\r\n                            a4 = a + u * b + h * f;\r\n                            a5 = c + (u + v * f) * d;\r\n                        }\r\n                        else {\r\n                            a4 = (a + g) * f + h;\r\n                            a5 = (f + u) * c + v * d;\r\n                        }\r\n\r\n                        // Evaluate new quadratic coefficients\r\n                        b1 = -(K[N - 1] / p[N]);\r\n                        b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\r\n                        c1 = v * b2 * a1;\r\n                        c2 = b1 * a7;\r\n                        c3 = b1 * b1 * a3;\r\n                        c4 = -(c2 + c3) + c1;\r\n                        temp = -c4 + a5 + b1 * a4;\r\n                        if(temp != 0.0) {\r\n                            iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\r\n                            iPar.b = v * (1.0 + c4 / temp);\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function Quad_ak1(a, b1, c, iPar) {\r\n                    // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\r\n                    // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\r\n                    // zeros are real and both zeros are complex. The smaller real zero is found directly from\r\n                    // the product of the zeros c/a.\r\n\r\n                    // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\r\n\r\n                    var b, d, e;\r\n                    iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\r\n\r\n                    if(a == 0) {\r\n                        iPar.sr = ((b1 != 0) ? -(c / b1) : iPar.sr);\r\n                        return;\r\n                    }\r\n                    if(c == 0) {\r\n                        iPar.lr = -(b1 / a);\r\n                        return;\r\n                    }\r\n\r\n                    // Compute discriminant avoiding overflow\r\n                    b = b1 / 2.0;\r\n                    if(Math.abs(b) < Math.abs(c)) {\r\n                        e = ((c >= 0) ? a : -a);\r\n                        e = -e + b * (b / Math.abs(c));\r\n                        d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\r\n                    }\r\n                    else {\r\n                        e = -((a / b) * (c / b)) + 1.0;\r\n                        d = Math.sqrt(Math.abs(e)) * (Math.abs(b));\r\n                    }\r\n\r\n                    if(e >= 0) {\r\n                        // Real zeros\r\n                        d = ((b >= 0) ? -d : d);\r\n                        iPar.lr = (-b + d) / a;\r\n                        iPar.sr = ((iPar.lr != 0) ? (c / (iPar.lr)) / a : iPar.sr);\r\n                    }\r\n                    else {\r\n                        // Complex conjugate zeros\r\n                        iPar.lr = iPar.sr = -(b / a);\r\n                        iPar.si = Math.abs(d / a);\r\n                        iPar.li = -(iPar.si);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\r\n                    // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\r\n                    // zeros are equimodular or nearly so.\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\r\n                    // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\r\n\r\n                    // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\r\n                    var qPar = new Object(),\r\n                            ee, mp, omp, relstp, t, u, ui, v, vi, zm,\r\n                            i, j = 0, tFlag, triedFlag = 0;   // Integer variables\r\n\r\n                    iPar.NZ = 0;// Number of zeros found\r\n                    u = uu; // uu and vv are coefficients of the starting quadratic\r\n                    v = vv;\r\n\r\n                    do {\r\n                        qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                        Quad_ak1(1.0, u, v, qPar);\r\n                        iPar.szr = qPar.sr;\r\n                        iPar.szi = qPar.si;\r\n                        iPar.lzr = qPar.lr;\r\n                        iPar.lzi = qPar.li;\r\n\r\n                        // Return if roots of the quadratic are real and not close to multiple or nearly\r\n                        // equal and of opposite sign.\r\n                        if(Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr))\r\n                            break;\r\n\r\n                        // Evaluate polynomial by quadratic synthetic division\r\n\r\n                        QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n\r\n                        mp = Math.abs(-((iPar.szr) * (sdPar.b)) + (sdPar.a)) + Math.abs((iPar.szi) * (sdPar.b));\r\n\r\n                        // Compute a rigorous bound on the rounding error in evaluating p\r\n\r\n                        zm = Math.sqrt(Math.abs(v));\r\n                        ee = 2.0 * Math.abs(qp[0]);\r\n                        t = -((iPar.szr) * (sdPar.b));\r\n\r\n                        for(i = 1; i < N; i++) {\r\n                            ee = ee * zm + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        ee = ee * zm + Math.abs(t + sdPar.a);\r\n                        ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs((sdPar.a) + t) + zm * Math.abs((sdPar.b)))) * DBL_EPSILON;\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\r\n                        if(mp <= 20.0 * ee) {\r\n                            iPar.NZ = 2;\r\n                            break;\r\n                        }\r\n\r\n                        j++;\r\n                        // Stop iteration after 20 steps\r\n                        if(j > 20)\r\n                            break;\r\n                        if(j >= 2) {\r\n                            if((relstp <= 0.01) && (mp >= omp) && (!triedFlag)) {\r\n                                // A cluster appears to be stalling the convergence. Five fixed shift\r\n                                // steps are taken with a u, v close to the cluster.\r\n                                relstp = ((relstp < DBL_EPSILON) ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp));\r\n                                u -= u * relstp;\r\n                                v += v * relstp;\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                for(i = 0; i < 5; i++) {\r\n                                    tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                                    nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                                }\r\n\r\n                                triedFlag = 1;\r\n                                j = 0;\r\n\r\n                            }\r\n                        }\r\n                        omp = mp;\r\n\r\n                        // Calculate next K polynomial and new u and v\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vi = sdPar.b;\r\n\r\n                        // If vi is zero, the iteration is not converging\r\n                        if(vi != 0) {\r\n                            relstp = Math.abs((-v + vi) / vi);\r\n                            u = ui;\r\n                            v = vi;\r\n                        }\r\n                    }\r\n                    while(vi != 0);\r\n                    return;\r\n                }\r\n\r\n                function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\r\n                    // Variable-shift H-polynomial iteration for a real zero\r\n                    // sss\t- starting iterate = sdPar.a\r\n                    // NZ\t\t- number of zeros found = iPar.NZ\r\n                    // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\r\n\r\n                    var ee, kv, mp, ms, omp, pv, s, t,\r\n                            dumFlag, i, j, nm1 = N - 1;   // Integer variables\r\n\r\n                    iPar.NZ = j = dumFlag = 0;\r\n                    s = sdPar.a;\r\n\r\n                    for(; ; ) {\r\n                        pv = p[0];\r\n\r\n                        // Evaluate p at s\r\n                        qp[0] = pv;\r\n                        for(i = 1; i < NN; i++) {\r\n                            qp[i] = pv = pv * s + p[i];\r\n                        }\r\n                        mp = Math.abs(pv);\r\n\r\n                        // Compute a rigorous bound on the error in evaluating p\r\n                        ms = Math.abs(s);\r\n                        ee = 0.5 * Math.abs(qp[0]);\r\n                        for(i = 1; i < NN; i++) {\r\n                            ee = ee * ms + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than\r\n                        // 20 times this bound\r\n                        if(mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\r\n                            iPar.NZ = 1;\r\n                            iPar.szr = s;\r\n                            iPar.szi = 0.0;\r\n                            break;\r\n                        }\r\n                        j++;\r\n                        // Stop iteration after 10 steps\r\n                        if(j > 10)\r\n                            break;\r\n\r\n                        if(j >= 2) {\r\n                            if((Math.abs(t) <= 0.001 * Math.abs(-t + s)) && (mp > omp)) {\r\n                                // A cluster of zeros near the real axis has been encountered.\r\n                                // Return with iFlag set to initiate a quadratic iteration.\r\n                                dumFlag = 1;\r\n                                iPar.a = s;\r\n                                break;\r\n                            } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\r\n                        } //End if (j >= 2)\r\n\r\n                        // Return if the polynomial value has increased significantly\r\n                        omp = mp;\r\n\r\n                        // Compute t, the next polynomial and the new iterate\r\n                        qk[0] = kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            qk[i] = kv = kv * s + K[i];\r\n                        }\r\n\r\n                        if(Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\r\n                            // Use the scaled form of the recurrence if the value of K at s is non-zero\r\n                            t = -(pv / kv);\r\n                            K[0] = qp[0];\r\n                            for(i = 1; i < N; i++) {\r\n                                K[i] = t * qk[i - 1] + qp[i];\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Use unscaled form\r\n                            K[0] = 0.0;\r\n                            for(i = 1; i < N; i++)\r\n                                K[i] = qk[i - 1];\r\n                        }\r\n\r\n                        kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            kv = kv * s + K[i];\r\n                        }\r\n                        t = ((Math.abs(kv) > (Math.abs(K[nm1]) * 10.0 * DBL_EPSILON)) ? -(pv / kv) : 0.0);\r\n                        s += t;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\r\n\r\n                    // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\r\n                    // quadratic case. Initiates one of the variable shift iterations and returns with the\r\n                    // number of zeros found.\r\n                    // L2\tlimit of fixed shift steps\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // NZ\tnumber of zeros found\r\n                    var sdPar = new Object(), // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\r\n                            calcPar = new Object(),\r\n                            // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\r\n\r\n                            qk = new Array(MDP1),\r\n                            svk = new Array(MDP1),\r\n                            a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv,\r\n                            fflag, i, iFlag = 1, j, spass, stry, tFlag, vpass, vtry;     // Integer variables\r\n\r\n                    iPar.NZ = 0;\r\n                    betav = betas = 0.25;\r\n                    oss = sr;\r\n                    ovv = v;\r\n\r\n                    //Evaluate polynomial by synthetic division\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                    a = sdPar.a;\r\n                    b = sdPar.b;\r\n                    calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\r\n                    tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                    for(j = 0; j < L2; j++) {\r\n                        fflag = 1;\r\n\r\n                        // Calculate next K polynomial and estimate v\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                        // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\r\n                        // sdPar.a = ui, sdPar.b = vi\r\n                        newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vv = vi = sdPar.b;\r\n\r\n                        // Estimate s\r\n                        ss = ((K[N - 1] != 0.0) ? -(p[N] / K[N - 1]) : 0.0);\r\n                        ts = tv = 1.0;\r\n\r\n                        if((j != 0) && (tFlag != 3)) {\r\n                            // Compute relative measures of convergence of s and v sequences\r\n                            tv = ((vv != 0.0) ? Math.abs((vv - ovv) / vv) : tv);\r\n                            ts = ((ss != 0.0) ? Math.abs((ss - oss) / ss) : ts);\r\n\r\n                            // If decreasing, multiply the two most recent convergence measures\r\n                            tvv = ((tv < otv) ? tv * otv : 1.0);\r\n                            tss = ((ts < ots) ? ts * ots : 1.0);\r\n\r\n                            // Compare with convergence criteria\r\n                            vpass = ((tvv < betav) ? 1 : 0);\r\n                            spass = ((tss < betas) ? 1 : 0);\r\n\r\n                            if((spass) || (vpass)) {\r\n\r\n                                // At least one sequence has passed the convergence test.\r\n                                // Store variables before iterating\r\n\r\n                                for(i = 0; i < N; i++) {\r\n                                    svk[i] = K[i];\r\n                                }\r\n                                s = ss;\r\n\r\n                                // Choose iteration according to the fastest converging sequence\r\n\r\n                                stry = vtry = 0;\r\n\r\n                                for(; ; ) {\r\n                                    if((fflag && ((fflag = 0) == 0)) && ((spass) && (!vpass || (tss < tvv)))) {\r\n                                        ;// Do nothing. Provides a quick \"short circuit\".\r\n                                    }\r\n                                    else {\r\n                                        QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\r\n                                        a = sdPar.a;\r\n                                        b = sdPar.b;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Quadratic iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        iFlag = vtry = 1;\r\n                                        betav *= 0.25;\r\n\r\n                                        // Try linear iteration if it has not been tried and the s sequence is converging\r\n                                        if(stry || (!spass)) {\r\n                                            iFlag = 0;\r\n                                        }\r\n                                        else {\r\n                                            for(i = 0; i < N; i++)\r\n                                                K[i] = svk[i];\r\n                                        }\r\n                                    }\r\n                                    //fflag = 0;\r\n                                    if(iFlag != 0) {\r\n                                        // Use sdPar for passing in s instead of defining a brand-new variable.\r\n                                        // sdPar.a = s\r\n                                        sdPar.a = s;\r\n                                        iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\r\n                                        s = sdPar.a;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Linear iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        stry = 1;\r\n                                        betas *= 0.25;\r\n\r\n                                        if(iFlag != 0) {\r\n                                            // If linear iteration signals an almost double real zero, attempt quadratic iteration\r\n                                            ui = -(s + s);\r\n                                            vi = s * s;\r\n                                            continue;\r\n\r\n                                        }\r\n                                    }\r\n\r\n                                    // Restore variables\r\n                                    for(i = 0; i < N; i++)\r\n                                        K[i] = svk[i];\r\n\r\n                                    // Try quadratic iteration if it has not been tried and the v sequence is converging\r\n                                    if(!vpass || vtry)\r\n                                        break;\t\t// Break out of infinite for loop\r\n\r\n                                }\r\n\r\n                                // Re-compute qp and scalar values to continue the second stage\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                a = sdPar.a;\r\n                                b = sdPar.b;\r\n\r\n                                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n                            }\r\n                        }\r\n                        ovv = vv;\r\n                        oss = ss;\r\n                        otv = tv;\r\n                        ots = ts;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function rpSolve(degPar, p, zeror, zeroi) {\r\n                    var N = degPar.Degree,\r\n                            RADFAC = 3.14159265358979323846 / 180, // Degrees-to-radians conversion factor = PI/180\r\n                            LB2 = Math.LN2, // Dummy variable to avoid re-calculating this value in loop below\r\n                            MDP1 = degPar.Degree + 1,\r\n                            K = new Array(MDP1),\r\n                            pt = new Array(MDP1),\r\n                            qp = new Array(MDP1),\r\n                            temp = new Array(MDP1),\r\n                            // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\r\n                            qPar = new Object(),\r\n                            // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\r\n                            Fxshfr_Par = new Object(),\r\n                            bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm,\r\n                            aa, bb, cc, sr, t, u, xxx,\r\n                            j, jj, l, NM1, NN, zerok;// Integer variables\r\n\r\n                    // Calculate the machine epsilon and store in the variable DBL_EPSILON.\r\n                    // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\r\n                    aa = 1.0;\r\n                    do {\r\n                        DBL_EPSILON = aa;\r\n                        aa /= 2;\r\n                        bb = 1.0 + aa;\r\n                    }\r\n                    while(bb > 1.0);\r\n\r\n                    var LO = Number.MIN_VALUE / DBL_EPSILON,\r\n                            cosr = Math.cos(94.0 * RADFAC), // = -0.069756474\r\n                            sinr = Math.sin(94.0 * RADFAC), // = 0.99756405\r\n                            xx = Math.sqrt(0.5), // = 0.70710678\r\n                            yy = -xx;\r\n\r\n                    Fxshfr_Par.NZ = j = 0;\r\n                    Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;\r\n\r\n                    // Remove zeros at the origin, if any\r\n                    while(p[N] == 0) {\r\n                        zeror[j] = zeroi[j] = 0;\r\n                        N--;\r\n                        j++;\r\n                    }\r\n                    NN = N + 1;\r\n\r\n                    // >>>>> Begin Main Loop <<<<<\r\n                    while(N >= 1) { // Main loop\r\n                        // Start the algorithm for one zero\r\n                        if(N <= 2) {\r\n                            // Calculate the final zero or pair of zeros\r\n                            if(N < 2) {\r\n                                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\r\n                                zeroi[degPar.Degree - 1] = 0;\r\n                            }\r\n                            else {\r\n                                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                                Quad_ak1(p[0], p[1], p[2], qPar);\r\n                                zeror[degPar.Degree - 2] = qPar.sr;\r\n                                zeroi[degPar.Degree - 2] = qPar.si;\r\n                                zeror[degPar.Degree - 1] = qPar.lr;\r\n                                zeroi[degPar.Degree - 1] = qPar.li;\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        // Find the largest and smallest moduli of the coefficients\r\n                        moduli_max = 0.0;\r\n                        moduli_min = Number.MAX_VALUE;\r\n\r\n                        for(i = 0; i < NN; i++) {\r\n                            x = Math.abs(p[i]);\r\n                            if(x > moduli_max)\r\n                                moduli_max = x;\r\n                            if((x != 0) && (x < moduli_min))\r\n                                moduli_min = x;\r\n                        }\r\n\r\n                        // Scale if there are large or very small coefficients\r\n                        // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\r\n                        // is done to avoid overflow and to avoid undetected underflow interfering with the\r\n                        // convergence criterion.\r\n                        // The factor is a power of the base.\r\n                        sc = LO / moduli_min;\r\n\r\n                        if(((sc <= 1.0) && (moduli_max >= 10)) || ((sc > 1.0) && (Number.MAX_VALUE / sc >= moduli_max))) {\r\n                            sc = ((sc == 0) ? Number.MIN_VALUE : sc);\r\n                            l = Math.floor(Math.log(sc) / LB2 + 0.5);\r\n                            factor = Math.pow(2.0, l);\r\n                            if(factor != 1.0) {\r\n                                for(i = 0; i < NN; i++)\r\n                                    p[i] *= factor;\r\n                            }\r\n                        }\r\n\r\n                        // Compute lower bound on moduli of zeros\r\n                        for(var i = 0; i < NN; i++)\r\n                            pt[i] = Math.abs(p[i]);\r\n                        pt[N] = -(pt[N]);\r\n                        NM1 = N - 1;\r\n\r\n                        // Compute upper estimate of bound\r\n                        x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\r\n\r\n                        if(pt[NM1] != 0) {\r\n                            // If Newton step at the origin is better, use it\r\n                            xm = -pt[N] / pt[NM1];\r\n                            x = ((xm < x) ? xm : x);\r\n                        }\r\n\r\n                        // Chop the interval (0, x) until ff <= 0\r\n                        xm = x;\r\n                        do {\r\n                            x = xm;\r\n                            xm = 0.1 * x;\r\n                            ff = pt[0];\r\n                            for(var i = 1; i < NN; i++) {\r\n                                ff = ff * xm + pt[i];\r\n                            }\r\n                        }\r\n                        while(ff > 0); // End do-while loop\r\n\r\n                        dx = x;\r\n                        // Do Newton iteration until x converges to two decimal places\r\n\r\n                        do {\r\n                            df = ff = pt[0];\r\n                            for(var i = 1; i < N; i++) {\r\n                                ff = x * ff + pt[i];\r\n                                df = x * df + ff;\r\n                            } // End for i\r\n                            ff = x * ff + pt[N];\r\n                            dx = ff / df;\r\n                            x -= dx;\r\n                        }\r\n                        while(Math.abs(dx / x) > 0.005); // End do-while loop\r\n\r\n                        bnd = x;\r\n\r\n                        // Compute the derivative as the initial K polynomial and do 5 steps with no shift\r\n                        for(var i = 1; i < N; i++)\r\n                            K[i] = (N - i) * p[i] / N;\r\n                        K[0] = p[0];\r\n                        aa = p[N];\r\n                        bb = p[NM1];\r\n                        zerok = ((K[NM1] == 0) ? 1 : 0);\r\n\r\n                        for(jj = 0; jj < 5; jj++) {\r\n                            cc = K[NM1];\r\n                            if(zerok) {\r\n                                // Use unscaled form of recurrence\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = K[j - 1];\r\n                                } // End for i\r\n                                K[0] = 0;\r\n                                zerok = ((K[NM1] == 0) ? 1 : 0);\r\n                            }\r\n                            else {\r\n                                // Used scaled form of recurrence if value of K at 0 is nonzero\r\n                                t = -aa / cc;\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = t * K[j - 1] + p[j];\r\n                                } // End for i\r\n                                K[0] = p[0];\r\n                                zerok = ((Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0) ? 1 : 0);\r\n                            }\r\n                        }\r\n\r\n                        // Save K for restarts with new shifts\r\n                        for(var i = 0; i < N; i++)\r\n                            temp[i] = K[i];\r\n\r\n                        // Loop to select the quadratic corresponding to each new shift\r\n                        for(jj = 1; jj <= 20; jj++) {\r\n\r\n                            // Quadratic corresponds to a double shift to a non-real point and its\r\n                            // complex conjugate. The point has modulus BND and amplitude rotated\r\n                            // by 94 degrees from the previous shift.\r\n\r\n                            xxx = -(sinr * yy) + cosr * xx;\r\n                            yy = sinr * xx + cosr * yy;\r\n                            xx = xxx;\r\n                            sr = bnd * xx;\r\n                            u = -(2.0 * sr);\r\n\r\n                            // Second stage calculation, fixed quadratic\r\n                            Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\r\n\r\n                            if(Fxshfr_Par.NZ != 0) {\r\n                                // The second stage jumps directly to one of the third stage iterations and\r\n                                // returns here if successful. Deflate the polynomial, store the zero or\r\n                                // zeros, and return to the main algorithm.\r\n                                j = degPar.Degree - N;\r\n                                zeror[j] = Fxshfr_Par.szr;\r\n                                zeroi[j] = Fxshfr_Par.szi;\r\n                                NN = NN - Fxshfr_Par.NZ;\r\n                                N = NN - 1;\r\n                                for(var i = 0; i < NN; i++)\r\n                                    p[i] = qp[i];\r\n                                if(Fxshfr_Par.NZ != 1) {\r\n                                    zeror[j + 1] = Fxshfr_Par.lzr;\r\n                                    zeroi[j + 1] = Fxshfr_Par.lzi;\r\n                                }\r\n                                break;\r\n                            }\r\n                            else {\r\n                                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\r\n                                for(var i = 0; i < N; i++) {\r\n                                    K[i] = temp[i];\r\n                                }\r\n                            }\r\n                        }\r\n                        // Return with failure if no convergence with 20 shifts\r\n                        if(jj > 20) {\r\n                            degPar.Degree -= N;\r\n                            break;\r\n                        }\r\n                    }\r\n                    // >>>>> End Main Loop <<<<<\r\n                    return;\r\n                }\r\n                //--> End Jenkins-Traub\r\n                rpSolve(degreePar, p, zeror, zeroi);\r\n\r\n                var l = zeroi.length;\r\n                //format the output\r\n                for(i = 0; i < l; i++) {\r\n                    // We round the imaginary part to avoid having something crazy like 5.67e-16.\r\n                    var img = round(zeroi[i], decp + 8),\r\n                            real = round(zeror[i], decp + 8);\r\n                    // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\r\n                    // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \r\n                    // the original otherwise the rounding was worth it.\r\n                    real = decp - String(real).length > 2 ? real : zeror[i];\r\n                    var sign = img < 0 ? '-' : '';\r\n\r\n                    // Remove the zeroes\r\n                    if(real === 0) {\r\n                        real = '';\r\n                    }\r\n                    if(img === 0) {\r\n                        img = '';\r\n                    }\r\n\r\n                    // Remove 1 as the multiplier and discard imaginary part if there isn't one.\r\n                    img = Math.abs(img) === 1 ? sign + 'i' : (img ? img + '*i' : '');\r\n\r\n                    var num = (real && img) ? real + '+' + img : real + img;\r\n                    zeror[i] = num.replace(/\\+\\-/g, '-');\r\n                }\r\n                return zeror;\r\n            }\r\n        },\r\n        roots: function (symbol) {\r\n\r\n            if(symbol.isConstant(true, true)) {\r\n                return core.Utils.nroots(symbol);\r\n            }\r\n            var roots = __.proots(symbol).map(function (x) {\r\n                return _.parse(x);\r\n            });\r\n            return core.Vector.fromArray(roots);\r\n        },\r\n        froot: function (f, guess, dx) {\r\n            var newtonraph = function (xn) {\r\n                var mesh = 1e-12,\r\n                        // If the derivative was already provided then don't recalculate.\r\n                        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\r\n                        // If the function was passed in as a function then don't recalculate.\r\n                        fn = f instanceof Function ? f : core.Utils.build(f),\r\n                        max = 10000,\r\n                        done = false,\r\n                        safety = 0;\r\n                while(!done) {\r\n                    var x = xn - (fn(xn) / df(xn));\r\n                    //absolute values for both x & xn ensures that we indeed have the radius    \r\n                    var r = Math.abs(x) - Math.abs(xn),\r\n                            delta = Math.abs(r);\r\n                    xn = x;\r\n\r\n                    if(delta < mesh)\r\n                        done = true;\r\n                    else if(safety > max) {\r\n                        xn = null;\r\n                        done = true;\r\n                    }\r\n\r\n                    safety++;\r\n                }\r\n                return xn;\r\n            };\r\n            return newtonraph(Number(guess));\r\n        },\r\n        quad: function (a, b, c) {\r\n            var q = function (a, b, c, sign) {\r\n                return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\r\n            };\r\n            return [q(a, b, c, 1), q(a, b, c, -1)];\r\n        },\r\n        sumProd: function (a, b) {\r\n            return __.quad(-b, a, -1).map(function (x) {\r\n                return x.invert();\r\n            });\r\n        },\r\n        coeffs: function (symbol, wrt, coeffs) {\r\n            wrt = String(wrt);\r\n            symbol = _.expand(symbol);\r\n            coeffs = coeffs || [new Symbol(0)];\r\n            //we cannot get coeffs for group EX\r\n            if(symbol.group === EX && symbol.contains(wrt, true))\r\n                _.error('Unable to get coefficients using expression ' + symbol.toString());\r\n            var vars = variables(symbol);\r\n            if(vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\r\n                var a = new Polynomial(symbol).coeffs.map(function (x) {\r\n                    return new Symbol(x);\r\n                });\r\n\r\n                for(var i = 0, l = a.length; i < l; i++) {\r\n                    var coeff = a[i],\r\n                            e = coeffs[i];\r\n                    if(e)\r\n                        coeff = _.add(e, coeff);\r\n                    coeffs[i] = coeff; //transfer it all over\r\n                }\r\n            }\r\n            else {\r\n                if(!wrt)\r\n                    _.error('Polynomial contains more than one variable. Please specify which variable is to be used!');\r\n                //if the variable isn't part of this polynomial then we're looking at x^0\r\n\r\n                if(vars.indexOf(wrt) === -1) {\r\n                    coeffs[0] = _.add(symbol, coeffs[0]);\r\n                }\r\n                else {\r\n                    coeffs = coeffs || [new Symbol(0)];\r\n                    if(symbol.group === CB) {\r\n                        var s = symbol.symbols[wrt];\r\n                        if(!s)\r\n                            _.error('Expression is not a polynomial!');\r\n                        var p = Number(s.power);\r\n                        coeff = _.divide(symbol.clone(), s.clone());\r\n                        if(coeff.contains(wrt, true) || p < 0 || !isInt(p))\r\n                            _.error('Expression is not a polynomial!');\r\n                        var e = coeffs[p];\r\n                        if(e)\r\n                            coeff = _.add(e, coeff);\r\n                        coeffs[p] = coeff;\r\n                    }\r\n                    else if(symbol.group === CP) {\r\n                        symbol.each(function (x) {\r\n                            __.coeffs(x.clone(), wrt, coeffs);\r\n                        }, true);\r\n                    }\r\n                }\r\n            }\r\n            //fill holes\r\n            for(var i = 0, l = coeffs.length; i < l; i++)\r\n                if(typeof coeffs[i] === 'undefined')\r\n                    coeffs[i] = new Symbol(0);\r\n\r\n            return coeffs;\r\n        },\r\n        /**\r\n         * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n         * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n         * @param {Symbol} e\r\n         * @param {String} for_variable\r\n         * @param {Array} powers\r\n         * @returns {Array} An array of the powers\r\n         */\r\n        //assumes you've already verified that it's a polynomial\r\n        polyPowers: function (e, for_variable, powers) {\r\n            powers = powers || [];\r\n            var g = g = e.group;\r\n            if(g === PL && for_variable === e.value) {\r\n                powers = powers.concat(keys(e.symbols));\r\n            }\r\n            else if(g === CP) {\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s];\r\n                    var g = symbol.group, v = symbol.value;\r\n                    if(g === S && for_variable === v)\r\n                        powers.push(symbol.power);\r\n                    else if(g === PL || g === CP)\r\n                        powers = __.polyPowers(symbol, for_variable, powers);\r\n                    else if(g === CB && symbol.contains(for_variable)) {\r\n                        var t = symbol.symbols[for_variable];\r\n                        if(t)\r\n                            powers.push((t.power));\r\n                    }\r\n                    else if(g === N || for_variable !== v)\r\n                        powers.push(0);\r\n                }\r\n            }\r\n            else if(g === CB && e.contains(for_variable)) {\r\n                powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\r\n            }\r\n            return core.Utils.arrayUnique(powers).sort();\r\n        },\r\n        //The factor object\r\n        Factor: {\r\n            //splits the symbol in symbol and constant\r\n            split: function (symbol) {\r\n                var c = new Symbol(1); //the constants part\r\n                var s = new Symbol(1); //the symbolic part\r\n                __.Factor.factor(symbol, new Factors()).each(function (x) {\r\n                    var t = _.parse(x);\r\n                    if(x.isConstant(true)) {\r\n                        c = _.multiply(c, t);\r\n                    }\r\n                    else {\r\n                        s = _.multiply(s, t);\r\n                    }\r\n                });\r\n                return [c, s];\r\n            },\r\n            mix: function (o, include_negatives) {\r\n                var factors = keys(o);\r\n                var l = factors.length;\r\n                var m = [];//create a row which we'r going to be mixing\r\n                for(var i = 0; i < l; i++) {\r\n                    var factor = factors[i],\r\n                            p = o[factor];\r\n                    var ll = m.length;\r\n                    for(var j = 0; j < ll; j++) {\r\n                        var t = m[j] * factor;\r\n                        m.push(t);\r\n                        if(include_negatives)\r\n                            m.push(-t);\r\n                    }\r\n\r\n                    for(var j = 1; j <= p; j++)\r\n                        m.push(Math.pow(factor, j));\r\n                }\r\n                return m;\r\n            },\r\n            //TODO: this method is to replace common factoring\r\n            common: function (symbol, factors) {\r\n                try {\r\n                    if(symbol.group === CP) {\r\n                        //this may have the unfortunate side effect of expanding and factoring again\r\n                        //to only end up with the same result. \r\n                        //TODO: try to avoid this\r\n                        //collect the symbols and sort to have the longest first. Thinking is that the longest terms \r\n                        //has to contain the variable in order for it to be factorable\r\n                        var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\r\n                            return (b.length || 1) - (a.length || 1);\r\n                        });\r\n\r\n                        var map = {}; //create a map of common factors\r\n                        var coeffs = [];\r\n                        for(var i = 0; i < symbols.length; i++) {\r\n                            var sym = symbols[i];\r\n                            coeffs.push(sym.multiplier.clone());\r\n                            sym.each(function (x) {\r\n                                var p = Number(x.power);\r\n                                //This check exits since we have a symbolic power.\r\n                                //For the future... think about removing this check and modify for symbolic powers\r\n                                if(isNaN(p))\r\n                                    throw new Error('exiting');\r\n                                //loop through the symbols and lump together common terms\r\n                                if(x.value in map) {\r\n                                    if(p < map[x.value][0])\r\n                                        map[x.value][0] = p;\r\n                                    map[x.value][1].push(x);\r\n                                }\r\n                                else\r\n                                    map[x.value] = [p, [x]];\r\n                            });\r\n                        }\r\n                        //the factor\r\n                        var factor = new Symbol(1);\r\n                        for(var x in map) {\r\n                            //if this factor is found in all terms since the length of \r\n                            //matching variable terms matches the number of original terms\r\n                            if(map[x][1].length === symbols.length) {\r\n                                //generate a symbol and multiply into the factor\r\n                                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\r\n                            }\r\n                        }\r\n                        //get coefficient factor\r\n                        var c = core.Math2.QGCD.apply(null, coeffs);\r\n\r\n                        if(!c.equals(1)) {\r\n                            factors.add(new Symbol(c));\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbols[i].multiplier = symbols[i].multiplier.divide(c);\r\n                            }\r\n                        }\r\n\r\n                        //if we actuall found any factors\r\n                        if(!factor.equals(1)) {\r\n                            factors.add(factor);\r\n                            symbol = new Symbol(0);\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            zeroes: function (symbol, factors) {\r\n                var exit = function () {\r\n                    throw new core.exceptions.ValueLimitExceededError('Exiting');\r\n                };\r\n                try {\r\n                    var vars, term, sum, p, e;\r\n                    symbol = _.expand(symbol.clone());\r\n                    e = symbol.toString();\r\n                    vars = variables(symbol);\r\n\r\n                    sum = new Symbol(0);\r\n\r\n                    var terms = [];\r\n                    var powers = [];\r\n\r\n                    //start setting each variable to zero\r\n                    for(var i = 0, l = vars.length; i < vars.length; i++) {\r\n                        var subs = {};\r\n                        //we want to create a subs object with all but the current variable set to zero\r\n                        for(var j = 0; j < l; j++)\r\n                            if(i !== j) //make sure we're not looking at the same variable\r\n                                subs[vars[j]] = 0;\r\n                        term = _.parse(e, subs);\r\n                        var tp = term.power;\r\n                        //the temporary power has to be an integer as well\r\n                        if(!isInt(tp))\r\n                            exit();\r\n                        terms.push(term);\r\n                        powers.push(term.power);\r\n                    }\r\n\r\n                    //get the gcd. This will be the p in (a^n+b^m)^p\r\n                    //if the gcd equals 1 meaning n = m then we need a tie breakder\r\n                    if(core.Utils.allSame(powers)) {\r\n                        //get p given x number of terms\r\n                        var n_terms = symbol.length;\r\n                        //the number of zeroes determines\r\n                        var n_zeroes = terms.length;\r\n                        if(n_zeroes === 2) {\r\n                            p = new Frac(powers[0] / (n_terms - 1));\r\n                        }\r\n                        if(n_zeroes === 3) {\r\n                            p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\r\n                        }\r\n                        /*\r\n                         //get the lowest possible power\r\n                         //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n                         symbol.each(function(x) {\r\n                         if(x.group === CB)\r\n                         x.each(function(y) {\r\n                         if(!p || y.power.lessThan(p))\r\n                         //p = Number(y.power);\r\n                         p = y.power;\r\n                         });\r\n                         else if(!p || x.power.lessThan(p))\r\n                         //p = Number(x.power);\r\n                         p = x.power;\r\n                         });\r\n                         */\r\n                    }\r\n                    else\r\n                        //p is just the gcd of the powers\r\n                        p = core.Math2.QGCD.apply(null, powers);\r\n\r\n                    //if we don't have an integer then exit\r\n                    if(!isInt(p))\r\n                        exit();\r\n\r\n                    //build the factor\r\n                    for(var i = 0; i < terms.length; i++) {\r\n                        var t = terms[i];\r\n                        var n = t.power.clone().divide(p);\r\n                        t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\r\n                        t.power = p.clone();\r\n                        sum = _.add(sum, t);\r\n                    }\r\n\r\n                    //by now we have the factor of zeroes. We'll know if we got it right because \r\n                    //we'll get a remainder of zero each time we divide by it\r\n                    if(sum.group !== CP)\r\n                        return symbol; //nothing to do\r\n\r\n                    while(true) {\r\n                        var d = __.div(symbol.clone(), sum.clone());\r\n                        if(d[1].equals(0)) {\r\n                            symbol = d[0];\r\n                            factors.add(sum.clone());\r\n                            if(symbol.equals(1)) //we've reached 1 so done.\r\n                                break;\r\n                        }\r\n                        else\r\n                            break;\r\n                    }\r\n                }\r\n                catch(e) {\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            },\r\n            factor: function (symbol, factors) {\r\n                // Don't try to factor constants\r\n                if(symbol.isConstant()) {\r\n                    return core.Math2.factor(symbol);\r\n                }\r\n\r\n                var _symbol = _.parse(symbol);\r\n                var retval = __.Factor._factor(_symbol, factors);\r\n                if(retval.equals(symbol)) {\r\n                    return retval;\r\n                }\r\n\r\n                if(retval.group === CB) {\r\n                    var t = new Symbol(1);\r\n                    var p = _.parse(retval.power);\r\n                    //store the multiplier and strip it\r\n                    var m = _.parse(retval.multiplier);\r\n\r\n                    retval.toUnitMultiplier();\r\n\r\n                    /* \r\n                     * NOTE: for sign issues with factor START DEBUGGING HERE\r\n                     */\r\n                    //move the sign to t\r\n                    if(retval.multiplier.lessThan(0)) {\r\n                        t.negate();\r\n                        retval.negate();\r\n                    }\r\n\r\n                    retval.each(function (x) {\r\n                        // Related to #566. Since the symbol's group may not have been properly\r\n                        // updated, it's easier to just parse the symbol and have the parser \r\n                        // do the update for us.\r\n                        var factored = _.parse(__.Factor._factor(x));\r\n\r\n                        if(factored.group === CB) {\r\n                            // Include the multiplier\r\n                            m = _.multiply(m, Symbol.create(factored.multiplier));\r\n                            factored.each(function (y) {\r\n                                var _factored = _.parse(__.Factor._factor(y));\r\n                                t = _.multiply(t, _factored);\r\n                                if(_factored.group === CB) {\r\n                                    m = _.multiply(m, Symbol.create(_factored.multiplier));\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            t = _.multiply(t, factored);\r\n                        }\r\n                    });\r\n\r\n                    //put back the multiplier and power\r\n                    retval = _.pow(_.multiply(m, t), p);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            quadFactor: function (symbol, factors) {\r\n                if(symbol.isPoly() && __.degree(symbol.equals(2))) {\r\n                    //We've  already checked that we're dealing with a polynomial\r\n                    var v = core.Utils.variables(symbol)[0]; //get the variable\r\n                    var coeffs = __.coeffs(symbol, v);\r\n                    //factor the lead coefficient\r\n                    var cf = __.Factor._factor(coeffs[2].clone());\r\n                    //check if we have factors\r\n                    if(cf.group === CB) {\r\n                        var symbols = cf.collectSymbols();\r\n                        //if the factors are greater than 2 we're done so exit\r\n                        if(symbols.length > 2)\r\n                            return symbol;\r\n                        //if we have two factors then attempt to factor the polynomial\r\n                        //let the factors be f1 and f1\r\n                        //let the factors be (ax+b)(cx+d)\r\n                        //let the coefficients be c1x^2+c2x+c3\r\n                        //then a(x1)+c(x2)=c2 and x1*x2=c3\r\n                        //we can solve for x1 and x2\r\n                        var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\r\n                        var b = _.parse(coeffs[1]).negate();\r\n                        var a = _.parse(symbols[1]);\r\n                        //solve the system\r\n                        var root = __.quad(a, b, c).filter(function (x) {\r\n                            if(core.Utils.isInt(x))\r\n                                return x;\r\n                        });\r\n                        //if we have one root then find the other one by dividing the constant\r\n                        if(root.length === 1) {\r\n                            var root1 = root[0];\r\n                            var root2 = _.divide(coeffs[0], _.parse(root1));\r\n                            if(core.Utils.isInt(root2)) {\r\n                                //we found them both\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            cubeFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var symbols = symbol.collectSymbols();\r\n                    // The symbol should be in the form of a^3+-b^3. The length\r\n                    // should therefore only be two. If it's any different from this\r\n                    // then we're done\r\n                    if(symbols.length === 2) {\r\n                        // Store the signs and then strip them from the symbols\r\n                        var sign_a = symbols[0].sign();\r\n                        var a = symbols[0].clone().abs();\r\n                        var sign_b = symbols[1].sign();\r\n                        var b = symbols[1].clone().abs();\r\n                        // Check if they're cube\r\n                        if(a.isCube() && b.isCube()) {\r\n                            // Keep the negative sign on the right, meaning b is always negative.\r\n                            if(sign_a < sign_b) {\r\n                                // Swap the signs and then the values\r\n                                [sign_a, sign_b] = [sign_b, sign_a];\r\n                                [a, b] = [b, a];\r\n                            }\r\n\r\n                            // Get teh roots\r\n                            var m_root_a = _.parse(a.getNth(3));\r\n                            var m_root_b = _.parse(b.getNth(3));\r\n\r\n                            // Remove the cube for both\r\n                            var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\r\n                            var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\r\n\r\n                            if(sign_a === 1 && sign_b === -1) {\r\n                                // Apply difference of cubes rule\r\n                                factors.add(_.parse(format('(({0})-({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                            else if(sign_a === 1 && sign_b === 1) {\r\n                                // Apply sum of cubes rule\r\n                                factors.add(_.parse(format('(({0})+({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            _factor: function (symbol, factors) {\r\n                //some items cannot be factored any further so return those right away\r\n                if(symbol.group === FN) {\r\n                    var arg = symbol.args[0];\r\n                    if(arg.group === S && arg.isSimple()) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n                else if(symbol.group === S && symbol.isSimple()) {\r\n                    return symbol;\r\n                }\r\n\r\n                // Expand the symbol to get it in a predictable form. If this step\r\n                // is skipped some factors are missed.\r\n                //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\r\n                if(symbol.group === CP) {\r\n                    symbol.distributeMultiplier(true);\r\n                    var t = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        if((x.group === CP && x.power.greaterThan(1) || x.group === CB))\r\n                            x = _.expand(x);\r\n                        t = _.add(t, x);\r\n                    });\r\n                    t.power = symbol.power;\r\n\r\n                    symbol = t;\r\n                }\r\n\r\n                if(symbol.group === FN && symbol.fname !== 'sqrt') {\r\n                    symbol = core.Utils.evaluate(symbol);\r\n                }\r\n\r\n                //make a copy of the symbol to return if something goes wrong\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    if(symbol.group === CB) {\r\n                        var p = _.parse(symbol.power);\r\n\r\n                        var den_array, num_array, den, num, dfact, nfact;\r\n                        //grab the denominator and strip the multiplier and power. Store them in an array\r\n                        den_array = __.Simplify.strip(symbol.getDenom());\r\n                        num_array = __.Simplify.strip(symbol.getNum());\r\n\r\n                        den = den_array.pop();\r\n                        num = num_array.pop();\r\n\r\n                        //if the numerator equals the symbol then we've hit the simplest form and then we're done\r\n                        if(num.equals(symbol)) {\r\n                            return symbol;\r\n                        }\r\n                        nfact = __.Factor.factor(num);\r\n                        dfact = __.Factor.factor(den);\r\n\r\n                        var n = __.Simplify.unstrip(num_array, nfact);\r\n                        var d = __.Simplify.unstrip(den_array, dfact);\r\n\r\n                        var retval = _.divide(n, d);\r\n\r\n                        return retval;\r\n                    }\r\n                    if(symbol.group === S) {\r\n                        return symbol; //absolutely nothing to do\r\n                    }\r\n\r\n                    if(symbol.isConstant()) {\r\n                        if(symbol.equals(1))\r\n                            return symbol.clone();\r\n                        var ret = core.Math2.factor(symbol);\r\n                        return ret;\r\n                    }\r\n\r\n                    var p = symbol.power.clone();\r\n\r\n                    if(isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\r\n                        var sign = p.sign();\r\n                        symbol.toLinear();\r\n                        factors = factors || new Factors();\r\n                        var map = {};\r\n                        symbol = _.parse(core.Utils.subFunctions(symbol, map));\r\n                        if(keys(map).length > 0) { //it might have functions\r\n                            factors.preAdd = function (factor) {\r\n                                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\r\n                                return ret;\r\n                            };\r\n                        }\r\n\r\n                        //strip the power\r\n                        if(!symbol.isLinear()) {\r\n                            factors.pFactor = symbol.power.toString();\r\n                            symbol.toLinear();\r\n                        }\r\n\r\n                        var vars = variables(symbol);\r\n                        //bypass for imaginary. TODO: find a better solution\r\n                        if(symbol.isImaginary()) {\r\n                            vars.push(core.Settings.IMAGINARY);\r\n                        }\r\n                        var multiVar = vars.length > 1;\r\n\r\n                        //minor optimization. Seems to cut factor time by half in some cases.\r\n                        if(multiVar) {\r\n                            var all_S = true, all_unit = true;\r\n                            symbol.each(function (x) {\r\n                                if(x.group !== S)\r\n                                    all_S = false;\r\n                                if(!x.multiplier.equals(1))\r\n                                    all_unit = false;\r\n                            });\r\n\r\n                            if(all_S && all_unit) {\r\n                                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\r\n                            }\r\n                        }\r\n\r\n                        //factor the coefficients\r\n                        var coeff_factors = new Factors();\r\n\r\n                        symbol = __.Factor.coeffFactor(symbol, coeff_factors);\r\n\r\n                        coeff_factors.each(function (x) {\r\n                            // If the factor was negative but was within a square then it becomes positive\r\n                            if(even(p) && x.lessThan(0)) {\r\n                                x.negate();\r\n                            }\r\n\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        //factor the power\r\n                        var power_factors = new Factors();\r\n                        symbol = __.Factor.powerFactor(symbol, power_factors);\r\n                        power_factors.each(function (x) {\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        if(!multiVar) {\r\n                            //pass in vars[0] for safety\r\n                            var v = vars[0];\r\n\r\n                            symbol = __.Factor.squareFree(symbol, factors, v);\r\n\r\n                            var t_factors = new Factors();\r\n\r\n                            symbol = __.Factor.trialAndError(symbol, t_factors, v);\r\n\r\n                            //generate a symbol based off the last factors\r\n                            var tf_symbol = t_factors.toSymbol();\r\n                            //if nothing was factored then return the factors\r\n                            if(tf_symbol.equals(untouched)) {\r\n                                return tf_symbol;\r\n                            }\r\n\r\n                            for(var x in t_factors.factors) {\r\n                                //store the current factor in t_factor\r\n                                var t_factor = t_factors.factors[x];\r\n                                factors.add(_.pow(t_factor, _.parse(p)));\r\n                            }\r\n                            //if we still don't have a factor and it's quadratic then let's just do a quad factor\r\n                            if(symbol.equals(untouched)) {\r\n                                symbol = __.Factor.quadFactor(symbol, factors);\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            // Try sum and difference of cubes\r\n                            symbol = __.Factor.cubeFactor(symbol, factors);\r\n\r\n                            symbol = __.Factor.mfactor(symbol, factors);\r\n\r\n                            //put back the sign of power\r\n                            factors.each(function (x) {\r\n                                if(sign < 0)\r\n                                    x.power.negate();\r\n                            });\r\n                        }\r\n\r\n                        //last minute clean up\r\n                        symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\r\n\r\n                        factors.add(_.pow(symbol, _.parse(p)));\r\n\r\n                        var retval = factors.toSymbol();\r\n\r\n                        return retval;\r\n                    }\r\n\r\n                    return symbol;\r\n                }\r\n                catch(e) {\r\n                    //no need to stop the show because something went wrong :). Just return the unfactored.\r\n                    return untouched;\r\n                }\r\n            },\r\n            reduce: function (symbol, factors) {\r\n                if(symbol.group === CP && symbol.length === 2) {\r\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                        return b.multiplier - a.multiplier;\r\n                    });\r\n                    if(symbols[0].power.equals(symbols[1].power)) {\r\n                        //x^n-a^n\r\n                        var n = _.parse(symbols[0].power),\r\n                                a = symbols[0].clone().toLinear(),\r\n                                b = symbols[1].clone().toLinear();\r\n\r\n                        //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\r\n                        factors.add(_.add(a.clone(), b.clone()));\r\n                        //flip the sign\r\n                        b.negate();\r\n                        //turn n into a number\r\n                        var nn = Number(n);\r\n                        //the remainder\r\n                        var result = new Symbol(0);\r\n                        for(var i = 1; i <= nn; i++) {\r\n                            var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\r\n                                    bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\r\n                            result = _.add(result, _.multiply(aa, bb));\r\n                        }\r\n                        return result;\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Makes Symbol square free\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @@param {String} variable The variable which is being factored \r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            squareFree: function (symbol, factors, variable) {\r\n                if(symbol.isConstant() || symbol.group === S)\r\n                    return symbol;\r\n\r\n                var poly = new Polynomial(symbol, variable);\r\n                var sqfr = poly.squareFree();\r\n                var p = sqfr[2];\r\n                //if we found a square then the p entry in the array will be non-unit\r\n                if(p !== 1) {\r\n                    //make sure the remainder doesn't have factors\r\n                    var t = sqfr[1].toSymbol();\r\n                    t.power = t.power.multiply(new Frac(p));\r\n                    //send the factor to be fatored to be sure it's completely factored\r\n                    factors.add(__.Factor.factor(t));\r\n\r\n                    var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\r\n\r\n                    return retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Factors the powers such that the lowest power is a constant\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            powerFactor: function (symbol, factors) {\r\n                //only PL need apply\r\n                if(symbol.group !== PL || symbol.previousGroup === EX)\r\n                    return symbol;\r\n                var k = keys(symbol.symbols);\r\n                //we expect only numeric powers so return all else\r\n                if(!core.Utils.allNumeric(k))\r\n                    return symbol;\r\n\r\n                var d = core.Utils.arrayMin(k);\r\n                var retval = new Symbol(0);\r\n                var q = _.parse(symbol.value + '^' + d);\r\n                symbol.each(function (x) {\r\n                    x = _.divide(x, q.clone());\r\n                    retval = _.add(retval, x);\r\n                });\r\n\r\n                factors.add(q);\r\n                return retval;\r\n            },\r\n            /**\r\n             * Removes GCD from coefficients\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @returns {Symbol}\r\n             */\r\n            coeffFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\r\n\r\n                    if(!gcd.equals(1)) {\r\n                        symbol.each(function (x) {\r\n                            if(x.isComposite()) {\r\n                                x.each(function (y) {\r\n                                    y.multiplier = y.multiplier.divide(gcd);\r\n                                });\r\n                            }\r\n                            else\r\n                                x.multiplier = x.multiplier.divide(gcd);\r\n                        });\r\n                        symbol.updateHash();\r\n                    }\r\n                    else {\r\n                        // TODO: This should probably go to the prototype\r\n                        var power = function (symbol) {\r\n                            var p;\r\n                            if(symbol.group === CB) {\r\n                                p = 0;\r\n                                symbol.each(function (x) {\r\n                                    p += x.power;\r\n                                });\r\n                            }\r\n                            else {\r\n                                p = Number(symbol.power);\r\n                            }\r\n                            return p;\r\n                        };\r\n                        // Factor out negatives from the lead term\r\n                        var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\r\n                            // Push constants to the back\r\n                            if(a.isConstant(true))\r\n                                return 1;\r\n                            return b.power - a.power;\r\n                        });\r\n\r\n                        var LT = terms[0];\r\n\r\n                        // Check if the LT is indeed the greatest\r\n                        if(power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\r\n                            if(LT.multiplier.lessThan(0)) {\r\n                                // Although the symbol should always be linear at this point, remove the negative for squares\r\n                                // to be safe.\r\n                                factors.add(new Symbol(-1));\r\n\r\n                                symbol.each(function (x) {\r\n                                    x.negate();\r\n                                }, true);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(factors) {\r\n                        factors.add(new Symbol(gcd));\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * The name says it all :)\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @@param {String} variable \r\n             * @returns {Symbol}\r\n             */\r\n            trialAndError: function (symbol, factors, variable) {\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    // At temp holder for the factors. If all goes well then\r\n                    // they'll be moved to the actual factors.\r\n                    var factor_array = [];\r\n\r\n                    if(symbol.isConstant() || symbol.group === S)\r\n                        return symbol;\r\n                    var poly = new Polynomial(symbol, variable),\r\n                            cnst = poly.coeffs[0],\r\n                            cfactors = core.Math2.ifactor(cnst),\r\n                            roots = __.proots(symbol);\r\n                    for(var i = 0; i < roots.length; i++) {\r\n                        var r = roots[i],\r\n                                p = 1;\r\n                        if(!isNaN(r)) { //if it's a number\r\n                            for(var x in cfactors) {\r\n                                //check it's raised to a power\r\n                                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\r\n                                if(isInt(n)) {\r\n                                    r = x; //x must be the root since n gave us a whole\r\n                                    p = n;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            var root = new Frac(r),\r\n                                    terms = [new Frac(root.num).negate()];\r\n                            terms[p] = new Frac(root.den);\r\n                            //convert to Frac. The den is coeff of LT and the num is coeff of constant\r\n                            var div = Polynomial.fromArray(terms, poly.variable).fill(),\r\n                                    t = poly.divide(div);\r\n                            if(t[1].equalsNumber(0)) { //if it's zero we have a root and divide it out\r\n                                poly = t[0];\r\n                                // factors.add(div.toSymbol());\r\n                                factor_array.push(div.toSymbol());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(!poly.equalsNumber(1)) {\r\n                        poly = __.Factor.search(poly, factors);\r\n                    }\r\n\r\n                    // Move the factors over since all went well.\r\n                    factor_array.forEach(function (x) {\r\n                        factors.add(x);\r\n                    });\r\n\r\n                    return poly.toSymbol();\r\n                }\r\n                catch(e) {\r\n                    return untouched;\r\n                }\r\n            },\r\n            search: function (poly, factors, base) {\r\n                base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\r\n                var v = poly.variable; //the polynmial variable name\r\n                /**\r\n                 * Attempt to remove a root by division given a number by first creating\r\n                 * a polynomial fromt he given information\r\n                 * @param {int} c1 - coeffient for the constant\r\n                 * @param {int} c2 - coefficient for the LT\r\n                 * @param {int} n - the number to be used to construct the polynomial\r\n                 * @param {int} p - the power at which to create the polynomial\r\n                 * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n                 */\r\n                var check = function (c1, c2, n, p) {\r\n                    var candidate = Polynomial.fit(c1, c2, n, base, p, v);\r\n                    if(candidate && candidate.coeffs.length > 1) {\r\n                        var t = poly.divide(candidate);\r\n                        if(t[1].equalsNumber(0)) {\r\n                            factors.add(candidate.toSymbol());\r\n                            return [t[0], candidate];\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n                var cnst = poly.coeffs[0];\r\n                var cfactors = core.Math2.ifactor(cnst);\r\n                var lc = poly.lc();\r\n                var ltfactors = core.Math2.ifactor(lc);\r\n                var subbed = poly.sub(base);\r\n                var isubbed = core.Math2.ifactor(subbed);\r\n                var nfactors = __.Factor.mix(isubbed, subbed < 0);\r\n                var cp = Math.ceil(poly.coeffs.length / 2);\r\n                var lc_is_neg = lc.lessThan(0);\r\n                var cnst_is_neg = cnst.lessThan(0);\r\n                ltfactors['1'] = 1;\r\n                cfactors['1'] = 1;\r\n                while(cp--) {\r\n                    for(var x in ltfactors) {\r\n                        for(var y in cfactors) {\r\n                            for(var i = 0; i < nfactors.length; i++) {\r\n                                var factor_found = check(x, y, nfactors[i], cp);\r\n                                if(factor_found) {\r\n                                    poly = factor_found[0];\r\n                                    if(!core.Utils.isPrime(poly.sub(base)))\r\n                                        poly = __.Factor.search(poly, factors);\r\n                                    return poly;\r\n                                }\r\n                                else if(!factor_found) {\r\n                                    if(lc_is_neg && cnst_is_neg)\r\n                                        factor_found = check(-x, -y, nfactors[i], cp);\r\n                                    else if(lc_is_neg)\r\n                                        factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\r\n                                    else if(cnst_is_neg)\r\n                                        factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return poly;\r\n            },\r\n            /**\r\n             * Equivalent of square free factor for multivariate polynomials\r\n             * @param {type} symbol\r\n             * @param {type} factors\r\n             * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n             */\r\n            mSqfrFactor: function (symbol, factors) {\r\n                if(symbol.group !== FN) {\r\n                    var vars = variables(symbol).reverse();\r\n\r\n                    // Loop through all the variable and remove the partial derivatives\r\n                    for(var i = 0; i < vars.length; i++) {\r\n                        do {\r\n                            if(vars[i] === symbol.value) {\r\n                                //the derivative tells us nothing since this symbol is already the factor\r\n                                factors.add(symbol);\r\n                                symbol = new Symbol(1);\r\n                                continue;\r\n                            }\r\n\r\n                            var diff = core.Calculus.diff(symbol, vars[i]);\r\n\r\n                            var d = __.Factor.coeffFactor(diff);\r\n\r\n                            if(d.equals(0))\r\n                                break;\r\n\r\n                            //trial division to see if factors have whole numbers. \r\n                            //This can be optimized by stopping as soon as can_divide is false\r\n                            //this will also need utilize big number at some point\r\n                            var can_divide = true;\r\n                            if(d.isConstant() && symbol.isComposite()) {\r\n                                //check the coefficients\r\n\r\n                                symbol.each(function (x) {\r\n                                    if(x.multiplier % d !== 0)\r\n                                        can_divide = false;\r\n                                }, true);\r\n                            }\r\n\r\n                            //if we can divide then do so\r\n                            if(can_divide) {\r\n\r\n                                var div = __.div(symbol, d.clone()),\r\n                                        is_factor = div[1].equals(0);\r\n\r\n                                if(div[0].isConstant()) {\r\n                                    factors.add(div[0]);\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else\r\n                                is_factor = false;\r\n\r\n                            if(is_factor) {\r\n                                factors.add(div[0]);\r\n                                symbol = d;\r\n                            }\r\n                        }\r\n                        while(is_factor)\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //difference of squares factorization\r\n            sqdiff: function (symbol, factors) {\r\n                if(symbol.isConstant('all')) {\r\n                    // Nothing to do\r\n                    return symbol;\r\n                }\r\n\r\n                try {\r\n                    var remove_square = function (x) {\r\n                        return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\r\n                            return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\r\n                        }, true);\r\n                    };\r\n                    var separated = core.Utils.separate(symbol.clone());\r\n\r\n                    var obj_array = [];\r\n\r\n                    //get the unique variables\r\n                    for(var x in separated) {\r\n                        if(x !== 'constants') {\r\n                            obj_array.push(separated[x]);\r\n                        }\r\n                    }\r\n                    obj_array.sort(function (a, b) {\r\n                        return b.power - a.power;\r\n                    });\r\n\r\n                    //if we have the same number of variables as unique variables then we can apply the difference of squares\r\n                    if(obj_array.length === 2) {\r\n                        var a, b;\r\n                        a = obj_array.pop();\r\n                        b = obj_array.pop();\r\n\r\n                        if(even(a.power) && even(b.power)\r\n                                && a.sign() === b.sign()\r\n                                && a.group === S && b.group === S) {\r\n                            throw new Error('Unable to factor');\r\n                        }\r\n                        ;\r\n\r\n                        if(a.isComposite() && b.power.equals(2)) {\r\n                            //remove the square from b\r\n                            b = remove_square(b);\r\n                            var f = __.Factor.factor(_.add(a, separated.constants));\r\n                            if(f.power.equals(2)) {\r\n                                f.toLinear();\r\n                                factors.add(_.subtract(f.clone(), b.clone()));\r\n                                factors.add(_.add(f, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                        else {\r\n                            a = a.powSimp();\r\n                            b = b.powSimp();\r\n\r\n                            if((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\r\n                                if(a.multiplier.lessThan(0)) {\r\n                                    var t = b;\r\n                                    b = a;\r\n                                    a = t;\r\n                                }\r\n                                if(a.multiplier.greaterThan(0)) {\r\n                                    a = remove_square(a);\r\n                                    b = remove_square(b);\r\n                                }\r\n\r\n                                factors.add(_.subtract(a.clone(), b.clone()));\r\n                                factors.add(_.add(a, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //factoring for multivariate\r\n            mfactor: function (symbol, factors) {\r\n\r\n                if(symbol.group === FN) {\r\n                    if(symbol.fname === 'sqrt') {\r\n                        var factors2 = new Factors(),\r\n                                arg = __.Factor.common(symbol.args[0].clone(), factors2);\r\n                        arg = __.Factor.coeffFactor(arg, factors2);\r\n                        symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\r\n                        factors2.each(function (x) {\r\n                            symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\r\n                        });\r\n                    }\r\n                    else\r\n                        factors.add(symbol);\r\n                }\r\n                else {\r\n\r\n                    //square free factorization\r\n                    symbol = __.Factor.mSqfrFactor(symbol, factors);\r\n\r\n                    //try factor out common factors\r\n                    //symbol = __.Factor.common(symbol, factors);\r\n\r\n                    var vars = variables(symbol),\r\n                            symbols = symbol.collectSymbols().map(function (x) {\r\n                        return Symbol.unwrapSQRT(x);\r\n                    }),\r\n                            sorted = {},\r\n                            maxes = {},\r\n                            l = vars.length, n = symbols.length;\r\n                    //take all the variables in the symbol and organize by variable name\r\n                    //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\r\n\r\n                    for(var i = 0; i < l; i++) {\r\n                        var v = vars[i];\r\n                        sorted[v] = new Symbol(0);\r\n                        for(var j = 0; j < n; j++) {\r\n                            var s = symbols[j];\r\n                            if(s.contains(v)) {\r\n                                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\r\n                                if(!maxes[v] || p < maxes[v])\r\n                                    maxes[v] = p;\r\n                                sorted[v] = _.add(sorted[v], s.clone());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    for(var x in sorted) {\r\n                        var r = _.parse(x + '^' + maxes[x]);\r\n                        var div = _.divide(sorted[x], r);\r\n                        var new_factor = _.expand(div);\r\n\r\n                        if(new_factor.equals(1))\r\n                            break; //why divide by one. Just move \r\n                        var divided = __.div(symbol.clone(), new_factor);\r\n\r\n                        if(divided[0].equals(0)) {\r\n                            //cant factor anymore\r\n                            break;\r\n                        }\r\n\r\n                        // We potentially ended up with fractional coefficients when the\r\n                        // trial division was performed. We need to remove \r\n                        // This check will more then likely become superfluous with improvements\r\n                        // to polynomial division\r\n                        if(divided[1].equals(0)) {\r\n                            var has_fractions = false;\r\n\r\n                            divided[0].each(function (x) {\r\n                                if(!isInt(x.multiplier)) {\r\n                                    has_fractions = true;\r\n                                }\r\n                            });\r\n\r\n                            // The factor isn't really a factor and needs to be put back\r\n                            if(has_fractions) {\r\n                                divided[1] = _.expand(_.multiply(divided[1], new_factor));\r\n                                // Since the new factor is not just one, we exit.\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\r\n\r\n                        if(divided[1].equals(0) && !neg_numeric_factor) { //we found at least one factor\r\n\r\n                            //factors.add(new_factor);\r\n                            var d = __.div(symbol.clone(), divided[0].clone());\r\n                            var r = d[0];\r\n\r\n                            // Nothing left to do since we didn't get a reduction\r\n                            if(r.equals(0)) {\r\n                                return symbol;\r\n                            }\r\n\r\n                            symbol = d[1];\r\n                            //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\r\n                            //and we just return the symbol;\r\n                            //If r equals zero then there's nothing left to do so we're done\r\n\r\n                            if(r.equals(-1) && !symbol.equals(0))\r\n                                return symbol;\r\n\r\n                            var factor = divided[0];\r\n\r\n                            if(symbol.equals(factor)) {\r\n                                var rem = __.Factor.reduce(factor, factors);\r\n\r\n                                if(!symbol.equals(rem))\r\n                                    return __.Factor.mfactor(rem, factors);\r\n\r\n                                return rem;\r\n                            }\r\n                            else {\r\n                                factors.add(factor);\r\n                                //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\r\n                                if(symbol.equals(0))\r\n                                    return r;\r\n                            }\r\n\r\n                            if(r.isConstant('all')) {\r\n                                factors.add(r);\r\n                                return r;\r\n                            }\r\n\r\n                            return __.Factor.mfactor(r, factors);\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                //difference of squares factorization\r\n                symbol = __.Factor.sqdiff(symbol, factors);\r\n\r\n                //factors by fishing for zeroes\r\n                symbol = __.Factor.zeroes(symbol, factors);\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        /**\r\n         * Checks to see if a set of \"equations\" is linear. \r\n         * @param {type} set\r\n         * @returns {Boolean}\r\n         */\r\n        allLinear: function (set) {\r\n            var l = set.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(!__.isLinear(set[i]))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /*\r\n         * Checks to see if the \"equation\" is linear\r\n         * @param {Symbol} e\r\n         * @returns {boolean}\r\n         */\r\n        isLinear: function (e) {\r\n            var status = false, g = e.group;\r\n            if(g === PL || g === CP) {\r\n                status = true;\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s], sg = symbol.group;\r\n                    if(sg === FN || sg === EX) {\r\n                        status = false;\r\n                    }\r\n                    if(sg === CB) {\r\n                        //needs further checking since it might be imaginary\r\n                        status = variables(symbol).length === 1;\r\n                    }\r\n                    else {\r\n                        if(sg === PL || sg === CP)\r\n                            status = __.isLinear(symbol);\r\n                        else {\r\n                            if(symbol.group !== N && symbol.power.toString() !== '1') {\r\n                                status = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(g === S && e.power === 1)\r\n                status = true;\r\n            return status;\r\n        },\r\n        gcd: function () {\r\n            var args;\r\n            if(arguments.length === 1 && arguments[0] instanceof core.Vector)\r\n                args = arguments[0].elements;\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //short-circuit early\r\n            if(args.length === 0)\r\n                return new Symbol(1);\r\n            else if(args.length === 1)\r\n                return args[0];\r\n\r\n            var appeared = [], evaluate = false;\r\n            for(var i = 0; i < args.length; i++) {\r\n                if(args[i].group === FN && args[i].fname === 'gcd')\r\n                {\r\n                    //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\r\n                    args = args.concat(arguments[i].args);\r\n                    //do not keep gcd in args\r\n                    args.splice(i, 1);\r\n                }\r\n                else\r\n                {\r\n                    //Look if there are any common variables such that\r\n                    //gcd(a,b) => gcd(a,b); gcd(a,a) => a\r\n                    var vars = variables(args[i]);\r\n                    if(core.Utils.haveIntersection(vars, appeared))\r\n                    {\r\n                        //Ok, there are common variables\r\n                        evaluate = true;\r\n                        break;\r\n                    }\r\n                    else\r\n                        appeared = appeared.concat(vars);\r\n                }\r\n            }\r\n\r\n            //appeared.length is 0 when all arguments are group N\r\n            if(evaluate || appeared.length === 0) {\r\n                //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\r\n                if(args.every(function (symbol) {\r\n                    return symbol.getDenom().equals(1)\r\n                })) {\r\n                    var aggregate = args[0];\r\n\r\n                    for(var i = 1; i < args.length; i++) {\r\n                        aggregate = __.gcd_(args[i], aggregate);\r\n                    }\r\n                    return aggregate;\r\n                }\r\n                else {\r\n                    //gcd_ cannot handle denominators correctly\r\n                    return _.divide(__.gcd.apply(null, args.map(function (symbol) {\r\n                        return symbol.getNum();\r\n                    })),\r\n                            __.lcm.apply(null, args.map(function (symbol) {\r\n                                return symbol.getDenom();\r\n                            })));\r\n                }\r\n            }\r\n            else\r\n                return _.symfunction('gcd', args);\r\n        },\r\n        gcd_: function (a, b) {\r\n            if(a.group === FN || a.group === P)\r\n                a = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(a);\r\n                });\r\n\r\n            if(b.group === FN)\r\n                b = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(b);\r\n                });\r\n\r\n            if(a.isConstant() && b.isConstant()) {\r\n                // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\r\n                return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\r\n            }\r\n\r\n            var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\r\n            a = _.multiply(a.clone(), den.clone());\r\n            b = _.multiply(b.clone(), den.clone());\r\n\r\n            //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\r\n            a = _.expand(a);\r\n            b = _.expand(b);\r\n\r\n            if(a.group === CB || b.group === CB) {\r\n                var q = _.divide(a.clone(), b.clone()); //get the quotient\r\n                var t = _.multiply(b.clone(), q.getDenom().invert());//multiply by the denominator\r\n                //if they have a common factor then the result will not equal one \r\n                if(!t.equals(1))\r\n                    return t;\r\n            }\r\n\r\n            //just take the gcd of each component when either of them is in group EX\r\n            if(a.group === EX || b.group === EX)\r\n            {\r\n                var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\r\n                var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\r\n                var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\r\n                return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\r\n            }\r\n\r\n            if(a.length < b.length) { //swap'm\r\n                var t = a;\r\n                a = b;\r\n                b = t;\r\n            }\r\n            var vars_a = variables(a), vars_b = variables(b);\r\n            if((vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0])\r\n                    || vars_a.length === 1 && vars_b.length === 0\r\n                    || vars_a.length === 0 && vars_b.length === 1) {\r\n                a = new Polynomial(a);\r\n                b = new Polynomial(b);\r\n                return _.divide(a.gcd(b).toSymbol(), den);\r\n            }\r\n            else {\r\n                //get the gcd of the multipiers\r\n                //get rid of gcd in coeffs\r\n                var multipliers = [];\r\n                a.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n                b.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n\r\n                var T;\r\n                while(!b.equals(0)) {\r\n                    var t = b.clone();\r\n                    a = a.clone();\r\n                    T = __.div(a, t);\r\n\r\n                    b = T[1];\r\n                    if(T[0].equals(0)) {\r\n                        //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\r\n                        return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\r\n                    }\r\n                    a = t;\r\n                }\r\n\r\n                var gcd = core.Math2.QGCD.apply(undefined, multipliers);\r\n\r\n                if(!gcd.equals(1)) {\r\n                    a.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(gcd);\r\n                    });\r\n                }\r\n\r\n                //return symbolic function for gcd in indeterminate form\r\n                if(a.equals(1) && !a.isConstant() && !b.isConstant())\r\n                    return _.divide(_.symfunction('gcd', arguments), den);\r\n\r\n                return _.divide(a, den);\r\n            }\r\n        },\r\n        lcm: function () {\r\n            //https://math.stackexchange.com/a/319310\r\n            //generalization of the 2-variable formula of lcm\r\n\r\n            var args;\r\n            if(arguments.length === 1)\r\n                if(arguments[0] instanceof core.Vector)\r\n                    args = arguments[0].elements;\r\n                else\r\n                    _.error('lcm expects either 1 vector or 2 or more arguments');\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //product of all arguments\r\n            //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n            var numer = args.reduce(function (prev, curr) {\r\n                return _.multiply(prev, curr.clone())\r\n            }, new Symbol(1));\r\n\r\n            //gcd of complementary terms\r\n            var denom_args =\r\n                    //https://stackoverflow.com/a/18223072\r\n                //take all complementary terms, e.g.\r\n                //[a,b,c] => [a*b, b*c, a*c]\r\n                //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\r\n                (function (input, size) {\r\n                        size = Number(size);\r\n                        var results = [], result, mask, i, total = Math.pow(2, input.length);\r\n                        for(mask = size; mask < total; mask++) {\r\n                            result = [];\r\n                            i = input.length - 1;\r\n\r\n                            do {\r\n                                if((mask & (1 << i)) !== 0) {\r\n                                    result.push(input[i]);\r\n                                }\r\n                            }\r\n                            while(i--);\r\n\r\n                            if(result.length === size) {\r\n                                results.push(result);\r\n                            }\r\n                        }\r\n                        return results;\r\n                        //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n                    })(arguments, arguments.length - 1).map(function (x) {\r\n                return x.reduce(function (prev, curr) {\r\n                    return _.multiply(prev, curr.clone())\r\n                }, new Symbol(1))\r\n            });\r\n\r\n            var denom;\r\n            //don't eat the gcd term if all arguments are symbols\r\n            if(args.every(function (x) {\r\n                return core.Utils.isVariableSymbol(x)\r\n            }))\r\n                denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));\r\n            else\r\n                denom = __.gcd.apply(null, denom_args);\r\n            //divide product of all arguments by gcd of complementary terms\r\n            var div = _.divide(numer, denom);\r\n            return div;\r\n        },\r\n        /**\r\n         * Divides one expression by another\r\n         * @param {Symbol} symbol1\r\n         * @param {Symbol} symbol2\r\n         * @returns {Array}\r\n         */\r\n        divide: function (symbol1, symbol2) {\r\n            var result, remainder, factored, den;\r\n            factored = core.Algebra.Factor.factor(symbol1.clone());\r\n            den = factored.getDenom();\r\n            if(!den.isConstant('all')) {\r\n                symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\r\n            }\r\n            else\r\n                //reset the denominator since we're not dividing by it anymore\r\n                den = new Symbol(1);\r\n            result = __.div(symbol1, symbol2);\r\n            remainder = _.divide(result[1], symbol2);\r\n            return _.divide(_.add(result[0], remainder), den);\r\n        },\r\n        div: function (symbol1, symbol2) {\r\n            // If all else fails then assume that division failed with\r\n            // a remainder of zero and the original quotient\r\n            var fail = [new Symbol(0), symbol1.clone()];\r\n\r\n            try {\r\n\r\n                // Division by constants\r\n                if(symbol2.isConstant('all')) {\r\n                    symbol1.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(symbol2.multiplier);\r\n                    });\r\n                    return [symbol1, new Symbol(0)];\r\n                }\r\n                // So that factorized symbols don't affect the result\r\n                symbol1 = _.expand(symbol1);\r\n                symbol2 = _.expand(symbol2);\r\n                // Special case. May need revisiting\r\n                if(symbol1.group === S && symbol2.group === CP) {\r\n                    var x = symbol1.value;\r\n                    var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\r\n                    if(symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\r\n                        var k = Symbol.create(symbol1.multiplier);\r\n                        return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\r\n                    }\r\n                }\r\n                if(symbol1.group === S && symbol2.group === S) {\r\n                    var r = _.divide(symbol1.clone(), symbol2.clone());\r\n                    if(r.isConstant()) //we have a whole\r\n                        return [r, new Symbol(0)];\r\n                    return [new Symbol(0), symbol1.clone()];\r\n                }\r\n                var symbol1_has_func = symbol1.hasFunc(),\r\n                        symbol2_has_func = symbol2.hasFunc(),\r\n                        parse_funcs = false;\r\n\r\n                //substitute out functions so we can treat them as regular variables\r\n                if(symbol1_has_func || symbol2_has_func) {\r\n                    parse_funcs = true;\r\n                    var map = {},\r\n                            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\r\n                            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\r\n                            subs = core.Utils.getFunctionsSubs(map);\r\n                }\r\n                //get a list of the variables\r\n                var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\r\n                        quot, rem;\r\n\r\n                //treat imaginary numbers as variables\r\n                if(symbol1.isImaginary() || symbol2.isImaginary()) {\r\n                    vars.push(core.Settings.IMAGINARY);\r\n                }\r\n\r\n                if(vars.length === 1) {\r\n                    var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\r\n                    quot = q[0].toSymbol();\r\n                    rem = q[1].toSymbol();\r\n                }\r\n                else {\r\n                    vars.push(CONST_HASH); //this is for the numbers\r\n                    var reconvert = function (arr) {\r\n                        var symbol = new Symbol(0);\r\n                        for(var i = 0; i < arr.length; i++) {\r\n                            var x = arr[i].toSymbol();\r\n                            symbol = _.add(symbol, x);\r\n                        }\r\n                        return symbol;\r\n                    };\r\n\r\n                    // Silly Martin. This is why you document. I don't remember now\r\n                    var get_unique_max = function (term, any) {\r\n                        var max = Math.max.apply(null, term.terms),\r\n                                count = 0, idx;\r\n\r\n                        if(!any) {\r\n                            for(var i = 0; i < term.terms.length; i++) {\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    count++;\r\n                                }\r\n                                if(count > 1)\r\n                                    return;\r\n                            }\r\n                        }\r\n                        if(any) {\r\n                            for(i = 0; i < term.terms.length; i++)\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    break;\r\n                                }\r\n                        }\r\n                        return [max, idx, term];\r\n                    };\r\n\r\n                    // Tries to find an LT in the dividend that will satisfy division\r\n                    var get_det = function (s, lookat) {\r\n                        lookat = lookat || 0;\r\n                        var det = s[lookat], l = s.length;\r\n                        if(!det)\r\n                            return;\r\n                        //eliminate the first term if it doesn't apply\r\n                        var umax = get_unique_max(det);\r\n                        for(var i = lookat + 1; i < l; i++) {\r\n                            var term = s[i],\r\n                                    is_equal = det.sum.equals(term.sum);\r\n                            if(!is_equal && umax) {\r\n                                break;\r\n                            }\r\n                            if(is_equal) {\r\n                                // Check the differences of their maxes. The one with the biggest difference governs\r\n                                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\r\n                                var max1, max2, idx1, idx2, l2 = det.terms.length;\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var item1 = det.terms[j], item2 = term.terms[j];\r\n                                    if(typeof max1 === 'undefined' || item1.greaterThan(max1)) {\r\n                                        max1 = item1;\r\n                                        idx1 = j;\r\n                                    }\r\n                                    if(typeof max2 === 'undefined' || item2.greaterThan(max2)) {\r\n                                        max2 = item2;\r\n                                        idx2 = j;\r\n                                    }\r\n                                }\r\n                                //check their differences\r\n                                var d1 = max1.subtract(term.terms[idx1]),\r\n                                        d2 = max2.subtract(det.terms[idx2]);\r\n                                if(d2 > d1) {\r\n                                    umax = [max2, idx2, term];\r\n                                    break;\r\n                                }\r\n                                if(d1 > d2) {\r\n                                    umax = [max1, idx1, det];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else {\r\n                                //check if it's a suitable pick to determine the order\r\n                                umax = get_unique_max(term);\r\n                                //if(umax) return umax;\r\n                                if(umax)\r\n                                    break;\r\n                            }\r\n                            umax = get_unique_max(term); //calculate a new unique max\r\n                        }\r\n\r\n                        //if still no umax then any will do since we have a tie\r\n                        if(!umax)\r\n                            return get_unique_max(s[0], true);\r\n                        var e, idx;\r\n                        for(var i = 0; i < s2.length; i++) {\r\n                            var cterm = s2[i].terms;\r\n                            //confirm that this is a good match for the denominator\r\n                            idx = umax[1];\r\n                            if(idx === cterm.length - 1)\r\n                                return;\r\n                            e = cterm[idx];\r\n                            if(!e.equals(0))\r\n                                break;\r\n                        }\r\n                        if(e.equals(0))\r\n                            return get_det(s, ++lookat); //look at the next term\r\n\r\n                        return umax;\r\n                    };\r\n\r\n                    var t_map = core.Utils.toMapObj(vars);\r\n                    var init_sort = function (a, b) {\r\n                        return b.sum.subtract(a.sum);\r\n                    };\r\n                    var is_larger = function (a, b) {\r\n                        if(!a || !b)\r\n                            return false; //it's empty so...\r\n                        for(var i = 0; i < a.terms.length; i++) {\r\n                            if(a.terms[i].lessThan(b.terms[i]))\r\n                                return false;\r\n                        }\r\n                        return true;\r\n                    };\r\n\r\n                    var s1 = symbol1.tBase(t_map).sort(init_sort),\r\n                            s2 = symbol2.tBase(t_map).sort(init_sort);\r\n                    var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\r\n                    var det = get_det(target);//we'll begin by assuming that this will let us know which term \r\n                    var quotient = [];\r\n                    if(det) {\r\n                        var lead_var = det[1];\r\n                        var can_divide = function (a, b) {\r\n                            if(a[0].sum.equals(b[0].sum))\r\n                                return a.length >= b.length;\r\n                            return true;\r\n                        };\r\n\r\n                        var try_better_lead_var = function (s1, s2, lead_var) {\r\n                            var checked = [];\r\n                            for(var i = 0; i < s1.length; i++) {\r\n                                var t = s1[i];\r\n                                for(var j = 0; j < t.terms.length; j++) {\r\n                                    var cf = checked[j], tt = t.terms[j];\r\n                                    if(i === 0)\r\n                                        checked[j] = tt; //add the terms for the first one\r\n                                    else if(cf && !cf.equals(tt))\r\n                                        checked[j] = undefined;\r\n                                }\r\n                            }\r\n                            for(var i = 0; i < checked.length; i++) {\r\n                                var t = checked[i];\r\n                                if(t && !t.equals(0))\r\n                                    return i;\r\n                            }\r\n                            return lead_var;\r\n                        };\r\n                        var sf = function (a, b) {\r\n                            var l1 = a.len(), l2 = b.len();\r\n                            var blv = b.terms[lead_var], alv = a.terms[lead_var];\r\n                            if(l2 > l1 && blv.greaterThan(alv))\r\n                                return l2 - l1;\r\n                            return blv.subtract(alv);\r\n                        };\r\n\r\n                        //check to see if there's a better lead_var\r\n                        lead_var = try_better_lead_var(s1, s2, lead_var);\r\n                        //reorder both according to the max power\r\n                        s1.sort(sf); //sort them both according to the leading variable power\r\n                        s2.sort(sf);\r\n\r\n                        //try to adjust if den is larger\r\n                        var fdt = s2[0], fnt = s1[0];\r\n\r\n                        var den = new MVTerm(new Frac(1), [], fnt.map);\r\n                        if(fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\r\n                            for(var i = 0; i < fnt.terms.length; i++) {\r\n                                var d = fdt.terms[i].subtract(fnt.terms[i]);\r\n                                if(!d.equals(0)) {\r\n                                    var nd = d.add(new Frac(1));\r\n                                    den.terms[i] = d;\r\n                                    for(var j = 0; j < s1.length; j++) {\r\n                                        s1[j].terms[i] = s1[j].terms[i].add(nd);\r\n                                    }\r\n                                }\r\n                                else\r\n                                    den.terms[i] = new Frac(0);\r\n                            }\r\n                        }\r\n\r\n                        var dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                        var safety = 0;\r\n                        var max = 200;\r\n\r\n                        while(dividend_larger && can_divide(s1, s2)) {\r\n                            if(safety++ > max) {\r\n                                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\r\n                            }\r\n\r\n                            var q = s1[0].divide(s2[0]);\r\n\r\n                            quotient.push(q); //add what's divided to the quotient\r\n                            s1.shift();//the first one is guaranteed to be gone so remove from dividend\r\n                            for(var i = 1; i < s2.length; i++) { //loop through the denominator\r\n                                var t = s2[i].multiply(q).generateImage(),\r\n                                        l2 = s1.length;\r\n                                //if we're subtracting from 0\r\n                                if(l2 === 0) {\r\n                                    t.coeff = t.coeff.neg();\r\n                                    s1.push(t);\r\n                                    s1.sort(sf);\r\n                                }\r\n\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var cur = s1[j];\r\n                                    if(cur.getImg() === t.getImg()) {\r\n                                        cur.coeff = cur.coeff.subtract(t.coeff);\r\n                                        if(cur.coeff.equals(0)) {\r\n                                            core.Utils.remove(s1, j);\r\n                                            j--; //adjust the iterator\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if(j === l2 - 1) {\r\n                                        t.coeff = t.coeff.neg();\r\n                                        s1.push(t);\r\n                                        s1.sort(sf);\r\n                                    }\r\n                                }\r\n                            }\r\n                            dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                            if(!dividend_larger && s1.length >= s2.length) {\r\n                                //One more try since there might be a terms that is larger than the LT of the divisor\r\n                                for(var i = 1; i < s1.length; i++) {\r\n                                    dividend_larger = is_larger(s1[i], s2[0]);\r\n                                    if(dividend_larger) {\r\n                                        //take it from its current position and move it to the front\r\n                                        s1.unshift(core.Utils.remove(s1, i));\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    quot = reconvert(quotient);\r\n                    rem = reconvert(s1);\r\n\r\n                    if(typeof den !== 'undefined') {\r\n                        den = den.toSymbol();\r\n                        quot = _.divide(quot, den.clone());\r\n                        rem = _.divide(rem, den);\r\n                    }\r\n                }\r\n\r\n                //put back the functions\r\n                if(parse_funcs) {\r\n                    quot = _.parse(quot.text(), subs);\r\n                    rem = _.parse(rem.text(), subs);\r\n                }\r\n\r\n                return [quot, rem];\r\n            }\r\n            catch(e) {\r\n                return fail;\r\n            }\r\n\r\n        },\r\n        line: function (v1, v2, x) {\r\n            if(core.Utils.isArray(v1))\r\n                v1 = core.Utils.convertToVector(v1);\r\n            if(core.Utils.isArray(v2))\r\n                v2 = core.Utils.convertToVector(v2);\r\n            x = _.parse(x || 'x');\r\n            if(!core.Utils.isVector(v1) || !core.Utils.isVector(v2))\r\n                _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\r\n            var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\r\n                    dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\r\n                    m = _.divide(dy, dx),\r\n                    a = _.multiply(x, m.clone()),\r\n                    b = _.multiply(v1.e(1).clone(), m);\r\n            return _.add(_.subtract(a, b), v1.e(2).clone());\r\n        },\r\n        PartFrac: {\r\n            createTemplate: function (den, denom_factors, f_array, v) {\r\n                //clean up the denominator function by factors so it reduces nicely\r\n                den = __.Factor.factor(den);\r\n\r\n                //clean up factors. This is so inefficient but factors are wrapped in parens for safety\r\n                den.each(function (x, key) {\r\n                    if(x.group === FN && x.fname === '' && x.args[0].group === S) {\r\n                        var y = x.args[0];\r\n                        if(this.symbols) {\r\n                            delete this.symbols[key];\r\n                            this.symbols[y.value] = y;\r\n                        }\r\n                        else {\r\n                            den = x.args[0];\r\n                        }\r\n                    }\r\n                });\r\n\r\n                var factors, factors_vec, f, p, deg, degrees, m;\r\n                factors = denom_factors.collectFactors();\r\n                factors_vec = []; //a vector for the template\r\n                degrees = [];\r\n                m = new Symbol(1);\r\n\r\n                for(var i = 0; i < factors.length; i++) { //loop through the factors\r\n                    var factor = Symbol.unwrapPARENS(factors[i]);\r\n                    //if in he for P^n where P is polynomial and n = integer\r\n                    if(factor.power.greaterThan(1)) {\r\n                        p = Number(factor.power);\r\n                        f = factor.clone().toLinear(); //remove the power so we have only the function\r\n                        deg = Number(__.degree(f, v)); //get the degree of f\r\n                        //expand the factor\r\n                        for(var j = 0; j < p; j++) {\r\n                            var efactor = _.pow(f.clone(), new Symbol(j + 1));\r\n                            f_array.push(efactor.clone());\r\n                            var d = _.divide(den.clone(), efactor.clone());\r\n                            degrees.push(deg);\r\n                            factors_vec.push(d);\r\n                        }\r\n                    }\r\n                    /*\r\n                     Possible bug.\r\n                     Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n                     else if(factor.isConstant('all')) {\r\n                     m = _.multiply(m, factor);\r\n                     }\r\n                     */\r\n                    else {\r\n                        //get the degree of the factor so we tack it on tot he factor. This should probably be an array\r\n                        //but for now we note it on the symbol\r\n                        deg = Number(__.degree(factor, v));\r\n                        f_array.push(factor);\r\n                        var d = _.divide(den.clone(), factor.clone());\r\n                        d = _.expand(Symbol.unwrapPARENS(d));\r\n                        degrees.push(deg);\r\n                        factors_vec.push(d);\r\n                    }\r\n                }\r\n                //put back the constant\r\n                f_array = f_array.map(function (x) {\r\n                    return _.multiply(x, m.clone());\r\n                });\r\n                return [f_array, factors_vec, degrees];\r\n            },\r\n            partfrac: function (symbol, v, as_array) {\r\n\r\n                var vars = variables(symbol);\r\n\r\n                v = v || _.parse(vars[0]); //make wrt optional and assume first variable\r\n                try {\r\n                    var num, den, factors, tfactors, ofactors, nterms, degrees,\r\n                            dterms, max, M, c, powers, div, r, factors_vec, ks,\r\n                            template, tfactors;\r\n                    num = _.expand(symbol.getNum());\r\n                    den = _.expand(symbol.getDenom().toUnitMultiplier());\r\n                    //move the entire multipier to the numerator\r\n                    num.multiplier = symbol.multiplier;\r\n                    //we only have a meaningful change if n factors > 1. This means that\r\n                    //the returned group will be a CB\r\n                    //collect the terms wrt the x\r\n                    nterms = num.groupTerms(v);\r\n                    //divide out wholes if top is larger\r\n                    if(Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\r\n                        div = __.div(num.clone(), _.expand(den.clone()));\r\n                        r = div[0]; //remove the wholes\r\n                        num = div[1]; //work with the remainder\r\n                        nterms = num.groupTerms(v); //recalculate the nterms\r\n                    }\r\n                    else\r\n                        r = new Symbol(0);\r\n\r\n                    if(Number(__.degree(den, v)) === 1) {\r\n                        var q = _.divide(num, den);\r\n                        if(as_array)\r\n                            return [r, q];\r\n                        return _.add(r, q);\r\n                    }\r\n                    //first factor the denominator. This means that the strength of this\r\n                    //algorithm depends on how well we can factor the denominator. \r\n                    ofactors = __.Factor.factor(den);\r\n                    //create the template. This method will create the template for solving \r\n                    //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\r\n                    template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\r\n                    tfactors = template[0]; //grab the factors\r\n                    factors_vec = template[1]; //grab the factor vectors\r\n                    degrees = template[2]; //grab the degrees\r\n                    //make note of the powers of each term\r\n                    powers = [nterms.length];\r\n                    //create the dterms vector\r\n                    dterms = [];\r\n                    factors = [];\r\n                    ks = [];\r\n                    var factor, deg;\r\n                    factors_vec.map(function (x, idx) {\r\n                        factor = tfactors[idx];\r\n                        deg = degrees[idx];\r\n                        for(var i = 0; i < deg; i++) {\r\n                            factors.push(factor.clone());\r\n                            var k = Symbol.create(v, i);\r\n                            var t = _.expand(_.multiply(x, k.clone())).groupTerms(v);\r\n                            //make a note of the power which corresponds to the length of the array\r\n                            var p = t.length;\r\n                            powers.push(p);\r\n                            dterms.push(t);\r\n                            ks.push(k.clone());\r\n                        }\r\n                    });\r\n                    //get the max power\r\n                    max = core.Utils.arrayMax(powers);\r\n\r\n                    //fill the holes and create a matrix\r\n                    c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();\r\n                    //for each of the factors we do the same\r\n                    M = new core.Matrix();\r\n                    for(var i = 0; i < dterms.length; i++) {\r\n                        M.elements.push(core.Utils.fillHoles(dterms[i], max));\r\n                    }\r\n\r\n                    //solve the system of equations\r\n                    var partials = _.multiply(M.transpose().invert(), c);\r\n                    //the results are backwards to reverse it\r\n                    //partials.elements.reverse();\r\n                    //convert it all back\r\n                    var retval = as_array ? [r] : r;\r\n                    partials.each(function (e, i) {\r\n                        var term = _.multiply(ks[i], _.divide(e, factors[i]));\r\n                        if(as_array)\r\n                            retval.push(term);\r\n                        else\r\n                            retval = _.add(retval, term);\r\n                    });\r\n\r\n                    //done\r\n                    return retval;\r\n                }\r\n                catch(e) {\r\n                    //try to group symbols\r\n                    try {\r\n                        if(symbol.isComposite()) {\r\n                            //group denominators\r\n                            var denominators = {};\r\n\r\n                            symbol.each(function (x) {\r\n                                var d = x.getDenom();\r\n                                var n = x.getNum();\r\n                                var e = denominators[d];\r\n                                denominators[d] = e ? _.add(e, n) : n;\r\n                            });\r\n\r\n                            var t = new Symbol(0);\r\n\r\n                            for(var x in denominators) {\r\n                                t = _.add(t, _.divide(denominators[x], _.parse(x)));\r\n                            }\r\n\r\n                            symbol = t;\r\n                        }\r\n                    }\r\n                    catch(e2) {\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        degree: function (symbol, v, o) {\r\n            o = o || {\r\n                nd: [], //numeric\r\n                sd: [], //symbolic\r\n                depth: 0 //call depth\r\n            };\r\n\r\n            if(!v) {\r\n                var vars = variables(symbol);\r\n                //The user must specify the variable for multivariate\r\n                if(vars.length > 1)\r\n                    throw new Error('You must specify the variable for multivariate polynomials!');\r\n                //if it's empty then we're dealing with a constant\r\n                if(vars.length === 0)\r\n                    return new Symbol(0);\r\n                //assume the variable for univariate\r\n                v = _.parse(vars[0]);\r\n            }\r\n\r\n            //store the group\r\n            var g = symbol.group;\r\n            //we're going to trust the user and assume no EX. Calling isPoly \r\n            //would eliminate this but no sense in checking twice. \r\n            if(symbol.isComposite()) {\r\n                symbol = symbol.clone();\r\n                symbol.distributeExponent();\r\n                symbol.each(function (x) {\r\n                    o.depth++; //mark a depth increase\r\n                    __.degree(x, v, o);\r\n                    o.depth--; //we're back\r\n                });\r\n            }\r\n            else if(symbol.group === CB) {\r\n                symbol.each(function (x) {\r\n                    o.depth++;\r\n                    __.degree(x, v, o);\r\n                    o.depth++;\r\n                });\r\n            }\r\n            else if(g === EX && symbol.value === v.value) {\r\n                o.sd.push(symbol.power.clone());\r\n            }\r\n            else if(g === S && symbol.value === v.value) {\r\n                o.nd.push(_.parse(symbol.power));\r\n            }\r\n            else\r\n                o.nd.push(new Symbol(0));\r\n\r\n            //get the max out of the array\r\n            var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\r\n\r\n            if(o.depth === 0 && o.sd.length > 0) {\r\n                if(deg !== undefined)\r\n                    o.sd.unshift(deg);\r\n                return _.symfunction('max', o.sd);\r\n            }\r\n            if(!core.Utils.isSymbol(deg))\r\n                deg = _.parse(deg);\r\n            //return the degree\r\n            return deg;\r\n        },\r\n        /**\r\n         * Attempts to complete the square of a polynomial\r\n         * @param {type} symbol\r\n         * @param {type} v\r\n         * @param {type} raw\r\n         * @throws {Error} \r\n         * @returns {Object|Symbol[]}\r\n         */\r\n        sqComplete: function (symbol, v, raw) {\r\n            if(!core.Utils.isSymbol(v))\r\n                v = _.parse(v);\r\n            var stop = function (msg) {\r\n                msg = msg || 'Stopping';\r\n                throw new core.exceptions.ValueLimitExceededError(msg);\r\n            };\r\n            //if not CP then nothing to do\r\n            if(!symbol.isPoly(true))\r\n                stop('Must be a polynomial!');\r\n\r\n            //declare vars\r\n            var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\r\n\r\n            br = core.Utils.inBrackets;\r\n            //make a copy\r\n            symbol = symbol.clone();\r\n            deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\r\n            //must be in form ax^2 +/- bx +/- c\r\n            if(!deg.equals(2))\r\n                stop('Cannot complete square for degree ' + deg);\r\n            //get the coeffs\r\n            coeffs = core.Algebra.coeffs(symbol, v);\r\n            a = coeffs[2];\r\n            //store the sign\r\n            sign = coeffs[1].sign();\r\n            //divide the linear term by two and square it\r\n            b = _.divide(coeffs[1], new Symbol(2));\r\n            //add the difference to the constant\r\n            c = _.pow(b.clone(), new Symbol(2));\r\n            if(raw)\r\n                return [a, b, d];\r\n            sqrt_a = math.sqrt(a);\r\n            e = _.divide(math.sqrt(c), sqrt_a.clone());\r\n            //calculate d which is the constant\r\n            d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));\r\n            //compute the square part\r\n            sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\r\n            return {\r\n                a: sym,\r\n                c: d,\r\n                f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\r\n            };\r\n        },\r\n        Simplify: {\r\n            strip: function (symbol) {\r\n                var c = _.parse(symbol.multiplier);\r\n                symbol.toUnitMultiplier();\r\n                var p = _.parse(symbol.power);\r\n                symbol.toLinear();\r\n                return [c, p, symbol];\r\n            },\r\n            unstrip: function (cp, symbol) {\r\n                var c = cp[0];\r\n                var p = cp[1];\r\n                return _.multiply(c, _.pow(symbol, p));\r\n            },\r\n            complexSimp: function (num, den) {\r\n                var ac, bd, bc, ad, cd, r1, r2, i1, i2;\r\n                r1 = num.realpart();\r\n                i1 = num.imagpart();\r\n                r2 = den.realpart();\r\n                i2 = den.imagpart();\r\n                //apply complex arithmatic rule\r\n                ac = _.multiply(r1.clone(), r2.clone());\r\n                bd = _.multiply(i1.clone(), i2.clone());\r\n                bc = _.multiply(r2.clone(), i1);\r\n                ad = _.multiply(r1, i2.clone());\r\n                cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\r\n\r\n                return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\r\n            },\r\n            trigSimp: function (symbol) {\r\n                if(symbol.containsFunction(['cos', 'sin', 'tan'])) {\r\n                    symbol = symbol.clone();\r\n                    //remove power and multiplier\r\n                    var sym_array = __.Simplify.strip(symbol);\r\n                    symbol = sym_array.pop();\r\n                    //the default return value is the symbol\r\n                    var retval = symbol.clone();\r\n\r\n                    //rewrite the symbol\r\n                    if(symbol.group === CP) {\r\n                        var sym = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            //rewrite the function\r\n                            var tr = __.Simplify.trigSimp(x.fnTransform());\r\n                            sym = _.add(sym, tr);\r\n                        }, true);\r\n\r\n                        //put back the power and multiplier and return\r\n                        retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\r\n                    }\r\n                    else if(symbol.group === CB) {\r\n\r\n                        var n = symbol.getNum();\r\n                        var d = symbol.getDenom();\r\n\r\n                        //try for tangent\r\n                        if(n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\r\n                            retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\r\n                        }\r\n                        if(retval.group === CB) {\r\n                            var t = new Symbol(1);\r\n                            retval.each(function (x) {\r\n                                if(x.fname === 'tan') {\r\n                                    x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\r\n                                }\r\n                                t = _.multiply(t, x);\r\n                            });\r\n                            retval = t;\r\n                        }\r\n                    }\r\n\r\n\r\n                    retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\r\n\r\n                    symbol = retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            fracSimp: function (symbol) {\r\n                //try a quick simplify of imaginary numbers\r\n                var den = symbol.getDenom();\r\n                var num = symbol.getNum();\r\n\r\n                if(num.isImaginary() && den.isImaginary())\r\n                    symbol = __.Simplify.complexSimp(num, den);\r\n\r\n                if(symbol.isComposite()) {\r\n                    if(symbol.power > 1) {\r\n                        symbol = _.expand(symbol);\r\n                    }\r\n\r\n                    var symbols = symbol.collectSymbols();\r\n                    //assumption 1.\r\n                    //since it's a composite, it has a length of at least 1\r\n                    var retval, a, b, d1, d2, n1, n2, x, y, c, den, num;\r\n                    a = symbols.pop(); //grab the first symbol\r\n                    //loop through each term and make denominator common\r\n                    while(symbols.length) {\r\n                        b = symbols.pop(); //grab the second symbol\r\n                        d1 = _.parse(a.getDenom());\r\n                        d2 = _.parse(b.getDenom());\r\n                        n1 = a.getNum();\r\n                        n2 = b.getNum();\r\n                        c = _.multiply(d1.clone(), d2.clone());\r\n                        x = _.multiply(n1, d2);\r\n                        y = _.multiply(n2, d1);\r\n                        a = _.divide(_.add(x, y), c);\r\n                    }\r\n                    den = _.expand(a.getDenom());\r\n                    num = _.expand(a.getNum());\r\n\r\n                    //simplify imaginary\r\n                    if(num.isImaginary() && den.isImaginary()) {\r\n                        retval = __.Simplify.complexSimp(num, den);\r\n                    }\r\n                    else {\r\n                        retval = _.divide(num, den);\r\n                    }\r\n\r\n                    //we've already hit the simplest form so return that\r\n                    if(retval.equals(symbol)) {\r\n                        return symbol;\r\n                    }\r\n\r\n                    //otherwise simplify it some more\r\n                    return __.Simplify.simplify(retval);\r\n                }\r\n                return symbol;\r\n            },\r\n            ratSimp: function (symbol) {\r\n                if(symbol.group === CB) {\r\n                    var den = symbol.getDenom();\r\n                    var num = symbol.getNum().distributeMultiplier();\r\n                    var d = __.Simplify.fracSimp(den);\r\n                    var n = __.Simplify.fracSimp(num);\r\n                    symbol = _.divide(n, d);\r\n                }\r\n                return symbol;\r\n            },\r\n            sqrtSimp: function (symbol, sym_array) {\r\n                var retval;\r\n                if(symbol.isSQRT()) {\r\n                    var factored = __.Factor.factor(symbol.args[0].clone());\r\n                    var m = _.parse(factored.multiplier);\r\n                    var sign = m.sign();\r\n\r\n                    var retval = _.sqrt(m.abs());\r\n                    var arg;\r\n\r\n                    if(isInt(retval)) {\r\n\r\n                        if(factored.group === CB) {\r\n                            var rem = new Symbol(1);\r\n\r\n                            factored.each(function (x) {\r\n                                if(x.group === N) {\r\n                                    var trial = _.sqrt(x.clone());\r\n\r\n                                    // Multiply back sqrt if it's an integer otherwise just put back the number\r\n                                    if(isInt(trial)) {\r\n                                        retval = _.multiply(retval, trial);\r\n                                    }\r\n                                    else {\r\n                                        rem = _.multiply(rem, x);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    rem = _.multiply(rem, x);\r\n                                }\r\n\r\n                            });\r\n                            var t = _.multiply(rem, _.parse(sign));\r\n                            arg = _.sqrt(t.clone());\r\n\r\n                            // Expand if it's imaginary\r\n                            if(arg.isImaginary) {\r\n                                arg = _.sqrt(_.expand(t.clone()));\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Strip the multiplier\r\n                            arg = _.sqrt(factored.clone().toUnitMultiplier());\r\n                        }\r\n                        return _.multiply(retval, arg);\r\n\r\n                    }\r\n\r\n                }\r\n                else if(symbol.isComposite() && symbol.isLinear()) {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, __.Simplify.sqrtSimp(x));\r\n                    }, true);\r\n                    // Put back the multiplier\r\n                    retval = _.multiply(retval, _.parse(symbol.multiplier));\r\n                }\r\n                else if(symbol.group === CB) {\r\n                    retval = _.parse(symbol.multiplier);\r\n                    symbol.each(function (x) {\r\n                        var simp = __.Simplify.sqrtSimp(x);\r\n                        retval = _.multiply(retval, simp);\r\n\r\n                    }, true);\r\n                    // Put back the power\r\n                    retval = _.pow(retval, _.parse(symbol.power));\r\n                }\r\n\r\n                return retval ? retval : _.parse(symbol);\r\n            },\r\n            /**\r\n             * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n             * @param {Symbol} symbol\r\n             * @return {Array} The symbol and the matched patterns\r\n             */\r\n            patternSub: function (symbol) {\r\n                var patterns = {};\r\n\r\n                var has_CP = function (symbol) {\r\n                    var found = false;\r\n                    symbol.each(function (x) {\r\n                        if(x.group === CP) {\r\n                            found = true;\r\n                        }\r\n                        else if(x.symbols) {\r\n                            found = has_CP(x);\r\n                        }\r\n                    });\r\n\r\n                    return found;\r\n                };\r\n\r\n                var collect = function (sym) {\r\n                    // We loop through each symbol looking for anything in the simplest\r\n                    // form of ax+byz+...\r\n                    sym.each(function (x) {\r\n                        // Items of group N,P,S, need to apply\r\n                        if(!x.symbols && x.group !== FN) {\r\n                            return;\r\n                        }\r\n\r\n                        // Check to see if it has any symbols of group CP\r\n                        // Get the patterns in that symbol instead if it has anything of group CP\r\n                        if(has_CP(x)) {\r\n                            collect(x);\r\n                        }\r\n                        else {\r\n                            if(!patterns[x.value]) {\r\n                                var u = core.Utils.getU(symbol);\r\n                                // Get a u value and mark it for subsitution\r\n                                patterns[x.value] = u;\r\n                                symbol = symbol.sub(x.value, u);\r\n                            }\r\n                        }\r\n                    }, true);\r\n                };\r\n\r\n                // Collect a list of patterns\r\n                collect(symbol);\r\n\r\n                return [symbol, patterns];\r\n            },\r\n            simplify: function (symbol) {\r\n                //remove the multiplier to make calculation easier;\r\n                var sym_array = __.Simplify.strip(symbol);\r\n                symbol = sym_array.pop();\r\n                //remove gcd from denominator\r\n                symbol = __.Simplify.fracSimp(symbol);\r\n\r\n                //nothing more to do\r\n                if(symbol.isConstant() || symbol.group === core.groups.S) {\r\n                    sym_array.push(symbol);\r\n                    var ret = __.Simplify.unstrip(sym_array, symbol);\r\n                    return ret;\r\n                }\r\n\r\n                //var patterns;\r\n\r\n                var simplified = symbol.clone(); //make a copy\r\n\r\n                //[simplified, patterns] = __.Simplify.patternSub(symbol);\r\n\r\n                // Simplify sqrt within the symbol\r\n//                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\r\n\r\n                // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\r\n                simplified = __.Simplify.trigSimp(simplified);\r\n\r\n                // Simplify common denominators\r\n                simplified = __.Simplify.ratSimp(simplified);\r\n\r\n                // First go for the \"cheapest\" simplification which may eliminate \r\n                // your problems right away. factor -> evaluate. Remember\r\n                // that there's no need to expand since factor already does that\r\n\r\n                simplified = __.Factor.factor(simplified);\r\n\r\n                //If the simplfied is a sum then we can make a few more simplifications\r\n                //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\r\n                if(simplified.group === core.groups.CP && simplified.isLinear()) {\r\n                    var m = simplified.multiplier.clone();\r\n                    simplified.toUnitMultiplier(); //strip the multiplier\r\n                    var r = new Symbol(0);\r\n                    //return the sum of simplifications\r\n                    simplified.each(function (x) {\r\n                        var s = __.Simplify.simplify(x);\r\n                        r = _.add(r, s);\r\n                    });\r\n                    simplified = r;\r\n                    //put back the multiplier\r\n                    r.multiplier = r.multiplier.multiply(m);\r\n                }\r\n\r\n                //place back multiplier and return\r\n                var retval = __.Simplify.unstrip(sym_array, simplified);\r\n\r\n                // Back substitute\r\n                /*\r\n                 for(var x in patterns) {\r\n                 retval = retval.sub(patterns[x], x);\r\n                 }\r\n                 */\r\n\r\n                return retval;\r\n            }\r\n        },\r\n\r\n        Classes: {\r\n            Polynomial: Polynomial,\r\n            Factors: Factors,\r\n            MVTerm: MVTerm\r\n        }\r\n    };\r\n\r\n    // Add a link to simplify\r\n    core.Expression.prototype.simplify = function () {\r\n        return __.Simplify.simplify(this.symbol);\r\n    };\r\n\r\n    nerdamer.useAlgebraDiv = function () {\r\n        var divide = __.divideFn = _.divide;\r\n        var calls = 0; //keep track of how many calls were made\r\n        _.divide = function (a, b) {\r\n            calls++;\r\n            var ans;\r\n            if(calls === 1) //check if this is the first call. If it is use algebra divide\r\n                ans = core.Algebra.divide(a, b);\r\n            else //otherwise use parser divide\r\n                ans = divide(a, b);\r\n            calls = 0; //reset the number of calls back to none\r\n            return ans;\r\n        };\r\n    };\r\n\r\n    nerdamer.useParserDiv = function () {\r\n        if(__.divideFn)\r\n            _.divide = __.divideFn;\r\n        delete __.divideFn;\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'factor',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Factor.factor;\r\n            }\r\n        },\r\n        {\r\n            name: 'simplify',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Simplify.simplify;\r\n            }\r\n        },\r\n        {\r\n            name: 'gcd',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.gcd;\r\n            }\r\n        },\r\n        {\r\n            name: 'lcm',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.lcm;\r\n            }\r\n        },\r\n        {\r\n            name: 'roots',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.roots;\r\n            }\r\n        },\r\n        {\r\n            name: 'divide',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.divide;\r\n            }\r\n        },\r\n        {\r\n            name: 'div',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.div;\r\n            }\r\n        },\r\n        {\r\n            name: 'partfrac',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.PartFrac.partfrac;\r\n            }\r\n        },\r\n        {\r\n            name: 'deg',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.degree;\r\n            }\r\n        },\r\n        {\r\n            name: 'coeffs',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function () {\r\n                    var coeffs = __.coeffs.apply(__, arguments);\r\n                    return new core.Vector(coeffs);\r\n                };\r\n                return f;\r\n            }\r\n        },\r\n        {\r\n            name: 'line',\r\n            visible: true,\r\n            numargs: [2, 3],\r\n            build: function () {\r\n                return __.line;\r\n            }\r\n        },\r\n        {\r\n            name: 'sqcomp',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function (x, v) {\r\n                    try {\r\n                        v = v || variables(x)[0];\r\n                        var sq = __.sqComplete(x.clone(), v);\r\n                        return sq.f;\r\n                    }\r\n                    catch(e) {\r\n                        return x;\r\n                    }\r\n                };\r\n                return f;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.api();\r\n})();"]},"metadata":{},"sourceType":"script"}