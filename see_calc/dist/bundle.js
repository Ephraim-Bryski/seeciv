/*! For license information please see bundle.js.LICENSE.txt */
(()=>{var t={647:t=>{const e=["+","-","*","/","^"],r={"-":"+","/":"*","+":"-","*":"/"},n={"-":"*","/":"^","+":"*","*":"^"};function o(t){const e={"+":0,"-":0,"*":1,"/":1.5,"^":2};if(!Object.keys(e).includes(t))throw"opeartion "+t+" has no priority defined";return e[t]}const s={"+":"0","*":"1"},i={"+":function(t,e){if(p(t)||p(e))return String(c(t)+c(e));const[r,n]=u(t),[o,s]=u(e),i=n*s;return f(i/n*r+i/s*o,i)},"*":function(t,e){if(p(t)||p(e))return String(c(t)*c(e));const[r,n]=u(t),[o,s]=u(e);return f(r*o,n*s)}};function f(t,e){let r=Number(t),n=Number(e);const o=function(t,e){for(e>t&&([t,e]=[e,t]);0!==e;){const r=t%e;t=e,e=r}return t}(Math.abs(r),Math.abs(n));r>0&&n<0&&(r=-r,n=-n);const s=r/o,i=n/o;return 1===i?(-1===i&&console.log("HI"),String(s/i)):String(s)+"/"+String(i)}function u(t){let e;return e=J(t)?t.split("/"):[t,"1"],e.map(Number)}function c(t){const e=u(t);return e[0]/e[1]}function p(t){return!J(t)&&Math.round(Number(t))!==Number(t)}const l=["+","*"],m=[["sin","sec","tan"],["cos","csc","cot"]].flat(),h=m.map((t=>"a"+t)),a=[m,h].flat(),d=a.map((t=>t+"h")),g=[a,d].flat().map((t=>t+"(")),b={};g.forEach((t=>{let e;e="a"===t[0]?t.slice(1):"a"+t,b[t]=e}));const y="(",w="sqrt(",v=[y,w].concat(g);function N(t){const r=function t(r){const n={terms:[]};if(1===r.length){const e=r[0],o=e.indexOf("(")+1,s=e.slice(0,o),i=e[e.length-1],f=v.includes(s);if(f!==(")"===i))throw"shouldnt happen "+e;if(f){n.op=s;const r=S(e.slice(o,e.length-1));return n.terms[0]=t(r),n}return e}const o=r.findIndex((t=>e.includes(t))),s=r.slice(0,o),i=r.slice(o+1),f=r[o];return n.op=f,n.terms[0]=t(s),n.terms[1]=t(i),n}(S(t));return function(t){let e=!0;for(;e;){const n=JSON.stringify(t);r(t),e=n!==JSON.stringify(t)}function r(t){if("string"==typeof t)return;t.terms.forEach(r);const e=t.op;if(v.includes(e))return;const n=t.terms[1].op;if(v.includes(n))return;if(void 0===n)return;const s=o(e),i=o(n);if(s>i||s===i&&"^"!==n){const r=t.terms[0],o=t.terms[1].terms[0],s=t.terms[1].terms[1];t.op=n;const i={};i.op=e,i.terms=[],i.terms[0]=r,i.terms[1]=o,t.terms=[],t.terms[0]=i,t.terms[1]=s}}r(t)}(r),E(r),_(r),M(r),Z(r)}function S(t){"-"===t[0]&&(t="0"+t);let e=t.match(/[+\-*/()^]|\b[0-9]+(?:\.[0-9]+)?\b|\b[a-zA-Z]+(?:[0-9]+)?\b/g);const r=[];e.forEach(((t,e)=>{v.includes(t+"(")&&r.push(e)})),r.forEach((t=>{e[t]=e[t]+"(",e[t+1]=""})),e=e.filter((t=>""!==t));var n=[],o="",s=!1,i=0;return e.forEach((t=>{if(s){if(o+=t,v.includes(t)?i+=1:")"===t&&(i-=1),i<-1)throw"shouldnt happen";-1===i&&(s=!1,n.push(o),o="",i=0)}else if(v.includes(t))s=!0,o+=t;else{if(")"===t)throw"this shouldnt happen";n.push(t)}})),n}function E(t,e){if("string"!=typeof t){if(t.op===y){const r=t.terms[0].terms;if(void 0===r){if(void 0===e)throw"this is probably where its just a single variable wrapped in parentheses";const r=e.terms.map((e=>e===t?t.terms[0]:e));e.terms=r}else t.op=t.terms[0].op,t.terms=r}t.terms.forEach((e=>{E(e,t)}))}}function _(t){"string"!=typeof t&&(t.op===w&&(t.op="^",t.terms=[t.terms[0],"1/2"]),t.terms.forEach(_))}function M(t){if("string"!=typeof t){if(["-","/"].includes(t.op)){t.op=r[t.op];const e=t.terms[1];let o;if(e.op===t.op){const r=e.terms.map((e=>({op:n[t.op],terms:[e,"-1"]})));o={op:t.op,terms:r}}else o={op:n[t.op],terms:[e,"-1"]};t.terms[1]=o}t.terms.forEach(M)}}function k(t){return t.terms[1]}function x(t){const e=t.terms.filter(I);if(0===e.length)return"1";if(1===e.length)return e[0];throw"should have already been simplified"}function O(t){return[t.terms[0]]}function j(t){return t.terms.filter((t=>!I(t)))}const A=function(t,e){const r=Math.pow(Math.abs(-1),.5),n=.5*Math.PI*1;return{real:r*Math.cos(n),imaginary:r*Math.sin(n)}}();function $(t){if("string"==typeof t)return t;if("*"===t.op&&t.terms.includes("0"))return"0";if("^"===t.op&"0"===t.terms[0]){const e=Number(t.terms[1]);if(0===e)throw"0/0 found";if(e<0)throw"infinite value found"}if("^"===t.op&&"0"===t.terms[1])return"1";if("^"===t.op&&"1"===t.terms[1])return t.terms[0];if("^"===t.op&&"0"===t.terms[0])return"0";if("^"===t.op&&"1"===t.terms[0])return"1";if("^"===t.op){if(t.terms.every(I)){const e=function(t,e){const r=c(t),n=c(e),o=Math.round(r)===r,s=Math.round(n)===n;return o&&s&&n<0?f("1",String(r**-n)):String(t**e)}(t.terms[0],t.terms[1]);return String(e)}if(t.op===t.terms[0].op)return Z({op:"^",terms:[t.terms[0].terms[0],{op:"*",terms:[t.terms[0].terms[1],t.terms[1]]}]});if("*"===t.terms[0].op){const e=t.terms[1],r=t.terms[0].terms,n=r.filter(I);J(e)||e.includes(".");return 0!==n.length&&Number(n),r.some(I),Z({op:"*",terms:r.map((t=>({op:"^",terms:[t,e]})))})}return t}if(l.includes(t.op)){const e=t.terms.filter(I),r=t.terms.filter((t=>!e.includes(t))),n=i[t.op];let o=s[t.op];e.forEach((t=>{o=n(o,t)}));const f=String(o),u=t.terms.every(I),c="+"===t.op&&"0"===f||"*"===t.op&&"1"===f,p=c&&1===r.length;let l;if(u)l=f;else if(p)l=r[0];else if(c){const e=r;l={op:t.op,terms:e}}else{const e=[r,f].flat();l={op:t.op,terms:e}}return l}if(g.includes(t.op)){if(I(t.terms[0]))return function(t,e){const r=t+String(c(e))+")";return math.evaluate(r)}(t.op,t.terms[0]);const e=t.terms[0].op,r=t.op;return b[r]===e?t.terms[0].terms[0]:t}throw"all cases should have been handled"}function z(t){const e=Object.keys(t).filter((t=>"inverted"!==t)).sort(),r=["op","terms"];return e.every(((t,n)=>e[n]===r[n]))}function I(t){if("string"!=typeof t&&!z(t))throw"must only check a string or a tree";if(z(t))return!1;const e=!isNaN(Number(t));return J(t)||e}function J(t){if("string"!=typeof t&&!z(t))throw"must only check a string or a tree";if(z(t))return!1;const e=t.split("/");if(2!==e.length)return!1;const r=e[0],n=e[1];return!isNaN(Number(r))&&!isNaN(Number(n))}function Z(t,e){if("string"==typeof t)return t;t.terms.forEach((e=>{Z(e,t)}));const r=function(t){if(1===t.terms.length){if(g.includes(t.op))return t;throw"i thought this case would no longer occur with how i simplify arithmetic"}if(!["+","*"].includes(t.op))return t;const e=t.terms.map((e=>"string"!=typeof e&&t.op===e.op?e.terms:e)).flat();return{op:t.op,terms:e}}(t);let o;if(["+","*"].includes(r.op)){let f,u;"+"===r.op?(f=x,u=j):(f=k,u=O);const c=n[r.op],p=r.terms.map((t=>{if(t.op===c)return t;if("*"===c)return{op:c,terms:[t]};if("^"===c)return{op:c,terms:[t,"1"]};throw"that should be all cases"}));function s(t){return l.flat().includes(t)}const l=[];p.forEach((t=>{if(s(t))return;const e=[t];l.push(e),p.forEach((r=>{s(r)||function(t,e){return r(t,e);function r(t,e,r){if(t.length!==e.length)return!1;if(r)return t.every(((r,o)=>n(t[o],e[o])));const o=new Array(e.length).fill(!1);for(let r=0;r<t.length;r++){const s=t[r];let i=!1;for(let t=0;t<e.length;t++)if(!o[t]&&n(s,e[t])){o[t]=!0,i=!0;break}if(!i)return!1}return!0}function n(t,e){if("string"==typeof t||"string"==typeof e)return t===e;if(t.op!==e.op)return!1;const n="^"===t.op;return r(t.terms,e.terms,n)}}(u(t),u(r))&&e.push(r)}))})),new_terms=l.map((t=>{const e=t.map(f);let n;if("*"===r.op)n=Z({op:"+",terms:e.concat("0")});else{if("+"!==r.op)throw"should be one of those two operations";n=$({op:"+",terms:e})}const o=u(t[0]);return $({op:c,terms:[o,n].flat()})})),o=1===new_terms.length?new_terms[0]:{op:r.op,terms:new_terms}}else o=r;const i=$(o);if(void 0===e)return i;!function(t,e,r){const n=[...Array(e.terms.length).keys()].filter((r=>e.terms[r]===t));if(0===n.length)throw"tree not child of parent";if(n.length>1)throw"tree in multiple places????";const o=n[0];e.terms[o]=r}(t,e,i)}function q(t,e=!1,r){if("string"==typeof t)return t;const n=(t=H(t)).terms.map((r=>{let n;return"string"==typeof r?(n=r,"^"===t.op&&J(r)&&(n="("+n+")")):n=q(r,e,t),n}));let s,f;if("/"===t.op){const t=n[0],r=n[1];s=e?`\\frac{${t}}{${r}}`:`${t}/${r}`}else if("^"===t.op){const t=n[0],r=n[1];s=e?t+"^{"+r+"}":t+"^"+r}else{if(v.includes(t.op)){const r=n[0];let o=t.op;return e&&(o="\\"+o),o+r+")"}if(!Object.keys(i).includes(t.op))throw"all operations should have been handled";{let r;r="*"===t.op&&e?"\\cdot ":t.op;const o=n.filter(I),i=n.filter((t=>!I(t)));if(o.length>1)throw"there should only be one coefficient";let f;if("+"===t.op)f=n;else{if("*"!==t.op)throw"there shouldn't be any other cumulative operation";f=o.concat(i)}s=f.map(((t,e)=>0===e?t:r+t)),s=s.join("")}}return f=void 0!==r&&(("^"!==r.op||!e)&&(("/"!==r.op||!e)&&(("/"!==r.op||1!==t.terms.length)&&(!g.includes(r.op)&&!g.includes(t.op)&&o(r.op)>o(t.op))))),f&&(s="("+s+")"),s=s.replace(/(?<=[^a-zA-Z0-9])1\*/g,""),s=s.replaceAll("+-","-"),s}function H(t){if("string"==typeof t&&!J(t))return t;if("string"!=typeof t&&(t.terms=t.terms.map(H)),"*"===t.op){let e=[],r=[];return t.terms.forEach((t=>{"/"===t.op?(e.push(t.terms[0]),r.push(t.terms[1])):e.push(t)})),e=e.filter((t=>"1"!==t)),r=r.filter((t=>"1"!==t)),0===e.length&&(e=["1"]),0!==r.length?(num_tree={op:"*",terms:e},den_tree={op:"*",terms:r},{op:"/",terms:[num_tree,den_tree]}):t}if("^"===t.op){const e=t.terms[0],r=t.terms[1];let n;if("string"==typeof r&&I(r))n=r;else if("*"===r.op){const t=r.terms.filter(I);if(t.length>1)throw"should have been condensed to one coefficient";n=1===t.length?t[0]:"1"}else n="1";if(0===Number(n))throw"zero coefficient should have been simplified";if(Number(n)>0)return t;const o=String(-Number(n));let s,i;return"string"==typeof r?s=o:(s={...r},s.terms[s.terms.length-1]=o),i=1===Number(s)?e:{op:"^",terms:[e,s]},{op:"/",terms:["1",i]}}return J(t)?([num,den]=u(t),{op:"/",terms:[String(num),String(den)]}):t}console.log(A),console.log(A),q(N("a/b")),t.exports={back_and_forth:(t,e=!1)=>q(N(t),e),arithmetic_check:function(t){return math.evaluate(t)===q(N(t))}}}},e={};!function r(n){var o=e[n];if(void 0!==o)return o.exports;var s=e[n]={exports:{}};return t[n](s,s.exports,r),s.exports}(647)})();