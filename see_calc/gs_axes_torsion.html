<link type="text/css" href="https://www.glowscript.org/css/redmond/2.1/jquery-ui.custom.css" rel="stylesheet" />

<script type="text/javascript" src="https://www.glowscript.org/lib/jquery/2.1/jquery.min.js"></script>
<script type="text/javascript" src="https://www.glowscript.org/lib/jquery/2.1/jquery-ui.custom.min.js"></script>
<script type="text/javascript" src="https://www.glowscript.org/package/glow.3.0.min.js"></script>
<script type="text/javascript" src="https://www.glowscript.org/package/RSrun.3.0.min.js"></script>


<div id="test" style="width:70%;height:70%"></div>

<button onclick="refresh()">REFRESH</button>

<script>
  var graphDiv = $("#test")[0]
      window.__context= {glowscript_container: graphDiv}  
    scene=canvas({width: graphDiv.offsetWidth,height: graphDiv.offsetHeight,resizable: true,userzoom: true,autoscale: true,background:color.white})

    var coord_length = 10
    var dir_cols = [vec(1,0,0),vec(0,1,0),vec(0,0,1)]
    var dir_txts = ["x","y","z"]
    for (let dir_i=0;dir_i<3;dir_i++){

      for (let i=-coord_length;i<=coord_length;i+=2){
        var txt_offset = 0.3
        var txt_loc = [0,0,0]
        txt_loc[dir_i] = i

        var offset_dir = dir_i+1
        if(dir_i===2){offset_dir = 1}
        txt_loc[offset_dir] = txt_offset
        label({pos:vec(...txt_loc),text:i.toString(),box:false,opacity:0,color:dir_cols[dir_i]})
      }

      var ax_dir = [0,0,0]
      ax_dir[dir_i] = 2*coord_length
      var ax_pos = [0,0,0]
      ax_pos[dir_i] = -coord_length
      cylinder({pos:vec(...ax_pos),axis:vec(...ax_dir),radius:0.1,color:dir_cols[dir_i]})

      var txt_pos = [0,0,0]
      txt_pos[dir_i] = coord_length+1
      label({pos:vec(...txt_pos),text:dir_txts[dir_i],color:dir_cols[dir_i],box:false,opacity:0})

      var cone_pos = [0,0,0]
      cone_pos[dir_i] = coord_length
      var ax_dir = [0,0,0]
      ax_dir[dir_i] = 0.5
      cone({pos:vec(...cone_pos),axis:vec(...ax_dir),radius:0.2,color:dir_cols[dir_i]})
    }

    scene.forward=vec(1,-0.5,-1)
    //scene.forward=vec(-1,1,0)
    scene.up = vec(0,1,0)

    scene.range = scene.range+2




    function refresh(){
      console.log("HI")
      setUpGS()
      
      zs = [0,3,8,12]
      rs = [4,3,2]
      thetas = [0,0.1,0.3,0.5]

      for (let i=0;i<3;i++){
          var h = zs[i+1]-zs[i]
          make_rod(rs[i],h,zs[i],thetas[i],thetas[i+1])
      }

    }

    var naive = false


    function setUpGS(){
      if (naive){
        function removeAllChildNodes(parent) {
            while (parent.firstChild) {
                parent.removeChild(parent.firstChild);
            }
        }
        removeAllChildNodes(document.getElementById("test"))
        
        
        var graphDiv = document.getElementById("test")
        window.__context= {glowscript_container: graphDiv}  
        scene=canvas({width: graphDiv.offsetWidth,height: graphDiv.offsetHeight,resizable: true,userzoom: true,autoscale: true})
        scene.forward=vec(1,-0.5,-1)
      }

      else{
        var reached_coord_labels = false
        scene.objects.forEach(obj=>{
          if (obj.constructor.name==="label"){
            reached_coord_labels = true
            return
          }
          if (!reached_coord_labels){return}
          obj.visible=false
        })
      }





        //makeCoordShape()
    }



    function make_rod(r,h,z0,theta1,theta2){
        // for now im assuming it's along the z axis

    
        //z0 = z0-0.1

        
        var nCoils=8

        var thick=.01

        var gridColor = color.blue




        var rod=cylinder({pos: vec(0,0,z0), axis:vec(0,0,h),opacity: 1,radius:r,opacity:0.9})



        var phi = theta2-theta1
        
        var coils=[]
        var nCoilPoints=10  // number of points on helix
        for (let i=0;i<nCoils;i++){


            var coilPoints=[]
            for (let j=0;j<nCoilPoints;j++){
                var angle=phi*j/(nCoilPoints-1)+2*Math.PI*i/nCoils+theta1
                coilPoints[j]=vec(r*cos(angle),r*sin(angle),z0+h*j/(nCoilPoints-1))
                //coils[i].modify(j,coilPoints[j])
                
            }



            coils[i]=curve({pos: coilPoints,thickness: thick, color: gridColor})
        }



        




            
        /*

        var thetaGrid=[]
        var yGrid=[]
        
        var gap=0.001    // gap so it's not directly on cylinder

        var rGrid=math.multiply(math.ones(nPatchPoints,nPatchPoints)._data,r+gap)

        for (let i=0;i<nPatchPoints;i++){
            yGrid[i]=Array(nPatchPoints).fill(h*i/((nRings-1)*(nPatchPoints-1))+h*nYSec/(nRings-1))
            thetaGrid[i]=[]

            for (let j=0;j<nPatchPoints;j++){
                var shiftR=2*Math.PI/(nCoils)*j/(nPatchPoints-1)
                var shiftY=phi/(nRings-1)*i/(nPatchPoints-1)
                thetaGrid[i].push(-(shiftR+shiftY+nYSec/(nRings-1)*phi))

            }
        }
        xGrid=math.dotMultiply(rGrid,math.cos(thetaGrid))
        zGrid=math.dotMultiply(rGrid,math.sin(thetaGrid))

        changeSurf(patch,xGrid,yGrid,zGrid)
        //#endregion
        
        //#region <change arrows>
        for (let sideN=0;sideN<2;sideN++){
            if      (sideN==0){var y=h; var sign=-1}
            else if (sideN==1){var y=0; var sign=1}

            for (let i=0;i<nArrowsS;i++){
                var thetaArrow=2*Math.PI*i/nArrowsS
                for (let j=0;j<nArrowsR;j++){
                    var arrowSel=arrowGroup[sideN][i][j]
                    var arrowR=0.9*r*(j+1)/5
                    var mag=s_max*sign*arrowR/r



                    arrowSel.pos=vec(arrowR*cos(thetaArrow),y,arrowR*sin(thetaArrow))
                    arrowSel.axis=vec(-mag*sin(thetaArrow)*arrowScale,0,mag*cos(thetaArrow)*arrowScale)
                }

            }
        }
        */
    }
            //#endregion

</script>


