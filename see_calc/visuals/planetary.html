<!DOCTYPE html>



<meta http-equiv="Content-Type" content="text/html; charset=utf-8">



<link type="text/css" href="https://www.glowscript.org/css/redmond/2.1/jquery-ui.custom.css" rel="stylesheet" />
<link type="text/css" href="https://www.glowscript.org/css/ide.css" rel="stylesheet" />
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>




<script type="text/javascript" src="https://www.glowscript.org/lib/jquery/2.1/jquery.min.js"></script>
<script type="text/javascript" src="https://www.glowscript.org/lib/jquery/2.1/jquery-ui.custom.min.js"></script>
<script type="text/javascript" src="https://www.glowscript.org/package/glow.3.0.min.js"></script>
<script type="text/javascript" src="https://www.glowscript.org/package/RSrun.3.0.min.js"></script>

<div id="vis" style="width:100%;height:100%"></div>

<script>


    window.__context= {glowscript_container: $("#vis")[0]}  
    canvas()

    const depth = 1
    const axis = vec(0,0,depth)
    const spoke_color = color.black 
    const base_spoke_angles = [0,Math.PI/2,Math.PI,3*Math.PI/2]

    make_planetary(2,1,1,2,1,60,20,0,30,color.white,color.red,color.green)




    function make_planetary(x,y,z,R_s,R_p,angle_s,angle_p,angle_c,angle_r,color_s,color_p,color_r){
        
        const R_ring = R_s+R_p*2
        const R_case = R_s+R_p
        make_gear(x,y,z,R_s,angle_s,color_s)
        make_ring_gear(x,y,z,R_ring,angle_r,color_r)

        const n_planets = 3

        for(let i=0;i<n_planets;i++){
            const base_orbit_angle = i/n_planets*2*Math.PI
            const orbit_angle = base_orbit_angle+angle_c*Math.PI/180
            const planet_x = x+R_case*Math.cos(orbit_angle)
            const planet_y = y+R_case*Math.sin(orbit_angle)
            make_gear(planet_x,planet_y,z,R_p,angle_p,color_p)
        }
    }

    function make_ring_gear(x,y,z,inner_R,theta,gear_color){
        const center = vec(x,y,z)

        const thickness = 0.1*inner_R   // arbitrary
        const outer_R = inner_R + thickness

        const thickness_ratio = (outer_R-inner_R)/outer_R
        const ring_shape = shapes.circle({radius:outer_R,thickness: thickness_ratio})
        
        
        const line_path = [center,center.add(axis)]
        extrusion({shape: ring_shape, path: line_path,color:gear_color})

        for (base_angle of base_spoke_angles){
            const angle = base_angle+theta*Math.PI/180
            const x1 = x+inner_R*Math.cos(angle)
            const y1 = y+inner_R*Math.sin(angle)
            const x2 = x+outer_R*Math.cos(angle)
            const y2 = y+outer_R*Math.sin(angle)    
            const z_F = z
            const z_B = z+depth
            curve({pos:[vec(x1,y1,z_F),vec(x2,y2,z_F)],color:spoke_color})
            curve({pos:[vec(x1,y1,z_B),vec(x2,y2,z_B)],color:spoke_color})
            curve({pos:[vec(x1,y1,z_F),vec(x1,y1,z_B)],color:spoke_color})
            curve({pos:[vec(x2,y2,z_F),vec(x2,y2,z_B)],color:spoke_color})
        }
    }

    function make_gear(x,y,z,R,theta,gear_color){

        cylinder({pos:vec(x,y,z), axis: axis,radius:R,color:gear_color})

        
        const angles = base_spoke_angles.map(angle => {return angle+theta*Math.PI/180})
        
        // gonna assume along z axis
        const spoke_points_F = angles.map(angle => {
            const x_pos = x+R*Math.cos(angle)
            const y_pos = y+R*Math.sin(angle)
            return vec(x_pos,y_pos,z)
        })


        const spoke_points_B = spoke_points_F.map(point => {
            return point.add(axis)
        })

        curve({pos:[spoke_points_F[0],spoke_points_F[2]],color:spoke_color})
        curve({pos:[spoke_points_F[1],spoke_points_F[3]],color:spoke_color})

        
        curve({pos:[spoke_points_B[0],spoke_points_B[2]],color:spoke_color})
        curve({pos:[spoke_points_B[1],spoke_points_B[3]],color:spoke_color})

        spoke_points_F.forEach((point_F,idx)=>{
            const point_B = spoke_points_B[idx]
            curve({pos:[point_F,point_B], color:spoke_color})
        })
    }
    

</script>